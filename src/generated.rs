// TCG TPM2 Structures interface code
// Autogenerated with gen-tpm2-cmd-interface version 0.1.0

#![allow(irrefutable_let_patterns)]
#![allow(unused_mut)]
#![allow(unused_variables)]
#![allow(unreachable_code)]
#![allow(unreachable_patterns)]
#![allow(clippy::absurd_extreme_comparisons)]
#![allow(clippy::collapsible_if)]
#![allow(clippy::eq_op)]
#![allow(clippy::identity_op)]
#![allow(clippy::let_and_return)]
#![allow(clippy::let_unit_value)]
#![allow(clippy::needless_borrow)]
#![allow(clippy::needless_lifetimes)]
#![allow(clippy::needless_question_mark)]
#![allow(clippy::needless_return)]
#![allow(clippy::new_without_default)]
#![allow(clippy::result_unit_err)]
#![allow(clippy::unnecessary_fallible_conversions)]

extern crate alloc;
use alloc::{boxed, vec};

#[allow(unused_imports)]
use vec::Vec;
#[allow(unused_imports)]
use boxed::Box;
#[allow(unused_imports)]
use core::cmp;
use core::convert;
use core::mem;
use core::ops;
#[allow(unused_imports)]
use core::ptr;

#[derive(Clone, Copy, Debug)]
pub enum TpmErr {
    Rc(u32),
    InternalErr,
}

#[allow(unused)]
fn copy_vec_from_slice<T: Copy>(slice: &[T]) -> Result<Vec<T>, TpmErr> {
    let mut v = Vec::new();
    v.try_reserve_exact(slice.len()).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))?;
    v.extend_from_slice(slice);
    Ok(v)
}

#[derive(Clone, Debug)]
pub enum TpmBuffer<'a> {
    Borrowed(&'a [u8]),
    Owned(Vec<u8>),
}

impl<'a> TpmBuffer<'a> {
    pub fn into_owned(mut self) -> Result<TpmBuffer<'static>, TpmErr> {
        let o = match &mut self {
            Self::Borrowed(b) => copy_vec_from_slice(b)?,
            Self::Owned(o) => {
                #[allow(clippy::mem_replace_with_default)]
                mem::replace(o, Vec::new())
            },
        };
        Ok(TpmBuffer::<'static>::Owned(o))
    }
}

#[cfg(feature = "zeroize")]
impl<'a> Drop for TpmBuffer<'a> {
    fn drop(&mut self) {
        match self {
            Self::Borrowed(_) => (),
            Self::Owned(o) => {
                #[cfg(feature = "zeroize")]
                <[u8] as zeroize::Zeroize>::zeroize(o.as_mut_slice());
            }
        }
    }
}

impl<'a> ops::Deref for TpmBuffer<'a> {
    type Target = [u8];

    fn deref(&self) -> &Self::Target {
        match self {
            Self::Borrowed(b) => b,
            Self::Owned(o) => o,
        }
    }
}

impl<'a> convert::From<&'a [u8]> for TpmBuffer<'a> {
    fn from(value: &'a [u8]) -> Self {
        Self::Borrowed(value)
    }
}

impl<'a> PartialEq for TpmBuffer<'a> {
    fn eq(&self, other: &Self) -> bool {
        <Self as ops::Deref>::deref(self) == <Self as ops::Deref>::deref(other)
    }
}

#[allow(unused)]
pub fn box_try_new<T>(v: T) -> Result<Box<T>, ()> {
    // Box::try_new() is unstable, so do it by ourselves for now.
    // Refer to https://doc.rust-lang.org/std/boxed/index.html#memory-layout.
    let p: *mut T = if mem::size_of::<T>() == 0 {
        // Dangling pointers are valid for ZSTs and the write below is Ok.
        ptr::NonNull::dangling().as_ptr()
    } else {
        let layout = alloc::alloc::Layout::new::<T>();
        let p: *mut T = unsafe { alloc::alloc::alloc(layout) } as *mut T;
        if p.is_null() {
            return Err(());
        }
        p
    };

    unsafe { p.write(v) };

    Ok(unsafe { Box::from_raw(p) })
}

#[allow(unused)]
#[allow(clippy::boxed_local)]
pub fn box_into_inner<T>(b: Box<T>) -> T {
    // Box::into_inner() is unstable, so do it by ourselves for now.
    *b
}
#[derive(Clone, Debug)]
pub struct TpmLimits {
    pub hash_count: u32,
    pub implementation_pcr: u32,
    pub max_2b_buffer_size: u16,
    pub max_active_sessions: u32,
    pub max_alg_list_size: u32,
    pub max_cap_buffer: u32,
    pub max_context_size: u16,
    pub max_loaded_objects: u32,
    pub max_nv_buffer_size: u16,
    pub max_nv_index_size: u16,
    #[cfg(feature = "rsa")]
    pub max_rsa_key_bytes: u16,
    pub platform_pcr: u32,
    pub private_vendor_specific_bytes: u16,
    #[cfg(feature = "rsa")]
    pub rsa_private_size: u16,
}
impl TpmLimits {
    fn label_max_buffer(&self) -> Result<u16, ()> {
        let max_digest_size = self.max_digest_size()?;
        let max_ecc_key_bytes = self.max_ecc_key_bytes()?;
        Ok(max_digest_size.max(max_ecc_key_bytes).min(32))
    }

    fn max_act_data(&self) -> Result<u32, ()> {
        let max_cap_data = self.max_cap_data()?;
        let max_act_data = max_cap_data.checked_div(tpms_act_data_marshalled_size() as u32).ok_or(())?;
        Ok(max_act_data)
    }

    fn max_ac_capabilities(&self) -> Result<u32, ()> {
        let max_cap_data = self.max_cap_data()?;
        let max_ac_capabilities = max_cap_data.checked_div(tpms_ac_output_marshalled_size() as u32).ok_or(())?;
        Ok(max_ac_capabilities)
    }

    fn max_cap_algs(&self) -> Result<u32, ()> {
        let max_cap_data = self.max_cap_data()?;
        let max_cap_algs = max_cap_data.checked_div(tpms_alg_property_marshalled_size() as u32).ok_or(())?;
        Ok(max_cap_algs)
    }

    fn max_cap_cc(&self) -> Result<u32, ()> {
        let max_cap_data = self.max_cap_data()?;
        let max_cap_cc = max_cap_data.checked_div(TpmCc::marshalled_size() as u32).ok_or(())?;
        Ok(max_cap_cc)
    }

    fn max_cap_data(&self) -> Result<u32, ()> {
        Ok(self.max_cap_buffer.checked_sub(TpmCap::marshalled_size() as u32).ok_or(())?.checked_sub(4).ok_or(())?)
    }

    fn max_cap_handles(&self) -> Result<u32, ()> {
        let max_cap_data = self.max_cap_data()?;
        let max_cap_handles = max_cap_data.checked_div(mem::size_of::<u32>() as u32).ok_or(())?;
        Ok(max_cap_handles)
    }

    fn max_digest_size(&self) -> Result<u16, ()> {
        let mut max_digest_size: u16 = 0;
        #[cfg(feature = "sha1")]
        {
            max_digest_size = max_digest_size.max(20);
        }
        #[cfg(feature = "sha256")]
        {
            max_digest_size = max_digest_size.max(32);
        }
        #[cfg(feature = "sha384")]
        {
            max_digest_size = max_digest_size.max(48);
        }
        #[cfg(feature = "sha512")]
        {
            max_digest_size = max_digest_size.max(64);
        }
        #[cfg(feature = "sm3_256")]
        {
            max_digest_size = max_digest_size.max(32);
        }
        #[cfg(feature = "sha3_256")]
        {
            max_digest_size = max_digest_size.max(32);
        }
        #[cfg(feature = "sha3_384")]
        {
            max_digest_size = max_digest_size.max(48);
        }
        #[cfg(feature = "sha3_512")]
        {
            max_digest_size = max_digest_size.max(64);
        }

        Ok(max_digest_size)
    }

    #[cfg(feature = "ecc")]
    fn max_ecc_curves(&self) -> Result<u32, ()> {
        let max_cap_data = self.max_cap_data()?;
        let max_ecc_curves = max_cap_data.checked_div(TpmEccCurve::marshalled_size() as u32).ok_or(())?;
        Ok(max_ecc_curves)
    }

    fn max_ecc_key_bytes(&self) -> Result<u16, ()> {
        let mut max_ecc_key_bits: u16 = 0;
        #[cfg(feature = "ecc_nist_p192")]
        {
            max_ecc_key_bits = max_ecc_key_bits.max(192);
        }
        #[cfg(feature = "ecc_nist_p224")]
        {
            max_ecc_key_bits = max_ecc_key_bits.max(224);
        }
        #[cfg(feature = "ecc_nist_p256")]
        {
            max_ecc_key_bits = max_ecc_key_bits.max(256);
        }
        #[cfg(feature = "ecc_nist_p384")]
        {
            max_ecc_key_bits = max_ecc_key_bits.max(384);
        }
        #[cfg(feature = "ecc_nist_p521")]
        {
            max_ecc_key_bits = max_ecc_key_bits.max(521);
        }
        #[cfg(feature = "ecc_bn_p256")]
        {
            max_ecc_key_bits = max_ecc_key_bits.max(256);
        }
        #[cfg(feature = "ecc_bn_p638")]
        {
            max_ecc_key_bits = max_ecc_key_bits.max(638);
        }
        #[cfg(feature = "ecc_sm2_p256")]
        {
            max_ecc_key_bits = max_ecc_key_bits.max(256);
        }
        #[cfg(feature = "ecc_bp_p256_r1")]
        {
            max_ecc_key_bits = max_ecc_key_bits.max(256);
        }
        #[cfg(feature = "ecc_bp_p384_r1")]
        {
            max_ecc_key_bits = max_ecc_key_bits.max(384);
        }
        #[cfg(feature = "ecc_bp_p512_r1")]
        {
            max_ecc_key_bits = max_ecc_key_bits.max(512);
        }
        #[cfg(feature = "ecc_curve_25519")]
        {
            max_ecc_key_bits = max_ecc_key_bits.max(256);
        }
        #[cfg(feature = "ecc_curve_448")]
        {
            max_ecc_key_bits = max_ecc_key_bits.max(448);
        }

        Ok(max_ecc_key_bits.checked_add(7).ok_or(())? / 8)
    }

    fn max_pcr_properties(&self) -> Result<u32, ()> {
        let max_cap_data = self.max_cap_data()?;
        let sizeof_tpms_tagged_pcr_select = tpms_tagged_pcr_select_marshalled_max_size(self)?;
        let max_pcr_properties = max_cap_data.checked_div(sizeof_tpms_tagged_pcr_select).ok_or(())?;
        Ok(max_pcr_properties)
    }

    fn max_pub_keys(&self) -> Result<u32, ()> {
        let max_cap_data = self.max_cap_data()?;
        let sizeof_tpm2b_public = tpm2b_public_marshalled_max_size(self)?;
        let max_pcr_properties = max_cap_data.checked_div(sizeof_tpm2b_public).ok_or(())?;
        Ok(max_pcr_properties)
    }

    fn max_spdm_session_info(&self) -> Result<u32, ()> {
        let max_cap_data = self.max_cap_data()?;
        let max_pcr_properties = max_cap_data.checked_div(tpms_spdm_session_info_marshalled_max_size() as u32).ok_or(())?;
        Ok(max_pcr_properties)
    }

    fn max_sym_block_size(&self) -> Result<u16, ()> {
        let mut max_sym_block_size_bits: u16 = 0;
        #[cfg(feature = "tdes")]
        {
            max_sym_block_size_bits = max_sym_block_size_bits.max(64);
        }
        #[cfg(feature = "aes")]
        {
            max_sym_block_size_bits = max_sym_block_size_bits.max(128);
        }
        #[cfg(feature = "sm4")]
        {
            max_sym_block_size_bits = max_sym_block_size_bits.max(128);
        }
        #[cfg(feature = "camellia")]
        {
            max_sym_block_size_bits = max_sym_block_size_bits.max(128);
        }

        Ok(max_sym_block_size_bits.checked_add(7).ok_or(())? / 8)
    }

    fn max_sym_data(&self) -> Result<u32, ()> {
        Ok(128u32)
    }

    fn max_sym_key_bytes(&self) -> Result<u16, ()> {
        let mut max_sym_key_bits: u16 = 0;
        #[cfg(feature = "tdes")]
        {
            max_sym_key_bits = max_sym_key_bits.max(192);
        }
        #[cfg(feature = "aes")]
        {
            max_sym_key_bits = max_sym_key_bits.max(256);
        }
        #[cfg(feature = "sm4")]
        {
            max_sym_key_bits = max_sym_key_bits.max(128);
        }
        #[cfg(feature = "camellia")]
        {
            max_sym_key_bits = max_sym_key_bits.max(256);
        }

        let max_sym_key_bytes = max_sym_key_bits.checked_add(7).ok_or(())? / 8;

        let max_digest_size = self.max_digest_size()?;

        Ok(max_sym_key_bytes.max(max_digest_size))
    }

    fn max_tagged_policies(&self) -> Result<u32, ()> {
        let max_cap_data = self.max_cap_data()?;
        let max_tagged_policies = max_cap_data.checked_div(tpms_tagged_policy_marshalled_max_size() as u32).ok_or(())?;
        Ok(max_tagged_policies)
    }

    fn max_tpm_properties(&self) -> Result<u32, ()> {
        let max_cap_data = self.max_cap_data()?;
        let max_tpm_properties = max_cap_data.checked_div(tpms_tagged_property_marshalled_size() as u32).ok_or(())?;
        Ok(max_tpm_properties)
    }

    fn max_vendor_property(&self) -> Result<u32, ()> {
        let max_cap_data = self.max_cap_data()?;
        let max_pcr_properties = max_cap_data.checked_div(tpm2b_vendor_property_marshalled_max_size() as u32).ok_or(())?;
        Ok(max_pcr_properties)
    }

    fn pcr_select_max(&self) -> Result<u8, ()> {
        let pcr_select_max = u8::try_from(self.implementation_pcr.checked_add(7).ok_or(())? / 8).or(Err(()))?;
        Ok(pcr_select_max)
    }

    fn pcr_select_min(&self) -> Result<u8, ()> {
        let pcr_select_min = u8::try_from(self.platform_pcr.checked_add(7).ok_or(())? / 8).or(Err(()))?;
        Ok(pcr_select_min)
    }
}

#[allow(unused)]
fn split_slice_at<T>(s: &[T], mid: usize) -> Result<(&[T], &[T]), TpmErr> {
    if s.len() < mid {
        return Err(TpmErr::Rc(TpmRc::INSUFFICIENT));
    }
    Ok(s.split_at(mid))
}

#[allow(unused)]
fn split_slice_at_mut<T>(s: &mut [T], mid: usize) -> Result<(&mut [T], &mut [T]), TpmErr> {
    if s.len() < mid {
        return Err(TpmErr::InternalErr);
    }
    Ok(s.split_at_mut(mid))
}

#[allow(unused)]
pub fn unmarshal_u8(buf: &[u8]) -> Result<(&[u8], u8), TpmErr> {
    let (consumed, buf) = split_slice_at(buf, mem::size_of::<u8>())?;
    let consumed = <&[u8; mem::size_of::<u8>()]>::try_from(consumed).map_err(|_| TpmErr::InternalErr)?;
    let value = u8::from_be_bytes(*consumed);
    Ok((buf, value))
}

#[allow(unused)]
pub fn unmarshal_i8(buf: &[u8]) -> Result<(&[u8], i8), TpmErr> {
    let (consumed, buf) = split_slice_at(buf, mem::size_of::<i8>())?;
    let consumed = <&[u8; mem::size_of::<i8>()]>::try_from(consumed).map_err(|_| TpmErr::InternalErr)?;
    let value = i8::from_be_bytes(*consumed);
    Ok((buf, value))
}

#[allow(unused)]
pub fn unmarshal_u16(buf: &[u8]) -> Result<(&[u8], u16), TpmErr> {
    let (consumed, buf) = split_slice_at(buf, mem::size_of::<u16>())?;
    let consumed = <&[u8; mem::size_of::<u16>()]>::try_from(consumed).map_err(|_| TpmErr::InternalErr)?;
    let value = u16::from_be_bytes(*consumed);
    Ok((buf, value))
}

#[allow(unused)]
pub fn unmarshal_i16(buf: &[u8]) -> Result<(&[u8], i16), TpmErr> {
    let (consumed, buf) = split_slice_at(buf, mem::size_of::<i16>())?;
    let consumed = <&[u8; mem::size_of::<i16>()]>::try_from(consumed).map_err(|_| TpmErr::InternalErr)?;
    let value = i16::from_be_bytes(*consumed);
    Ok((buf, value))
}

#[allow(unused)]
pub fn unmarshal_u32(buf: &[u8]) -> Result<(&[u8], u32), TpmErr> {
    let (consumed, buf) = split_slice_at(buf, mem::size_of::<u32>())?;
    let consumed = <&[u8; mem::size_of::<u32>()]>::try_from(consumed).map_err(|_| TpmErr::InternalErr)?;
    let value = u32::from_be_bytes(*consumed);
    Ok((buf, value))
}

#[allow(unused)]
pub fn unmarshal_i32(buf: &[u8]) -> Result<(&[u8], i32), TpmErr> {
    let (consumed, buf) = split_slice_at(buf, mem::size_of::<i32>())?;
    let consumed = <&[u8; mem::size_of::<i32>()]>::try_from(consumed).map_err(|_| TpmErr::InternalErr)?;
    let value = i32::from_be_bytes(*consumed);
    Ok((buf, value))
}

#[allow(unused)]
pub fn unmarshal_u64(buf: &[u8]) -> Result<(&[u8], u64), TpmErr> {
    let (consumed, buf) = split_slice_at(buf, mem::size_of::<u64>())?;
    let consumed = <&[u8; mem::size_of::<u64>()]>::try_from(consumed).map_err(|_| TpmErr::InternalErr)?;
    let value = u64::from_be_bytes(*consumed);
    Ok((buf, value))
}

#[allow(unused)]
pub fn unmarshal_i64(buf: &[u8]) -> Result<(&[u8], i64), TpmErr> {
    let (consumed, buf) = split_slice_at(buf, mem::size_of::<i64>())?;
    let consumed = <&[u8; mem::size_of::<i64>()]>::try_from(consumed).map_err(|_| TpmErr::InternalErr)?;
    let value = i64::from_be_bytes(*consumed);
    Ok((buf, value))
}

#[allow(unused)]
pub fn marshal_u8(buf: &mut [u8], value: u8) -> Result<&mut [u8], TpmErr> {
    let (produced, buf) = split_slice_at_mut(buf, mem::size_of::<u8>())?;
    let produced = <&mut [u8; mem::size_of::<u8>()]>::try_from(produced).map_err(|_| TpmErr::InternalErr)?;
    *produced = value.to_be_bytes();
    Ok(buf)
}

#[allow(unused)]
pub fn marshal_i8(buf: &mut [u8], value: i8) -> Result<&mut [u8], TpmErr> {
    let (produced, buf) = split_slice_at_mut(buf, mem::size_of::<i8>())?;
    let produced = <&mut [u8; mem::size_of::<i8>()]>::try_from(produced).map_err(|_| TpmErr::InternalErr)?;
    *produced = value.to_be_bytes();
    Ok(buf)
}

#[allow(unused)]
pub fn marshal_u16(buf: &mut [u8], value: u16) -> Result<&mut [u8], TpmErr> {
    let (produced, buf) = split_slice_at_mut(buf, mem::size_of::<u16>())?;
    let produced = <&mut [u8; mem::size_of::<u16>()]>::try_from(produced).map_err(|_| TpmErr::InternalErr)?;
    *produced = value.to_be_bytes();
    Ok(buf)
}

#[allow(unused)]
pub fn marshal_i16(buf: &mut [u8], value: i16) -> Result<&mut [u8], TpmErr> {
    let (produced, buf) = split_slice_at_mut(buf, mem::size_of::<i16>())?;
    let produced = <&mut [u8; mem::size_of::<i16>()]>::try_from(produced).map_err(|_| TpmErr::InternalErr)?;
    *produced = value.to_be_bytes();
    Ok(buf)
}

#[allow(unused)]
pub fn marshal_u32(buf: &mut [u8], value: u32) -> Result<&mut [u8], TpmErr> {
    let (produced, buf) = split_slice_at_mut(buf, mem::size_of::<u32>())?;
    let produced = <&mut [u8; mem::size_of::<u32>()]>::try_from(produced).map_err(|_| TpmErr::InternalErr)?;
    *produced = value.to_be_bytes();
    Ok(buf)
}

#[allow(unused)]
pub fn marshal_i32(buf: &mut [u8], value: i32) -> Result<&mut [u8], TpmErr> {
    let (produced, buf) = split_slice_at_mut(buf, mem::size_of::<i32>())?;
    let produced = <&mut [u8; mem::size_of::<i32>()]>::try_from(produced).map_err(|_| TpmErr::InternalErr)?;
    *produced = value.to_be_bytes();
    Ok(buf)
}

#[allow(unused)]
pub fn marshal_u64(buf: &mut [u8], value: u64) -> Result<&mut [u8], TpmErr> {
    let (produced, buf) = split_slice_at_mut(buf, mem::size_of::<u64>())?;
    let produced = <&mut [u8; mem::size_of::<u64>()]>::try_from(produced).map_err(|_| TpmErr::InternalErr)?;
    *produced = value.to_be_bytes();
    Ok(buf)
}

#[allow(unused)]
pub fn marshal_i64(buf: &mut [u8], value: i64) -> Result<&mut [u8], TpmErr> {
    let (produced, buf) = split_slice_at_mut(buf, mem::size_of::<i64>())?;
    let produced = <&mut [u8; mem::size_of::<i64>()]>::try_from(produced).map_err(|_| TpmErr::InternalErr)?;
    *produced = value.to_be_bytes();
    Ok(buf)
}

#[allow(unused)]
fn marshal_bytes<'a>(buf: &'a mut [u8], src: &[u8]) -> Result<&'a mut [u8], TpmErr> {
    let (produced, buf) = split_slice_at_mut(buf, src.len())?;
    produced.copy_from_slice(src);
    Ok(buf)
}

// TCG Algorithm Registry, page 11, table 3, TPM_ALG_ID constants
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u16)]
pub enum TpmAlgId {
    Error = 0x0u16,
    #[cfg(feature = "rsa")]
    Rsa = 0x1u16,
    #[cfg(feature = "tdes")]
    Tdes = 0x3u16,
    #[cfg(feature = "sha1")]
    Sha1 = 0x4u16,
    #[cfg(feature = "hmac")]
    Hmac = 0x5u16,
    #[cfg(feature = "aes")]
    Aes = 0x6u16,
    #[cfg(feature = "mgf1")]
    Mgf1 = 0x7u16,
    Keyedhash = 0x8u16,
    Xor = 0xau16,
    #[cfg(feature = "sha256")]
    Sha256 = 0xbu16,
    #[cfg(feature = "sha384")]
    Sha384 = 0xcu16,
    #[cfg(feature = "sha512")]
    Sha512 = 0xdu16,
    Null = 0x10u16,
    #[cfg(feature = "sm3_256")]
    Sm3_256 = 0x12u16,
    #[cfg(feature = "sm4")]
    Sm4 = 0x13u16,
    #[cfg(all(feature = "rsa", feature = "rsassa"))]
    Rsassa = 0x14u16,
    #[cfg(all(feature = "rsa", feature = "rsaes"))]
    Rsaes = 0x15u16,
    #[cfg(all(feature = "rsa", feature = "rsapss"))]
    Rsapss = 0x16u16,
    #[cfg(all(feature = "oaep", feature = "rsa"))]
    Oaep = 0x17u16,
    #[cfg(all(feature = "ecc", feature = "ecdsa"))]
    Ecdsa = 0x18u16,
    #[cfg(all(feature = "ecc", feature = "ecdh"))]
    Ecdh = 0x19u16,
    #[cfg(all(feature = "ecc", feature = "ecdaa"))]
    Ecdaa = 0x1au16,
    #[cfg(all(feature = "ecc", feature = "sm2"))]
    Sm2 = 0x1bu16,
    #[cfg(all(feature = "ecc", feature = "ecschnorr"))]
    Ecschnorr = 0x1cu16,
    #[cfg(all(feature = "ecc", feature = "ecmqv"))]
    Ecmqv = 0x1du16,
    #[cfg(all(feature = "ecc", feature = "kdf1_sp800_56a"))]
    Kdf1Sp800_56a = 0x20u16,
    #[cfg(feature = "kdf2")]
    Kdf2 = 0x21u16,
    #[cfg(feature = "kdf1_sp800_108")]
    Kdf1Sp800_108 = 0x22u16,
    #[cfg(feature = "ecc")]
    Ecc = 0x23u16,
    Symcipher = 0x25u16,
    #[cfg(feature = "camellia")]
    Camellia = 0x26u16,
    #[cfg(feature = "sha3_256")]
    Sha3_256 = 0x27u16,
    #[cfg(feature = "sha3_384")]
    Sha3_384 = 0x28u16,
    #[cfg(feature = "sha3_512")]
    Sha3_512 = 0x29u16,
    #[cfg(feature = "cmac")]
    Cmac = 0x3fu16,
    #[cfg(feature = "ctr")]
    Ctr = 0x40u16,
    #[cfg(feature = "ofb")]
    Ofb = 0x41u16,
    #[cfg(feature = "cbc")]
    Cbc = 0x42u16,
    #[cfg(feature = "cfb")]
    Cfb = 0x43u16,
    #[cfg(feature = "ecb")]
    Ecb = 0x44u16,
    #[cfg(feature = "ccm")]
    Ccm = 0x50u16,
    #[cfg(feature = "gcm")]
    Gcm = 0x51u16,
    #[cfg(all(feature = "aes", feature = "kw"))]
    Kw = 0x52u16,
    #[cfg(all(feature = "aes", feature = "kwp"))]
    Kwp = 0x53u16,
    #[cfg(feature = "eax")]
    Eax = 0x54u16,
    #[cfg(all(feature = "ecc", feature = "eddsa"))]
    Eddsa = 0x60u16,
    #[cfg(all(feature = "ecc", feature = "eddsa_ph"))]
    EddsaPh = 0x61u16,
}

impl TpmAlgId {
    const fn marshalled_size() -> u16 {
        mem::size_of::<u16>() as u16
    }

    fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u16(buf, *self as u16)
    }

    fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u16(buf)?;
        let result = Self::try_from(value)?;
        Ok((buf, result))
    }
}

impl convert::TryFrom<u16> for TpmAlgId {
    type Error = TpmErr;

    fn try_from(value: u16) -> Result<Self, TpmErr> {
        let result = match value {
            value if value == Self::Error as u16 => Self::Error,
            #[cfg(feature = "rsa")]
            value if value == Self::Rsa as u16 => Self::Rsa,
            #[cfg(feature = "tdes")]
            value if value == Self::Tdes as u16 => Self::Tdes,
            #[cfg(feature = "sha1")]
            value if value == Self::Sha1 as u16 => Self::Sha1,
            #[cfg(feature = "hmac")]
            value if value == Self::Hmac as u16 => Self::Hmac,
            #[cfg(feature = "aes")]
            value if value == Self::Aes as u16 => Self::Aes,
            #[cfg(feature = "mgf1")]
            value if value == Self::Mgf1 as u16 => Self::Mgf1,
            value if value == Self::Keyedhash as u16 => Self::Keyedhash,
            value if value == Self::Xor as u16 => Self::Xor,
            #[cfg(feature = "sha256")]
            value if value == Self::Sha256 as u16 => Self::Sha256,
            #[cfg(feature = "sha384")]
            value if value == Self::Sha384 as u16 => Self::Sha384,
            #[cfg(feature = "sha512")]
            value if value == Self::Sha512 as u16 => Self::Sha512,
            value if value == Self::Null as u16 => Self::Null,
            #[cfg(feature = "sm3_256")]
            value if value == Self::Sm3_256 as u16 => Self::Sm3_256,
            #[cfg(feature = "sm4")]
            value if value == Self::Sm4 as u16 => Self::Sm4,
            #[cfg(all(feature = "rsa", feature = "rsassa"))]
            value if value == Self::Rsassa as u16 => Self::Rsassa,
            #[cfg(all(feature = "rsa", feature = "rsaes"))]
            value if value == Self::Rsaes as u16 => Self::Rsaes,
            #[cfg(all(feature = "rsa", feature = "rsapss"))]
            value if value == Self::Rsapss as u16 => Self::Rsapss,
            #[cfg(all(feature = "oaep", feature = "rsa"))]
            value if value == Self::Oaep as u16 => Self::Oaep,
            #[cfg(all(feature = "ecc", feature = "ecdsa"))]
            value if value == Self::Ecdsa as u16 => Self::Ecdsa,
            #[cfg(all(feature = "ecc", feature = "ecdh"))]
            value if value == Self::Ecdh as u16 => Self::Ecdh,
            #[cfg(all(feature = "ecc", feature = "ecdaa"))]
            value if value == Self::Ecdaa as u16 => Self::Ecdaa,
            #[cfg(all(feature = "ecc", feature = "sm2"))]
            value if value == Self::Sm2 as u16 => Self::Sm2,
            #[cfg(all(feature = "ecc", feature = "ecschnorr"))]
            value if value == Self::Ecschnorr as u16 => Self::Ecschnorr,
            #[cfg(all(feature = "ecc", feature = "ecmqv"))]
            value if value == Self::Ecmqv as u16 => Self::Ecmqv,
            #[cfg(all(feature = "ecc", feature = "kdf1_sp800_56a"))]
            value if value == Self::Kdf1Sp800_56a as u16 => Self::Kdf1Sp800_56a,
            #[cfg(feature = "kdf2")]
            value if value == Self::Kdf2 as u16 => Self::Kdf2,
            #[cfg(feature = "kdf1_sp800_108")]
            value if value == Self::Kdf1Sp800_108 as u16 => Self::Kdf1Sp800_108,
            #[cfg(feature = "ecc")]
            value if value == Self::Ecc as u16 => Self::Ecc,
            value if value == Self::Symcipher as u16 => Self::Symcipher,
            #[cfg(feature = "camellia")]
            value if value == Self::Camellia as u16 => Self::Camellia,
            #[cfg(feature = "sha3_256")]
            value if value == Self::Sha3_256 as u16 => Self::Sha3_256,
            #[cfg(feature = "sha3_384")]
            value if value == Self::Sha3_384 as u16 => Self::Sha3_384,
            #[cfg(feature = "sha3_512")]
            value if value == Self::Sha3_512 as u16 => Self::Sha3_512,
            #[cfg(feature = "cmac")]
            value if value == Self::Cmac as u16 => Self::Cmac,
            #[cfg(feature = "ctr")]
            value if value == Self::Ctr as u16 => Self::Ctr,
            #[cfg(feature = "ofb")]
            value if value == Self::Ofb as u16 => Self::Ofb,
            #[cfg(feature = "cbc")]
            value if value == Self::Cbc as u16 => Self::Cbc,
            #[cfg(feature = "cfb")]
            value if value == Self::Cfb as u16 => Self::Cfb,
            #[cfg(feature = "ecb")]
            value if value == Self::Ecb as u16 => Self::Ecb,
            #[cfg(feature = "ccm")]
            value if value == Self::Ccm as u16 => Self::Ccm,
            #[cfg(feature = "gcm")]
            value if value == Self::Gcm as u16 => Self::Gcm,
            #[cfg(all(feature = "aes", feature = "kw"))]
            value if value == Self::Kw as u16 => Self::Kw,
            #[cfg(all(feature = "aes", feature = "kwp"))]
            value if value == Self::Kwp as u16 => Self::Kwp,
            #[cfg(feature = "eax")]
            value if value == Self::Eax as u16 => Self::Eax,
            #[cfg(all(feature = "ecc", feature = "eddsa"))]
            value if value == Self::Eddsa as u16 => Self::Eddsa,
            #[cfg(all(feature = "ecc", feature = "eddsa_ph"))]
            value if value == Self::EddsaPh as u16 => Self::EddsaPh,
            _ => {
                return Err(TpmErr::Rc(TpmRc::VALUE));
            },
        };

        Ok(result)
    }
}

// TCG Algorithm Registry, page 15, table 4, TPM_ECC_CURVE constants
#[cfg(feature = "ecc")]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u16)]
pub enum TpmEccCurve {
    None = 0x0u16,
    #[cfg(feature = "ecc_nist_p192")]
    NistP192 = 0x1u16,
    #[cfg(feature = "ecc_nist_p224")]
    NistP224 = 0x2u16,
    #[cfg(feature = "ecc_nist_p256")]
    NistP256 = 0x3u16,
    #[cfg(feature = "ecc_nist_p384")]
    NistP384 = 0x4u16,
    #[cfg(feature = "ecc_nist_p521")]
    NistP521 = 0x5u16,
    #[cfg(feature = "ecc_bn_p256")]
    BnP256 = 0x10u16,
    #[cfg(feature = "ecc_bn_p638")]
    BnP638 = 0x11u16,
    #[cfg(feature = "ecc_sm2_p256")]
    Sm2P256 = 0x20u16,
    #[cfg(feature = "ecc_bp_p256_r1")]
    BpP256R1 = 0x30u16,
    #[cfg(feature = "ecc_bp_p384_r1")]
    BpP384R1 = 0x31u16,
    #[cfg(feature = "ecc_bp_p512_r1")]
    BpP512R1 = 0x32u16,
    #[cfg(feature = "ecc_curve_25519")]
    Curve25519 = 0x40u16,
    #[cfg(feature = "ecc_curve_448")]
    Curve448 = 0x41u16,
}

#[cfg(feature = "ecc")]
impl TpmEccCurve {
    const fn marshalled_size() -> u16 {
        mem::size_of::<u16>() as u16
    }

    fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u16(buf, *self as u16)
    }

    fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u16(buf)?;
        let result = Self::try_from(value)?;
        Ok((buf, result))
    }
}

#[cfg(feature = "ecc")]
impl convert::TryFrom<u16> for TpmEccCurve {
    type Error = TpmErr;

    fn try_from(value: u16) -> Result<Self, TpmErr> {
        let result = match value {
            value if value == Self::None as u16 => Self::None,
            #[cfg(feature = "ecc_nist_p192")]
            value if value == Self::NistP192 as u16 => Self::NistP192,
            #[cfg(feature = "ecc_nist_p224")]
            value if value == Self::NistP224 as u16 => Self::NistP224,
            #[cfg(feature = "ecc_nist_p256")]
            value if value == Self::NistP256 as u16 => Self::NistP256,
            #[cfg(feature = "ecc_nist_p384")]
            value if value == Self::NistP384 as u16 => Self::NistP384,
            #[cfg(feature = "ecc_nist_p521")]
            value if value == Self::NistP521 as u16 => Self::NistP521,
            #[cfg(feature = "ecc_bn_p256")]
            value if value == Self::BnP256 as u16 => Self::BnP256,
            #[cfg(feature = "ecc_bn_p638")]
            value if value == Self::BnP638 as u16 => Self::BnP638,
            #[cfg(feature = "ecc_sm2_p256")]
            value if value == Self::Sm2P256 as u16 => Self::Sm2P256,
            #[cfg(feature = "ecc_bp_p256_r1")]
            value if value == Self::BpP256R1 as u16 => Self::BpP256R1,
            #[cfg(feature = "ecc_bp_p384_r1")]
            value if value == Self::BpP384R1 as u16 => Self::BpP384R1,
            #[cfg(feature = "ecc_bp_p512_r1")]
            value if value == Self::BpP512R1 as u16 => Self::BpP512R1,
            #[cfg(feature = "ecc_curve_25519")]
            value if value == Self::Curve25519 as u16 => Self::Curve25519,
            #[cfg(feature = "ecc_curve_448")]
            value if value == Self::Curve448 as u16 => Self::Curve448,
            _ => {
                return Err(TpmErr::Rc(TpmRc::CURVE));
            },
        };

        Ok(result)
    }
}

// TCG Algorithm Registry, page 31, table 25, TPMA_HASH_ALGS bits
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct TpmaHashAlgs {
    value: u32,
}

impl TpmaHashAlgs {
    pub fn new() -> Self {
        Self { value: 0u32 }
    }

    const ALG_SHA1_MASK: u32 = 1u32 << 0u32;

    pub fn get_alg_sha1(&self) -> bool {
        self.value & Self::ALG_SHA1_MASK != 0
    }

    pub fn set_alg_sha1(&mut self, value: bool) {
        if value {
            self.value |= Self::ALG_SHA1_MASK;
        } else {
            self.value &= !Self::ALG_SHA1_MASK;
        }
    }

    const ALG_SHA256_MASK: u32 = 1u32 << 1u32;

    pub fn get_alg_sha256(&self) -> bool {
        self.value & Self::ALG_SHA256_MASK != 0
    }

    pub fn set_alg_sha256(&mut self, value: bool) {
        if value {
            self.value |= Self::ALG_SHA256_MASK;
        } else {
            self.value &= !Self::ALG_SHA256_MASK;
        }
    }

    const ALG_SHA384_MASK: u32 = 1u32 << 2u32;

    pub fn get_alg_sha384(&self) -> bool {
        self.value & Self::ALG_SHA384_MASK != 0
    }

    pub fn set_alg_sha384(&mut self, value: bool) {
        if value {
            self.value |= Self::ALG_SHA384_MASK;
        } else {
            self.value &= !Self::ALG_SHA384_MASK;
        }
    }

    const ALG_SHA512_MASK: u32 = 1u32 << 3u32;

    pub fn get_alg_sha512(&self) -> bool {
        self.value & Self::ALG_SHA512_MASK != 0
    }

    pub fn set_alg_sha512(&mut self, value: bool) {
        if value {
            self.value |= Self::ALG_SHA512_MASK;
        } else {
            self.value &= !Self::ALG_SHA512_MASK;
        }
    }

    const ALG_SM3_256_MASK: u32 = 1u32 << 4u32;

    pub fn get_alg_sm3_256(&self) -> bool {
        self.value & Self::ALG_SM3_256_MASK != 0
    }

    pub fn set_alg_sm3_256(&mut self, value: bool) {
        if value {
            self.value |= Self::ALG_SM3_256_MASK;
        } else {
            self.value &= !Self::ALG_SM3_256_MASK;
        }
    }

    const ALG_SHA3_256_MASK: u32 = 1u32 << 5u32;

    pub fn get_alg_sha3_256(&self) -> bool {
        self.value & Self::ALG_SHA3_256_MASK != 0
    }

    pub fn set_alg_sha3_256(&mut self, value: bool) {
        if value {
            self.value |= Self::ALG_SHA3_256_MASK;
        } else {
            self.value &= !Self::ALG_SHA3_256_MASK;
        }
    }

    const ALG_SHA3_384_MASK: u32 = 1u32 << 6u32;

    pub fn get_alg_sha3_384(&self) -> bool {
        self.value & Self::ALG_SHA3_384_MASK != 0
    }

    pub fn set_alg_sha3_384(&mut self, value: bool) {
        if value {
            self.value |= Self::ALG_SHA3_384_MASK;
        } else {
            self.value &= !Self::ALG_SHA3_384_MASK;
        }
    }

    const ALG_SHA3_512_MASK: u32 = 1u32 << 7u32;

    pub fn get_alg_sha3_512(&self) -> bool {
        self.value & Self::ALG_SHA3_512_MASK != 0
    }

    pub fn set_alg_sha3_512(&mut self, value: bool) {
        if value {
            self.value |= Self::ALG_SHA3_512_MASK;
        } else {
            self.value &= !Self::ALG_SHA3_512_MASK;
        }
    }

    const RESERVED_MASK: u32 = 0xffffffffu32 >> (32u32 - 1u32 - 31u32 + 8u32) << 8u32;

    pub const fn marshalled_size() -> u16 {
        mem::size_of::<u32>() as u16
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u32(buf, self.value)
    }

    pub fn unmarshal(buf: &[u8]) -> Result<(&[u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u32(buf)?;
        let result = Self::try_from(value)?;
        Ok((buf, result))
    }
}

impl convert::TryFrom<u32> for TpmaHashAlgs {
    type Error = TpmErr;

    fn try_from(value: u32) -> Result<Self, TpmErr> {

        if value & Self::RESERVED_MASK != 0 {
            return Err(TpmErr::Rc(TpmRc::RESERVED_BITS));
        }

        Ok(Self { value })
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 42, table 9, TPM_CONSTANTS32 constants
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u32)]
pub enum TpmConstants32 {
    GeneratedValue = 0xff544347u32,
    MaxDerivationBits = 8192u32,
}

impl TpmConstants32 {
    const fn marshalled_size() -> u16 {
        mem::size_of::<u32>() as u16
    }

    fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u32(buf, *self as u32)
    }

    fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u32(buf)?;
        let result = Self::try_from(value)?;
        Ok((buf, result))
    }
}

impl convert::TryFrom<u32> for TpmConstants32 {
    type Error = TpmErr;

    fn try_from(value: u32) -> Result<Self, TpmErr> {
        let result = match value {
            value if value == Self::GeneratedValue as u32 => Self::GeneratedValue,
            value if value == Self::MaxDerivationBits as u32 => Self::MaxDerivationBits,
            _ => {
                return Err(TpmErr::Rc(TpmRc::VALUE));
            },
        };

        Ok(result)
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 55, table 14, TPM_CC constants
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u32)]
pub enum TpmCc {
    NvUndefineSpaceSpecial = 0x11fu32,
    EvictControl = 0x120u32,
    HierarchyControl = 0x121u32,
    NvUndefineSpace = 0x122u32,
    ChangeEPS = 0x124u32,
    ChangePPS = 0x125u32,
    Clear = 0x126u32,
    ClearControl = 0x127u32,
    ClockSet = 0x128u32,
    HierarchyChangeAuth = 0x129u32,
    NvDefineSpace = 0x12au32,
    PcrAllocate = 0x12bu32,
    PcrSetAuthPolicy = 0x12cu32,
    PpCommands = 0x12du32,
    SetPrimaryPolicy = 0x12eu32,
    FieldUpgradeStart = 0x12fu32,
    ClockRateAdjust = 0x130u32,
    CreatePrimary = 0x131u32,
    NvGlobalWriteLock = 0x132u32,
    GetCommandAuditDigest = 0x133u32,
    NvIncrement = 0x134u32,
    NvSetBits = 0x135u32,
    NvExtend = 0x136u32,
    NvWrite = 0x137u32,
    NvWriteLock = 0x138u32,
    DictionaryAttackLockReset = 0x139u32,
    DictionaryAttackParameters = 0x13au32,
    NvChangeAuth = 0x13bu32,
    PcrEvent = 0x13cu32,
    PcrReset = 0x13du32,
    SequenceComplete = 0x13eu32,
    SetAlgorithmSet = 0x13fu32,
    SetCommandCodeAuditStatus = 0x140u32,
    FieldUpgradeData = 0x141u32,
    IncrementalSelfTest = 0x142u32,
    SelfTest = 0x143u32,
    Startup = 0x144u32,
    Shutdown = 0x145u32,
    StirRandom = 0x146u32,
    ActivateCredential = 0x147u32,
    Certify = 0x148u32,
    PolicyNV = 0x149u32,
    CertifyCreation = 0x14au32,
    Duplicate = 0x14bu32,
    GetTime = 0x14cu32,
    GetSessionAuditDigest = 0x14du32,
    NvRead = 0x14eu32,
    NvReadLock = 0x14fu32,
    ObjectChangeAuth = 0x150u32,
    PolicySecret = 0x151u32,
    Rewrap = 0x152u32,
    Create = 0x153u32,
    #[cfg(feature = "ecc")]
    EcdhZGen = 0x154u32,
    #[cfg(not(feature = "cmac"))]
    Hmac = 0x155u32,
    #[cfg(feature = "cmac")]
    Mac = 0x155u32,
    Import = 0x156u32,
    Load = 0x157u32,
    Quote = 0x158u32,
    #[cfg(feature = "rsa")]
    RsaDecrypt = 0x159u32,
    #[cfg(not(feature = "cmac"))]
    HmacStart = 0x15bu32,
    #[cfg(feature = "cmac")]
    MacStart = 0x15bu32,
    SequenceUpdate = 0x15cu32,
    Sign = 0x15du32,
    Unseal = 0x15eu32,
    PolicySigned = 0x160u32,
    ContextLoad = 0x161u32,
    ContextSave = 0x162u32,
    #[cfg(feature = "ecc")]
    EcdhKeyGen = 0x163u32,
    EncryptDecrypt = 0x164u32,
    FlushContext = 0x165u32,
    LoadExternal = 0x167u32,
    MakeCredential = 0x168u32,
    NvReadPublic = 0x169u32,
    PolicyAuthorize = 0x16au32,
    PolicyAuthValue = 0x16bu32,
    PolicyCommandCode = 0x16cu32,
    PolicyCounterTimer = 0x16du32,
    PolicyCpHash = 0x16eu32,
    PolicyLocality = 0x16fu32,
    PolicyNameHash = 0x170u32,
    PolicyOR = 0x171u32,
    PolicyTicket = 0x172u32,
    ReadPublic = 0x173u32,
    #[cfg(feature = "rsa")]
    RsaEncrypt = 0x174u32,
    StartAuthSession = 0x176u32,
    VerifySignature = 0x177u32,
    #[cfg(feature = "ecc")]
    EccParameters = 0x178u32,
    FirmwareRead = 0x179u32,
    GetCapability = 0x17au32,
    GetRandom = 0x17bu32,
    GetTestResult = 0x17cu32,
    Hash = 0x17du32,
    PcrRead = 0x17eu32,
    PolicyPCR = 0x17fu32,
    PolicyRestart = 0x180u32,
    ReadClock = 0x181u32,
    PcrExtend = 0x182u32,
    PcrSetAuthValue = 0x183u32,
    NvCertify = 0x184u32,
    EventSequenceComplete = 0x185u32,
    HashSequenceStart = 0x186u32,
    PolicyPhysicalPresence = 0x187u32,
    PolicyDuplicationSelect = 0x188u32,
    PolicyGetDigest = 0x189u32,
    TestParms = 0x18au32,
    #[cfg(feature = "ecc")]
    Commit = 0x18bu32,
    PolicyPassword = 0x18cu32,
    #[cfg(feature = "ecc")]
    ZGen2Phase = 0x18du32,
    #[cfg(feature = "ecc")]
    EcEphemeral = 0x18eu32,
    PolicyNvWritten = 0x18fu32,
    PolicyTemplate = 0x190u32,
    CreateLoaded = 0x191u32,
    PolicyAuthorizeNV = 0x192u32,
    EncryptDecrypt2 = 0x193u32,
    AcGetCapability = 0x194u32,
    AcSend = 0x195u32,
    PolicyAcSendSelect = 0x196u32,
    CertifyX509 = 0x197u32,
    ActSetTimeout = 0x198u32,
    #[cfg(feature = "ecc")]
    EccEncrypt = 0x199u32,
    #[cfg(feature = "ecc")]
    EccDecrypt = 0x19au32,
    PolicyCapability = 0x19bu32,
    PolicyParameters = 0x19cu32,
    NvDefineSpace2 = 0x19du32,
    NvReadPublic2 = 0x19eu32,
    SetCapability = 0x19fu32,
    ReadOnlyControl = 0x1a0u32,
    PolicyTransportSPDM = 0x1a1u32,
    VendorTcgTest = Self::VEND + 0x0u32,
}

impl TpmCc {
    const VEND: u32 = 0x20000000u32;

    const fn marshalled_size() -> u16 {
        mem::size_of::<u32>() as u16
    }

    fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u32(buf, *self as u32)
    }

    fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u32(buf)?;
        let result = Self::try_from(value)?;
        Ok((buf, result))
    }
}

impl convert::TryFrom<u32> for TpmCc {
    type Error = TpmErr;

    fn try_from(value: u32) -> Result<Self, TpmErr> {
        let result = match value {
            value if value == Self::NvUndefineSpaceSpecial as u32 => Self::NvUndefineSpaceSpecial,
            value if value == Self::EvictControl as u32 => Self::EvictControl,
            value if value == Self::HierarchyControl as u32 => Self::HierarchyControl,
            value if value == Self::NvUndefineSpace as u32 => Self::NvUndefineSpace,
            value if value == Self::ChangeEPS as u32 => Self::ChangeEPS,
            value if value == Self::ChangePPS as u32 => Self::ChangePPS,
            value if value == Self::Clear as u32 => Self::Clear,
            value if value == Self::ClearControl as u32 => Self::ClearControl,
            value if value == Self::ClockSet as u32 => Self::ClockSet,
            value if value == Self::HierarchyChangeAuth as u32 => Self::HierarchyChangeAuth,
            value if value == Self::NvDefineSpace as u32 => Self::NvDefineSpace,
            value if value == Self::PcrAllocate as u32 => Self::PcrAllocate,
            value if value == Self::PcrSetAuthPolicy as u32 => Self::PcrSetAuthPolicy,
            value if value == Self::PpCommands as u32 => Self::PpCommands,
            value if value == Self::SetPrimaryPolicy as u32 => Self::SetPrimaryPolicy,
            value if value == Self::FieldUpgradeStart as u32 => Self::FieldUpgradeStart,
            value if value == Self::ClockRateAdjust as u32 => Self::ClockRateAdjust,
            value if value == Self::CreatePrimary as u32 => Self::CreatePrimary,
            value if value == Self::NvGlobalWriteLock as u32 => Self::NvGlobalWriteLock,
            value if value == Self::GetCommandAuditDigest as u32 => Self::GetCommandAuditDigest,
            value if value == Self::NvIncrement as u32 => Self::NvIncrement,
            value if value == Self::NvSetBits as u32 => Self::NvSetBits,
            value if value == Self::NvExtend as u32 => Self::NvExtend,
            value if value == Self::NvWrite as u32 => Self::NvWrite,
            value if value == Self::NvWriteLock as u32 => Self::NvWriteLock,
            value if value == Self::DictionaryAttackLockReset as u32 => Self::DictionaryAttackLockReset,
            value if value == Self::DictionaryAttackParameters as u32 => Self::DictionaryAttackParameters,
            value if value == Self::NvChangeAuth as u32 => Self::NvChangeAuth,
            value if value == Self::PcrEvent as u32 => Self::PcrEvent,
            value if value == Self::PcrReset as u32 => Self::PcrReset,
            value if value == Self::SequenceComplete as u32 => Self::SequenceComplete,
            value if value == Self::SetAlgorithmSet as u32 => Self::SetAlgorithmSet,
            value if value == Self::SetCommandCodeAuditStatus as u32 => Self::SetCommandCodeAuditStatus,
            value if value == Self::FieldUpgradeData as u32 => Self::FieldUpgradeData,
            value if value == Self::IncrementalSelfTest as u32 => Self::IncrementalSelfTest,
            value if value == Self::SelfTest as u32 => Self::SelfTest,
            value if value == Self::Startup as u32 => Self::Startup,
            value if value == Self::Shutdown as u32 => Self::Shutdown,
            value if value == Self::StirRandom as u32 => Self::StirRandom,
            value if value == Self::ActivateCredential as u32 => Self::ActivateCredential,
            value if value == Self::Certify as u32 => Self::Certify,
            value if value == Self::PolicyNV as u32 => Self::PolicyNV,
            value if value == Self::CertifyCreation as u32 => Self::CertifyCreation,
            value if value == Self::Duplicate as u32 => Self::Duplicate,
            value if value == Self::GetTime as u32 => Self::GetTime,
            value if value == Self::GetSessionAuditDigest as u32 => Self::GetSessionAuditDigest,
            value if value == Self::NvRead as u32 => Self::NvRead,
            value if value == Self::NvReadLock as u32 => Self::NvReadLock,
            value if value == Self::ObjectChangeAuth as u32 => Self::ObjectChangeAuth,
            value if value == Self::PolicySecret as u32 => Self::PolicySecret,
            value if value == Self::Rewrap as u32 => Self::Rewrap,
            value if value == Self::Create as u32 => Self::Create,
            #[cfg(feature = "ecc")]
            value if value == Self::EcdhZGen as u32 => Self::EcdhZGen,
            #[cfg(not(feature = "cmac"))]
            value if value == Self::Hmac as u32 => Self::Hmac,
            #[cfg(feature = "cmac")]
            value if value == Self::Mac as u32 => Self::Mac,
            value if value == Self::Import as u32 => Self::Import,
            value if value == Self::Load as u32 => Self::Load,
            value if value == Self::Quote as u32 => Self::Quote,
            #[cfg(feature = "rsa")]
            value if value == Self::RsaDecrypt as u32 => Self::RsaDecrypt,
            #[cfg(not(feature = "cmac"))]
            value if value == Self::HmacStart as u32 => Self::HmacStart,
            #[cfg(feature = "cmac")]
            value if value == Self::MacStart as u32 => Self::MacStart,
            value if value == Self::SequenceUpdate as u32 => Self::SequenceUpdate,
            value if value == Self::Sign as u32 => Self::Sign,
            value if value == Self::Unseal as u32 => Self::Unseal,
            value if value == Self::PolicySigned as u32 => Self::PolicySigned,
            value if value == Self::ContextLoad as u32 => Self::ContextLoad,
            value if value == Self::ContextSave as u32 => Self::ContextSave,
            #[cfg(feature = "ecc")]
            value if value == Self::EcdhKeyGen as u32 => Self::EcdhKeyGen,
            value if value == Self::EncryptDecrypt as u32 => Self::EncryptDecrypt,
            value if value == Self::FlushContext as u32 => Self::FlushContext,
            value if value == Self::LoadExternal as u32 => Self::LoadExternal,
            value if value == Self::MakeCredential as u32 => Self::MakeCredential,
            value if value == Self::NvReadPublic as u32 => Self::NvReadPublic,
            value if value == Self::PolicyAuthorize as u32 => Self::PolicyAuthorize,
            value if value == Self::PolicyAuthValue as u32 => Self::PolicyAuthValue,
            value if value == Self::PolicyCommandCode as u32 => Self::PolicyCommandCode,
            value if value == Self::PolicyCounterTimer as u32 => Self::PolicyCounterTimer,
            value if value == Self::PolicyCpHash as u32 => Self::PolicyCpHash,
            value if value == Self::PolicyLocality as u32 => Self::PolicyLocality,
            value if value == Self::PolicyNameHash as u32 => Self::PolicyNameHash,
            value if value == Self::PolicyOR as u32 => Self::PolicyOR,
            value if value == Self::PolicyTicket as u32 => Self::PolicyTicket,
            value if value == Self::ReadPublic as u32 => Self::ReadPublic,
            #[cfg(feature = "rsa")]
            value if value == Self::RsaEncrypt as u32 => Self::RsaEncrypt,
            value if value == Self::StartAuthSession as u32 => Self::StartAuthSession,
            value if value == Self::VerifySignature as u32 => Self::VerifySignature,
            #[cfg(feature = "ecc")]
            value if value == Self::EccParameters as u32 => Self::EccParameters,
            value if value == Self::FirmwareRead as u32 => Self::FirmwareRead,
            value if value == Self::GetCapability as u32 => Self::GetCapability,
            value if value == Self::GetRandom as u32 => Self::GetRandom,
            value if value == Self::GetTestResult as u32 => Self::GetTestResult,
            value if value == Self::Hash as u32 => Self::Hash,
            value if value == Self::PcrRead as u32 => Self::PcrRead,
            value if value == Self::PolicyPCR as u32 => Self::PolicyPCR,
            value if value == Self::PolicyRestart as u32 => Self::PolicyRestart,
            value if value == Self::ReadClock as u32 => Self::ReadClock,
            value if value == Self::PcrExtend as u32 => Self::PcrExtend,
            value if value == Self::PcrSetAuthValue as u32 => Self::PcrSetAuthValue,
            value if value == Self::NvCertify as u32 => Self::NvCertify,
            value if value == Self::EventSequenceComplete as u32 => Self::EventSequenceComplete,
            value if value == Self::HashSequenceStart as u32 => Self::HashSequenceStart,
            value if value == Self::PolicyPhysicalPresence as u32 => Self::PolicyPhysicalPresence,
            value if value == Self::PolicyDuplicationSelect as u32 => Self::PolicyDuplicationSelect,
            value if value == Self::PolicyGetDigest as u32 => Self::PolicyGetDigest,
            value if value == Self::TestParms as u32 => Self::TestParms,
            #[cfg(feature = "ecc")]
            value if value == Self::Commit as u32 => Self::Commit,
            value if value == Self::PolicyPassword as u32 => Self::PolicyPassword,
            #[cfg(feature = "ecc")]
            value if value == Self::ZGen2Phase as u32 => Self::ZGen2Phase,
            #[cfg(feature = "ecc")]
            value if value == Self::EcEphemeral as u32 => Self::EcEphemeral,
            value if value == Self::PolicyNvWritten as u32 => Self::PolicyNvWritten,
            value if value == Self::PolicyTemplate as u32 => Self::PolicyTemplate,
            value if value == Self::CreateLoaded as u32 => Self::CreateLoaded,
            value if value == Self::PolicyAuthorizeNV as u32 => Self::PolicyAuthorizeNV,
            value if value == Self::EncryptDecrypt2 as u32 => Self::EncryptDecrypt2,
            value if value == Self::AcGetCapability as u32 => Self::AcGetCapability,
            value if value == Self::AcSend as u32 => Self::AcSend,
            value if value == Self::PolicyAcSendSelect as u32 => Self::PolicyAcSendSelect,
            value if value == Self::CertifyX509 as u32 => Self::CertifyX509,
            value if value == Self::ActSetTimeout as u32 => Self::ActSetTimeout,
            #[cfg(feature = "ecc")]
            value if value == Self::EccEncrypt as u32 => Self::EccEncrypt,
            #[cfg(feature = "ecc")]
            value if value == Self::EccDecrypt as u32 => Self::EccDecrypt,
            value if value == Self::PolicyCapability as u32 => Self::PolicyCapability,
            value if value == Self::PolicyParameters as u32 => Self::PolicyParameters,
            value if value == Self::NvDefineSpace2 as u32 => Self::NvDefineSpace2,
            value if value == Self::NvReadPublic2 as u32 => Self::NvReadPublic2,
            value if value == Self::SetCapability as u32 => Self::SetCapability,
            value if value == Self::ReadOnlyControl as u32 => Self::ReadOnlyControl,
            value if value == Self::PolicyTransportSPDM as u32 => Self::PolicyTransportSPDM,
            value if value == Self::VendorTcgTest as u32 => Self::VendorTcgTest,
            _ => {
                return Err(TpmErr::Rc(TpmRc::COMMAND_CODE));
            },
        };

        Ok(result)
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 63, table 20, TPM_RC constants
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct TpmRc {
    pub value: u32,
}

impl TpmRc {
    pub const SUCCESS: u32 = 0x0u32;
    pub const BAD_TAG: u32 = 0x1eu32;
    pub const VER1: u32 = 0x100u32;
    pub const INITIALIZE: u32 = Self::VER1 + 0x0u32;
    pub const FAILURE: u32 = Self::VER1 + 0x1u32;
    pub const SEQUENCE: u32 = Self::VER1 + 0x3u32;
    pub const PRIVATE: u32 = Self::VER1 + 0xbu32;
    pub const HMAC: u32 = Self::VER1 + 0x19u32;
    pub const DISABLED: u32 = Self::VER1 + 0x20u32;
    pub const EXCLUSIVE: u32 = Self::VER1 + 0x21u32;
    pub const AUTH_TYPE: u32 = Self::VER1 + 0x24u32;
    pub const AUTH_MISSING: u32 = Self::VER1 + 0x25u32;
    pub const POLICY: u32 = Self::VER1 + 0x26u32;
    pub const PCR: u32 = Self::VER1 + 0x27u32;
    pub const PCR_CHANGED: u32 = Self::VER1 + 0x28u32;
    pub const UPGRADE: u32 = Self::VER1 + 0x2du32;
    pub const TOO_MANY_CONTEXTS: u32 = Self::VER1 + 0x2eu32;
    pub const AUTH_UNAVAILABLE: u32 = Self::VER1 + 0x2fu32;
    pub const REBOOT: u32 = Self::VER1 + 0x30u32;
    pub const UNBALANCED: u32 = Self::VER1 + 0x31u32;
    pub const COMMAND_SIZE: u32 = Self::VER1 + 0x42u32;
    pub const COMMAND_CODE: u32 = Self::VER1 + 0x43u32;
    pub const AUTHSIZE: u32 = Self::VER1 + 0x44u32;
    pub const AUTH_CONTEXT: u32 = Self::VER1 + 0x45u32;
    pub const NV_RANGE: u32 = Self::VER1 + 0x46u32;
    pub const NV_SIZE: u32 = Self::VER1 + 0x47u32;
    pub const NV_LOCKED: u32 = Self::VER1 + 0x48u32;
    pub const NV_AUTHORIZATION: u32 = Self::VER1 + 0x49u32;
    pub const NV_UNINITIALIZED: u32 = Self::VER1 + 0x4au32;
    pub const NV_SPACE: u32 = Self::VER1 + 0x4bu32;
    pub const NV_DEFINED: u32 = Self::VER1 + 0x4cu32;
    pub const BAD_CONTEXT: u32 = Self::VER1 + 0x50u32;
    pub const CPHASH: u32 = Self::VER1 + 0x51u32;
    pub const PARENT: u32 = Self::VER1 + 0x52u32;
    pub const NEEDS_TEST: u32 = Self::VER1 + 0x53u32;
    pub const NO_RESULT: u32 = Self::VER1 + 0x54u32;
    pub const SENSITIVE: u32 = Self::VER1 + 0x55u32;
    pub const READ_ONLY: u32 = Self::VER1 + 0x56u32;
    pub const MAX_FM0: u32 = Self::VER1 + 0x7fu32;
    pub const FMT1: u32 = 0x80u32;
    pub const ASYMMETRIC: u32 = Self::FMT1 + 0x1u32;
    pub const ATTRIBUTES: u32 = Self::FMT1 + 0x2u32;
    pub const HASH: u32 = Self::FMT1 + 0x3u32;
    pub const VALUE: u32 = Self::FMT1 + 0x4u32;
    pub const HIERARCHY: u32 = Self::FMT1 + 0x5u32;
    pub const KEY_SIZE: u32 = Self::FMT1 + 0x7u32;
    pub const MGF: u32 = Self::FMT1 + 0x8u32;
    pub const MODE: u32 = Self::FMT1 + 0x9u32;
    pub const TYPE: u32 = Self::FMT1 + 0xau32;
    pub const HANDLE: u32 = Self::FMT1 + 0xbu32;
    pub const KDF: u32 = Self::FMT1 + 0xcu32;
    pub const RANGE: u32 = Self::FMT1 + 0xdu32;
    pub const AUTH_FAIL: u32 = Self::FMT1 + 0xeu32;
    pub const NONCE: u32 = Self::FMT1 + 0xfu32;
    pub const PP: u32 = Self::FMT1 + 0x10u32;
    pub const SCHEME: u32 = Self::FMT1 + 0x12u32;
    pub const SIZE: u32 = Self::FMT1 + 0x15u32;
    pub const SYMMETRIC: u32 = Self::FMT1 + 0x16u32;
    pub const TAG: u32 = Self::FMT1 + 0x17u32;
    pub const SELECTOR: u32 = Self::FMT1 + 0x18u32;
    pub const INSUFFICIENT: u32 = Self::FMT1 + 0x1au32;
    pub const SIGNATURE: u32 = Self::FMT1 + 0x1bu32;
    pub const KEY: u32 = Self::FMT1 + 0x1cu32;
    pub const POLICY_FAIL: u32 = Self::FMT1 + 0x1du32;
    pub const INTEGRITY: u32 = Self::FMT1 + 0x1fu32;
    pub const TICKET: u32 = Self::FMT1 + 0x20u32;
    pub const RESERVED_BITS: u32 = Self::FMT1 + 0x21u32;
    pub const BAD_AUTH: u32 = Self::FMT1 + 0x22u32;
    pub const EXPIRED: u32 = Self::FMT1 + 0x23u32;
    pub const POLICY_CC: u32 = Self::FMT1 + 0x24u32;
    pub const BINDING: u32 = Self::FMT1 + 0x25u32;
    pub const CURVE: u32 = Self::FMT1 + 0x26u32;
    pub const ECC_POINT: u32 = Self::FMT1 + 0x27u32;
    pub const FW_LIMITED: u32 = Self::FMT1 + 0x28u32;
    pub const SVN_LIMITED: u32 = Self::FMT1 + 0x29u32;
    pub const CHANNEL: u32 = Self::FMT1 + 0x30u32;
    pub const CHANNEL_KEY: u32 = Self::FMT1 + 0x31u32;
    pub const WARN: u32 = 0x900u32;
    pub const CONTEXT_GAP: u32 = Self::WARN + 0x1u32;
    pub const OBJECT_MEMORY: u32 = Self::WARN + 0x2u32;
    pub const SESSION_MEMORY: u32 = Self::WARN + 0x3u32;
    pub const MEMORY: u32 = Self::WARN + 0x4u32;
    pub const SESSION_HANDLES: u32 = Self::WARN + 0x5u32;
    pub const OBJECT_HANDLES: u32 = Self::WARN + 0x6u32;
    pub const LOCALITY: u32 = Self::WARN + 0x7u32;
    pub const YIELDED: u32 = Self::WARN + 0x8u32;
    pub const CANCELED: u32 = Self::WARN + 0x9u32;
    pub const TESTING: u32 = Self::WARN + 0xau32;
    pub const REFERENCE_H0: u32 = Self::WARN + 0x10u32;
    pub const REFERENCE_H1: u32 = Self::WARN + 0x11u32;
    pub const REFERENCE_H2: u32 = Self::WARN + 0x12u32;
    pub const REFERENCE_H3: u32 = Self::WARN + 0x13u32;
    pub const REFERENCE_H4: u32 = Self::WARN + 0x14u32;
    pub const REFERENCE_H5: u32 = Self::WARN + 0x15u32;
    pub const REFERENCE_H6: u32 = Self::WARN + 0x16u32;
    pub const REFERENCE_S0: u32 = Self::WARN + 0x18u32;
    pub const REFERENCE_S1: u32 = Self::WARN + 0x19u32;
    pub const REFERENCE_S2: u32 = Self::WARN + 0x1au32;
    pub const REFERENCE_S3: u32 = Self::WARN + 0x1bu32;
    pub const REFERENCE_S4: u32 = Self::WARN + 0x1cu32;
    pub const REFERENCE_S5: u32 = Self::WARN + 0x1du32;
    pub const REFERENCE_S6: u32 = Self::WARN + 0x1eu32;
    pub const NV_RATE: u32 = Self::WARN + 0x20u32;
    pub const LOCKOUT: u32 = Self::WARN + 0x21u32;
    pub const RETRY: u32 = Self::WARN + 0x22u32;
    pub const NV_UNAVAILABLE: u32 = Self::WARN + 0x23u32;
    pub const NOT_USED: u32 = Self::WARN + 0x7fu32;
    pub const RC_H: u32 = 0x0u32;
    pub const RC_P: u32 = 0x40u32;
    pub const RC_S: u32 = 0x800u32;
    pub const RC_1: u32 = 0x100u32;
    pub const RC_2: u32 = 0x200u32;
    pub const RC_3: u32 = 0x300u32;
    pub const RC_4: u32 = 0x400u32;
    pub const RC_5: u32 = 0x500u32;
    pub const RC_6: u32 = 0x600u32;
    pub const RC_7: u32 = 0x700u32;
    pub const RC_8: u32 = 0x800u32;
    pub const RC_9: u32 = 0x900u32;
    pub const RC_A: u32 = 0xa00u32;
    pub const RC_B: u32 = 0xb00u32;
    pub const RC_C: u32 = 0xc00u32;
    pub const RC_D: u32 = 0xd00u32;
    pub const RC_E: u32 = 0xe00u32;
    pub const RC_F: u32 = 0xf00u32;
    pub const N_MASK: u32 = 0xf00u32;

    const fn marshalled_size() -> u16 {
        mem::size_of::<u32>() as u16
    }

    fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u32(buf, self.value)
    }

    fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u32(buf)?;

        if Self::SUCCESS == value {
            return Ok((buf, Self{value}));
        }

        if Self::BAD_TAG == value {
            return Ok((buf, Self{value}));
        }

        if Self::VER1 == value {
            return Ok((buf, Self{value}));
        }

        if Self::INITIALIZE == value {
            return Ok((buf, Self{value}));
        }

        if Self::FAILURE == value {
            return Ok((buf, Self{value}));
        }

        if Self::SEQUENCE == value {
            return Ok((buf, Self{value}));
        }

        if Self::PRIVATE == value {
            return Ok((buf, Self{value}));
        }

        if Self::HMAC == value {
            return Ok((buf, Self{value}));
        }

        if Self::DISABLED == value {
            return Ok((buf, Self{value}));
        }

        if Self::EXCLUSIVE == value {
            return Ok((buf, Self{value}));
        }

        if Self::AUTH_TYPE == value {
            return Ok((buf, Self{value}));
        }

        if Self::AUTH_MISSING == value {
            return Ok((buf, Self{value}));
        }

        if Self::POLICY == value {
            return Ok((buf, Self{value}));
        }

        if Self::PCR == value {
            return Ok((buf, Self{value}));
        }

        if Self::PCR_CHANGED == value {
            return Ok((buf, Self{value}));
        }

        if Self::UPGRADE == value {
            return Ok((buf, Self{value}));
        }

        if Self::TOO_MANY_CONTEXTS == value {
            return Ok((buf, Self{value}));
        }

        if Self::AUTH_UNAVAILABLE == value {
            return Ok((buf, Self{value}));
        }

        if Self::REBOOT == value {
            return Ok((buf, Self{value}));
        }

        if Self::UNBALANCED == value {
            return Ok((buf, Self{value}));
        }

        if Self::COMMAND_SIZE == value {
            return Ok((buf, Self{value}));
        }

        if Self::COMMAND_CODE == value {
            return Ok((buf, Self{value}));
        }

        if Self::AUTHSIZE == value {
            return Ok((buf, Self{value}));
        }

        if Self::AUTH_CONTEXT == value {
            return Ok((buf, Self{value}));
        }

        if Self::NV_RANGE == value {
            return Ok((buf, Self{value}));
        }

        if Self::NV_SIZE == value {
            return Ok((buf, Self{value}));
        }

        if Self::NV_LOCKED == value {
            return Ok((buf, Self{value}));
        }

        if Self::NV_AUTHORIZATION == value {
            return Ok((buf, Self{value}));
        }

        if Self::NV_UNINITIALIZED == value {
            return Ok((buf, Self{value}));
        }

        if Self::NV_SPACE == value {
            return Ok((buf, Self{value}));
        }

        if Self::NV_DEFINED == value {
            return Ok((buf, Self{value}));
        }

        if Self::BAD_CONTEXT == value {
            return Ok((buf, Self{value}));
        }

        if Self::CPHASH == value {
            return Ok((buf, Self{value}));
        }

        if Self::PARENT == value {
            return Ok((buf, Self{value}));
        }

        if Self::NEEDS_TEST == value {
            return Ok((buf, Self{value}));
        }

        if Self::NO_RESULT == value {
            return Ok((buf, Self{value}));
        }

        if Self::SENSITIVE == value {
            return Ok((buf, Self{value}));
        }

        if Self::READ_ONLY == value {
            return Ok((buf, Self{value}));
        }

        if Self::MAX_FM0 == value {
            return Ok((buf, Self{value}));
        }

        if Self::FMT1 == value {
            return Ok((buf, Self{value}));
        }

        if Self::ASYMMETRIC == value {
            return Ok((buf, Self{value}));
        }

        if Self::ATTRIBUTES == value {
            return Ok((buf, Self{value}));
        }

        if Self::HASH == value {
            return Ok((buf, Self{value}));
        }

        if Self::VALUE == value {
            return Ok((buf, Self{value}));
        }

        if Self::HIERARCHY == value {
            return Ok((buf, Self{value}));
        }

        if Self::KEY_SIZE == value {
            return Ok((buf, Self{value}));
        }

        if Self::MGF == value {
            return Ok((buf, Self{value}));
        }

        if Self::MODE == value {
            return Ok((buf, Self{value}));
        }

        if Self::TYPE == value {
            return Ok((buf, Self{value}));
        }

        if Self::HANDLE == value {
            return Ok((buf, Self{value}));
        }

        if Self::KDF == value {
            return Ok((buf, Self{value}));
        }

        if Self::RANGE == value {
            return Ok((buf, Self{value}));
        }

        if Self::AUTH_FAIL == value {
            return Ok((buf, Self{value}));
        }

        if Self::NONCE == value {
            return Ok((buf, Self{value}));
        }

        if Self::PP == value {
            return Ok((buf, Self{value}));
        }

        if Self::SCHEME == value {
            return Ok((buf, Self{value}));
        }

        if Self::SIZE == value {
            return Ok((buf, Self{value}));
        }

        if Self::SYMMETRIC == value {
            return Ok((buf, Self{value}));
        }

        if Self::TAG == value {
            return Ok((buf, Self{value}));
        }

        if Self::SELECTOR == value {
            return Ok((buf, Self{value}));
        }

        if Self::INSUFFICIENT == value {
            return Ok((buf, Self{value}));
        }

        if Self::SIGNATURE == value {
            return Ok((buf, Self{value}));
        }

        if Self::KEY == value {
            return Ok((buf, Self{value}));
        }

        if Self::POLICY_FAIL == value {
            return Ok((buf, Self{value}));
        }

        if Self::INTEGRITY == value {
            return Ok((buf, Self{value}));
        }

        if Self::TICKET == value {
            return Ok((buf, Self{value}));
        }

        if Self::RESERVED_BITS == value {
            return Ok((buf, Self{value}));
        }

        if Self::BAD_AUTH == value {
            return Ok((buf, Self{value}));
        }

        if Self::EXPIRED == value {
            return Ok((buf, Self{value}));
        }

        if Self::POLICY_CC == value {
            return Ok((buf, Self{value}));
        }

        if Self::BINDING == value {
            return Ok((buf, Self{value}));
        }

        if Self::CURVE == value {
            return Ok((buf, Self{value}));
        }

        if Self::ECC_POINT == value {
            return Ok((buf, Self{value}));
        }

        if Self::FW_LIMITED == value {
            return Ok((buf, Self{value}));
        }

        if Self::SVN_LIMITED == value {
            return Ok((buf, Self{value}));
        }

        if Self::CHANNEL == value {
            return Ok((buf, Self{value}));
        }

        if Self::CHANNEL_KEY == value {
            return Ok((buf, Self{value}));
        }

        if Self::WARN == value {
            return Ok((buf, Self{value}));
        }

        if Self::CONTEXT_GAP == value {
            return Ok((buf, Self{value}));
        }

        if Self::OBJECT_MEMORY == value {
            return Ok((buf, Self{value}));
        }

        if Self::SESSION_MEMORY == value {
            return Ok((buf, Self{value}));
        }

        if Self::MEMORY == value {
            return Ok((buf, Self{value}));
        }

        if Self::SESSION_HANDLES == value {
            return Ok((buf, Self{value}));
        }

        if Self::OBJECT_HANDLES == value {
            return Ok((buf, Self{value}));
        }

        if Self::LOCALITY == value {
            return Ok((buf, Self{value}));
        }

        if Self::YIELDED == value {
            return Ok((buf, Self{value}));
        }

        if Self::CANCELED == value {
            return Ok((buf, Self{value}));
        }

        if Self::TESTING == value {
            return Ok((buf, Self{value}));
        }

        if Self::REFERENCE_H0 == value {
            return Ok((buf, Self{value}));
        }

        if Self::REFERENCE_H1 == value {
            return Ok((buf, Self{value}));
        }

        if Self::REFERENCE_H2 == value {
            return Ok((buf, Self{value}));
        }

        if Self::REFERENCE_H3 == value {
            return Ok((buf, Self{value}));
        }

        if Self::REFERENCE_H4 == value {
            return Ok((buf, Self{value}));
        }

        if Self::REFERENCE_H5 == value {
            return Ok((buf, Self{value}));
        }

        if Self::REFERENCE_H6 == value {
            return Ok((buf, Self{value}));
        }

        if Self::REFERENCE_S0 == value {
            return Ok((buf, Self{value}));
        }

        if Self::REFERENCE_S1 == value {
            return Ok((buf, Self{value}));
        }

        if Self::REFERENCE_S2 == value {
            return Ok((buf, Self{value}));
        }

        if Self::REFERENCE_S3 == value {
            return Ok((buf, Self{value}));
        }

        if Self::REFERENCE_S4 == value {
            return Ok((buf, Self{value}));
        }

        if Self::REFERENCE_S5 == value {
            return Ok((buf, Self{value}));
        }

        if Self::REFERENCE_S6 == value {
            return Ok((buf, Self{value}));
        }

        if Self::NV_RATE == value {
            return Ok((buf, Self{value}));
        }

        if Self::LOCKOUT == value {
            return Ok((buf, Self{value}));
        }

        if Self::RETRY == value {
            return Ok((buf, Self{value}));
        }

        if Self::NV_UNAVAILABLE == value {
            return Ok((buf, Self{value}));
        }

        if Self::NOT_USED == value {
            return Ok((buf, Self{value}));
        }

        if Self::RC_H == value {
            return Ok((buf, Self{value}));
        }

        if Self::RC_P == value {
            return Ok((buf, Self{value}));
        }

        if Self::RC_S == value {
            return Ok((buf, Self{value}));
        }

        if Self::RC_1 == value {
            return Ok((buf, Self{value}));
        }

        if Self::RC_2 == value {
            return Ok((buf, Self{value}));
        }

        if Self::RC_3 == value {
            return Ok((buf, Self{value}));
        }

        if Self::RC_4 == value {
            return Ok((buf, Self{value}));
        }

        if Self::RC_5 == value {
            return Ok((buf, Self{value}));
        }

        if Self::RC_6 == value {
            return Ok((buf, Self{value}));
        }

        if Self::RC_7 == value {
            return Ok((buf, Self{value}));
        }

        if Self::RC_8 == value {
            return Ok((buf, Self{value}));
        }

        if Self::RC_9 == value {
            return Ok((buf, Self{value}));
        }

        if Self::RC_A == value {
            return Ok((buf, Self{value}));
        }

        if Self::RC_B == value {
            return Ok((buf, Self{value}));
        }

        if Self::RC_C == value {
            return Ok((buf, Self{value}));
        }

        if Self::RC_D == value {
            return Ok((buf, Self{value}));
        }

        if Self::RC_E == value {
            return Ok((buf, Self{value}));
        }

        if Self::RC_F == value {
            return Ok((buf, Self{value}));
        }

        if Self::N_MASK == value {
            return Ok((buf, Self{value}));
        }

        return Err(TpmErr::Rc(Self::VALUE));
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 70, table 21, TPM_CLOCK_ADJUST constants
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(i8)]
pub enum TpmClockAdjust {
    CoarseSlower = -3i8,
    MediumSlower = -2i8,
    FineSlower = -1i8,
    NoChange = 0i8,
    FineFaster = 1i8,
    MediumFaster = 2i8,
    CoarseFaster = 3i8,
}

impl TpmClockAdjust {
    const fn marshalled_size() -> u16 {
        mem::size_of::<i8>() as u16
    }

    fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_i8(buf, *self as i8)
    }

    fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_i8(buf)?;
        let result = Self::try_from(value)?;
        Ok((buf, result))
    }
}

impl convert::TryFrom<i8> for TpmClockAdjust {
    type Error = TpmErr;

    fn try_from(value: i8) -> Result<Self, TpmErr> {
        let result = match value {
            value if value == Self::CoarseSlower as i8 => Self::CoarseSlower,
            value if value == Self::MediumSlower as i8 => Self::MediumSlower,
            value if value == Self::FineSlower as i8 => Self::FineSlower,
            value if value == Self::NoChange as i8 => Self::NoChange,
            value if value == Self::FineFaster as i8 => Self::FineFaster,
            value if value == Self::MediumFaster as i8 => Self::MediumFaster,
            value if value == Self::CoarseFaster as i8 => Self::CoarseFaster,
            _ => {
                return Err(TpmErr::Rc(TpmRc::VALUE));
            },
        };

        Ok(result)
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 70, table 22, TPM_EO constants
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u16)]
pub enum TpmEo {
    Eq = 0x0u16,
    Neq = 0x1u16,
    SignedGt = 0x2u16,
    UnsignedGt = 0x3u16,
    SignedLt = 0x4u16,
    UnsignedLt = 0x5u16,
    SignedGe = 0x6u16,
    UnsignedGe = 0x7u16,
    SignedLe = 0x8u16,
    UnsignedLe = 0x9u16,
    Bitset = 0xau16,
    Bitclear = 0xbu16,
}

impl TpmEo {
    const fn marshalled_size() -> u16 {
        mem::size_of::<u16>() as u16
    }

    fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u16(buf, *self as u16)
    }

    fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u16(buf)?;
        let result = Self::try_from(value)?;
        Ok((buf, result))
    }
}

impl convert::TryFrom<u16> for TpmEo {
    type Error = TpmErr;

    fn try_from(value: u16) -> Result<Self, TpmErr> {
        let result = match value {
            value if value == Self::Eq as u16 => Self::Eq,
            value if value == Self::Neq as u16 => Self::Neq,
            value if value == Self::SignedGt as u16 => Self::SignedGt,
            value if value == Self::UnsignedGt as u16 => Self::UnsignedGt,
            value if value == Self::SignedLt as u16 => Self::SignedLt,
            value if value == Self::UnsignedLt as u16 => Self::UnsignedLt,
            value if value == Self::SignedGe as u16 => Self::SignedGe,
            value if value == Self::UnsignedGe as u16 => Self::UnsignedGe,
            value if value == Self::SignedLe as u16 => Self::SignedLe,
            value if value == Self::UnsignedLe as u16 => Self::UnsignedLe,
            value if value == Self::Bitset as u16 => Self::Bitset,
            value if value == Self::Bitclear as u16 => Self::Bitclear,
            _ => {
                return Err(TpmErr::Rc(TpmRc::VALUE));
            },
        };

        Ok(result)
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 71, table 23, TPM_ST constants
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u16)]
pub enum TpmSt {
    RspCommand = 0xc4u16,
    Null = 0x8000u16,
    NoSessions = 0x8001u16,
    Sessions = 0x8002u16,
    AttestNv = 0x8014u16,
    AttestCommandAudit = 0x8015u16,
    AttestSessionAudit = 0x8016u16,
    AttestCertify = 0x8017u16,
    AttestQuote = 0x8018u16,
    AttestTime = 0x8019u16,
    AttestCreation = 0x801au16,
    AttestNvDigest = 0x801cu16,
    Creation = 0x8021u16,
    Verified = 0x8022u16,
    AuthSecret = 0x8023u16,
    Hashcheck = 0x8024u16,
    AuthSigned = 0x8025u16,
    FuManifest = 0x8029u16,
}

impl TpmSt {
    const fn marshalled_size() -> u16 {
        mem::size_of::<u16>() as u16
    }

    fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u16(buf, *self as u16)
    }

    fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u16(buf)?;
        let result = Self::try_from(value)?;
        Ok((buf, result))
    }
}

impl convert::TryFrom<u16> for TpmSt {
    type Error = TpmErr;

    fn try_from(value: u16) -> Result<Self, TpmErr> {
        let result = match value {
            value if value == Self::RspCommand as u16 => Self::RspCommand,
            value if value == Self::Null as u16 => Self::Null,
            value if value == Self::NoSessions as u16 => Self::NoSessions,
            value if value == Self::Sessions as u16 => Self::Sessions,
            value if value == Self::AttestNv as u16 => Self::AttestNv,
            value if value == Self::AttestCommandAudit as u16 => Self::AttestCommandAudit,
            value if value == Self::AttestSessionAudit as u16 => Self::AttestSessionAudit,
            value if value == Self::AttestCertify as u16 => Self::AttestCertify,
            value if value == Self::AttestQuote as u16 => Self::AttestQuote,
            value if value == Self::AttestTime as u16 => Self::AttestTime,
            value if value == Self::AttestCreation as u16 => Self::AttestCreation,
            value if value == Self::AttestNvDigest as u16 => Self::AttestNvDigest,
            value if value == Self::Creation as u16 => Self::Creation,
            value if value == Self::Verified as u16 => Self::Verified,
            value if value == Self::AuthSecret as u16 => Self::AuthSecret,
            value if value == Self::Hashcheck as u16 => Self::Hashcheck,
            value if value == Self::AuthSigned as u16 => Self::AuthSigned,
            value if value == Self::FuManifest as u16 => Self::FuManifest,
            _ => {
                return Err(TpmErr::Rc(TpmRc::VALUE));
            },
        };

        Ok(result)
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 74, table 24, TPM_SU constants
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u16)]
pub enum TpmSu {
    Clear = 0x0u16,
    State = 0x1u16,
}

impl TpmSu {
    const fn marshalled_size() -> u16 {
        mem::size_of::<u16>() as u16
    }

    fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u16(buf, *self as u16)
    }

    fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u16(buf)?;
        let result = Self::try_from(value)?;
        Ok((buf, result))
    }
}

impl convert::TryFrom<u16> for TpmSu {
    type Error = TpmErr;

    fn try_from(value: u16) -> Result<Self, TpmErr> {
        let result = match value {
            value if value == Self::Clear as u16 => Self::Clear,
            value if value == Self::State as u16 => Self::State,
            _ => {
                return Err(TpmErr::Rc(TpmRc::VALUE));
            },
        };

        Ok(result)
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 75, table 25, TPM_SE constants
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u8)]
pub enum TpmSe {
    Hmac = 0x0u8,
    Policy = 0x1u8,
    Trial = 0x3u8,
}

impl TpmSe {
    const fn marshalled_size() -> u16 {
        mem::size_of::<u8>() as u16
    }

    fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u8(buf, *self as u8)
    }

    fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u8(buf)?;
        let result = Self::try_from(value)?;
        Ok((buf, result))
    }
}

impl convert::TryFrom<u8> for TpmSe {
    type Error = TpmErr;

    fn try_from(value: u8) -> Result<Self, TpmErr> {
        let result = match value {
            value if value == Self::Hmac as u8 => Self::Hmac,
            value if value == Self::Policy as u8 => Self::Policy,
            value if value == Self::Trial as u8 => Self::Trial,
            _ => {
                return Err(TpmErr::Rc(TpmRc::VALUE));
            },
        };

        Ok(result)
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 75, table 26, TPM_CAP constants
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u32)]
pub enum TpmCap {
    Algs = 0x0u32,
    Handles = 0x1u32,
    Commands = 0x2u32,
    PpCommands = 0x3u32,
    AuditCommands = 0x4u32,
    Pcrs = 0x5u32,
    TpmProperties = 0x6u32,
    PcrProperties = 0x7u32,
    #[cfg(feature = "ecc")]
    EccCurves = 0x8u32,
    AuthPolicies = 0x9u32,
    Act = 0xau32,
    PubKeys = 0xbu32,
    SpdmSessionInfo = 0xcu32,
    VendorProperty = 0x100u32,
}

impl TpmCap {
    const fn marshalled_size() -> u16 {
        mem::size_of::<u32>() as u16
    }

    fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u32(buf, *self as u32)
    }

    fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u32(buf)?;
        let result = Self::try_from(value)?;
        Ok((buf, result))
    }
}

impl convert::TryFrom<u32> for TpmCap {
    type Error = TpmErr;

    fn try_from(value: u32) -> Result<Self, TpmErr> {
        let result = match value {
            value if value == Self::Algs as u32 => Self::Algs,
            value if value == Self::Handles as u32 => Self::Handles,
            value if value == Self::Commands as u32 => Self::Commands,
            value if value == Self::PpCommands as u32 => Self::PpCommands,
            value if value == Self::AuditCommands as u32 => Self::AuditCommands,
            value if value == Self::Pcrs as u32 => Self::Pcrs,
            value if value == Self::TpmProperties as u32 => Self::TpmProperties,
            value if value == Self::PcrProperties as u32 => Self::PcrProperties,
            #[cfg(feature = "ecc")]
            value if value == Self::EccCurves as u32 => Self::EccCurves,
            value if value == Self::AuthPolicies as u32 => Self::AuthPolicies,
            value if value == Self::Act as u32 => Self::Act,
            value if value == Self::PubKeys as u32 => Self::PubKeys,
            value if value == Self::SpdmSessionInfo as u32 => Self::SpdmSessionInfo,
            value if value == Self::VendorProperty as u32 => Self::VendorProperty,
            _ => {
                return Err(TpmErr::Rc(TpmRc::VALUE));
            },
        };

        Ok(result)
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 78, table 30, TPM_PT constants
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u32)]
pub enum TpmPt {
    None = 0x0u32,
    FamilyIndicator = Self::FIXED + 0u32,
    Level = Self::FIXED + 1u32,
    Revision = Self::FIXED + 2u32,
    DayOfYear = Self::FIXED + 3u32,
    Year = Self::FIXED + 4u32,
    Manufacturer = Self::FIXED + 5u32,
    VendorString1 = Self::FIXED + 6u32,
    VendorString2 = Self::FIXED + 7u32,
    VendorString3 = Self::FIXED + 8u32,
    VendorString4 = Self::FIXED + 9u32,
    VendorTpmType = Self::FIXED + 10u32,
    FirmwareVersion1 = Self::FIXED + 11u32,
    FirmwareVersion2 = Self::FIXED + 12u32,
    InputBuffer = Self::FIXED + 13u32,
    HrTransientMin = Self::FIXED + 14u32,
    HrPersistentMin = Self::FIXED + 15u32,
    HrLoadedMin = Self::FIXED + 16u32,
    ActiveSessionsMax = Self::FIXED + 17u32,
    PcrCount = Self::FIXED + 18u32,
    PcrSelectMin = Self::FIXED + 19u32,
    ContextGapMax = Self::FIXED + 20u32,
    NvCountersMax = Self::FIXED + 22u32,
    NvIndexMax = Self::FIXED + 23u32,
    Memory = Self::FIXED + 24u32,
    ClockUpdate = Self::FIXED + 25u32,
    ContextHash = Self::FIXED + 26u32,
    ContextSym = Self::FIXED + 27u32,
    ContextSymSize = Self::FIXED + 28u32,
    OrderlyCount = Self::FIXED + 29u32,
    MaxCommandSize = Self::FIXED + 30u32,
    MaxResponseSize = Self::FIXED + 31u32,
    MaxDigest = Self::FIXED + 32u32,
    MaxObjectContext = Self::FIXED + 33u32,
    MaxSessionContext = Self::FIXED + 34u32,
    PsFamilyIndicator = Self::FIXED + 35u32,
    PsLevel = Self::FIXED + 36u32,
    PsRevision = Self::FIXED + 37u32,
    PsDayOfYear = Self::FIXED + 38u32,
    PsYear = Self::FIXED + 39u32,
    SplitMax = Self::FIXED + 40u32,
    TotalCommands = Self::FIXED + 41u32,
    LibraryCommands = Self::FIXED + 42u32,
    VendorCommands = Self::FIXED + 43u32,
    NvBufferMax = Self::FIXED + 44u32,
    Modes = Self::FIXED + 45u32,
    MaxCapBuffer = Self::FIXED + 46u32,
    FirmwareSvn = Self::FIXED + 47u32,
    FirmwareMaxSvn = Self::FIXED + 48u32,
    Permanent = Self::VAR + 0u32,
    StartupClear = Self::VAR + 1u32,
    HrNvIndex = Self::VAR + 2u32,
    HrLoaded = Self::VAR + 3u32,
    HrLoadedAvail = Self::VAR + 4u32,
    HrActive = Self::VAR + 5u32,
    HrActiveAvail = Self::VAR + 6u32,
    HrTransientAvail = Self::VAR + 7u32,
    HrPersistent = Self::VAR + 8u32,
    HrPersistentAvail = Self::VAR + 9u32,
    NvCounters = Self::VAR + 10u32,
    NvCountersAvail = Self::VAR + 11u32,
    AlgorithmSet = Self::VAR + 12u32,
    LoadedCurves = Self::VAR + 13u32,
    LockoutCounter = Self::VAR + 14u32,
    MaxAuthFail = Self::VAR + 15u32,
    LockoutInterval = Self::VAR + 16u32,
    LockoutRecovery = Self::VAR + 17u32,
    NvWriteRecovery = Self::VAR + 18u32,
    AuditCounter0 = Self::VAR + 19u32,
    AuditCounter1 = Self::VAR + 20u32,
}

impl TpmPt {
    const GROUP: u32 = 0x100u32;
    const FIXED: u32 = Self::GROUP * 1u32;
    const VAR: u32 = Self::GROUP * 2u32;

    const fn marshalled_size() -> u16 {
        mem::size_of::<u32>() as u16
    }

    fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u32(buf, *self as u32)
    }

    fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u32(buf)?;
        let result = Self::try_from(value)?;
        Ok((buf, result))
    }
}

impl convert::TryFrom<u32> for TpmPt {
    type Error = TpmErr;

    fn try_from(value: u32) -> Result<Self, TpmErr> {
        let result = match value {
            value if value == Self::None as u32 => Self::None,
            value if value == Self::FamilyIndicator as u32 => Self::FamilyIndicator,
            value if value == Self::Level as u32 => Self::Level,
            value if value == Self::Revision as u32 => Self::Revision,
            value if value == Self::DayOfYear as u32 => Self::DayOfYear,
            value if value == Self::Year as u32 => Self::Year,
            value if value == Self::Manufacturer as u32 => Self::Manufacturer,
            value if value == Self::VendorString1 as u32 => Self::VendorString1,
            value if value == Self::VendorString2 as u32 => Self::VendorString2,
            value if value == Self::VendorString3 as u32 => Self::VendorString3,
            value if value == Self::VendorString4 as u32 => Self::VendorString4,
            value if value == Self::VendorTpmType as u32 => Self::VendorTpmType,
            value if value == Self::FirmwareVersion1 as u32 => Self::FirmwareVersion1,
            value if value == Self::FirmwareVersion2 as u32 => Self::FirmwareVersion2,
            value if value == Self::InputBuffer as u32 => Self::InputBuffer,
            value if value == Self::HrTransientMin as u32 => Self::HrTransientMin,
            value if value == Self::HrPersistentMin as u32 => Self::HrPersistentMin,
            value if value == Self::HrLoadedMin as u32 => Self::HrLoadedMin,
            value if value == Self::ActiveSessionsMax as u32 => Self::ActiveSessionsMax,
            value if value == Self::PcrCount as u32 => Self::PcrCount,
            value if value == Self::PcrSelectMin as u32 => Self::PcrSelectMin,
            value if value == Self::ContextGapMax as u32 => Self::ContextGapMax,
            value if value == Self::NvCountersMax as u32 => Self::NvCountersMax,
            value if value == Self::NvIndexMax as u32 => Self::NvIndexMax,
            value if value == Self::Memory as u32 => Self::Memory,
            value if value == Self::ClockUpdate as u32 => Self::ClockUpdate,
            value if value == Self::ContextHash as u32 => Self::ContextHash,
            value if value == Self::ContextSym as u32 => Self::ContextSym,
            value if value == Self::ContextSymSize as u32 => Self::ContextSymSize,
            value if value == Self::OrderlyCount as u32 => Self::OrderlyCount,
            value if value == Self::MaxCommandSize as u32 => Self::MaxCommandSize,
            value if value == Self::MaxResponseSize as u32 => Self::MaxResponseSize,
            value if value == Self::MaxDigest as u32 => Self::MaxDigest,
            value if value == Self::MaxObjectContext as u32 => Self::MaxObjectContext,
            value if value == Self::MaxSessionContext as u32 => Self::MaxSessionContext,
            value if value == Self::PsFamilyIndicator as u32 => Self::PsFamilyIndicator,
            value if value == Self::PsLevel as u32 => Self::PsLevel,
            value if value == Self::PsRevision as u32 => Self::PsRevision,
            value if value == Self::PsDayOfYear as u32 => Self::PsDayOfYear,
            value if value == Self::PsYear as u32 => Self::PsYear,
            value if value == Self::SplitMax as u32 => Self::SplitMax,
            value if value == Self::TotalCommands as u32 => Self::TotalCommands,
            value if value == Self::LibraryCommands as u32 => Self::LibraryCommands,
            value if value == Self::VendorCommands as u32 => Self::VendorCommands,
            value if value == Self::NvBufferMax as u32 => Self::NvBufferMax,
            value if value == Self::Modes as u32 => Self::Modes,
            value if value == Self::MaxCapBuffer as u32 => Self::MaxCapBuffer,
            value if value == Self::FirmwareSvn as u32 => Self::FirmwareSvn,
            value if value == Self::FirmwareMaxSvn as u32 => Self::FirmwareMaxSvn,
            value if value == Self::Permanent as u32 => Self::Permanent,
            value if value == Self::StartupClear as u32 => Self::StartupClear,
            value if value == Self::HrNvIndex as u32 => Self::HrNvIndex,
            value if value == Self::HrLoaded as u32 => Self::HrLoaded,
            value if value == Self::HrLoadedAvail as u32 => Self::HrLoadedAvail,
            value if value == Self::HrActive as u32 => Self::HrActive,
            value if value == Self::HrActiveAvail as u32 => Self::HrActiveAvail,
            value if value == Self::HrTransientAvail as u32 => Self::HrTransientAvail,
            value if value == Self::HrPersistent as u32 => Self::HrPersistent,
            value if value == Self::HrPersistentAvail as u32 => Self::HrPersistentAvail,
            value if value == Self::NvCounters as u32 => Self::NvCounters,
            value if value == Self::NvCountersAvail as u32 => Self::NvCountersAvail,
            value if value == Self::AlgorithmSet as u32 => Self::AlgorithmSet,
            value if value == Self::LoadedCurves as u32 => Self::LoadedCurves,
            value if value == Self::LockoutCounter as u32 => Self::LockoutCounter,
            value if value == Self::MaxAuthFail as u32 => Self::MaxAuthFail,
            value if value == Self::LockoutInterval as u32 => Self::LockoutInterval,
            value if value == Self::LockoutRecovery as u32 => Self::LockoutRecovery,
            value if value == Self::NvWriteRecovery as u32 => Self::NvWriteRecovery,
            value if value == Self::AuditCounter0 as u32 => Self::AuditCounter0,
            value if value == Self::AuditCounter1 as u32 => Self::AuditCounter1,
            _ => {
                return Err(TpmErr::Rc(TpmRc::VALUE));
            },
        };

        Ok(result)
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 86, table 31, TPM_PT_PCR constants
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u32)]
pub enum TpmPtPcr {
    Save = 0x0u32,
    ExtendL0 = 0x1u32,
    ResetL0 = 0x2u32,
    ExtendL1 = 0x3u32,
    ResetL1 = 0x4u32,
    ExtendL2 = 0x5u32,
    ResetL2 = 0x6u32,
    ExtendL3 = 0x7u32,
    ResetL3 = 0x8u32,
    ExtendL4 = 0x9u32,
    ResetL4 = 0xau32,
    NoIncrement = 0x11u32,
    DrtmReset = 0x12u32,
    Policy = 0x13u32,
    Auth = 0x14u32,
}

impl TpmPtPcr {
    const fn marshalled_size() -> u16 {
        mem::size_of::<u32>() as u16
    }

    fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u32(buf, *self as u32)
    }

    fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u32(buf)?;
        let result = Self::try_from(value)?;
        Ok((buf, result))
    }
}

impl convert::TryFrom<u32> for TpmPtPcr {
    type Error = TpmErr;

    fn try_from(value: u32) -> Result<Self, TpmErr> {
        let result = match value {
            value if value == Self::Save as u32 => Self::Save,
            value if value == Self::ExtendL0 as u32 => Self::ExtendL0,
            value if value == Self::ResetL0 as u32 => Self::ResetL0,
            value if value == Self::ExtendL1 as u32 => Self::ExtendL1,
            value if value == Self::ResetL1 as u32 => Self::ResetL1,
            value if value == Self::ExtendL2 as u32 => Self::ExtendL2,
            value if value == Self::ResetL2 as u32 => Self::ResetL2,
            value if value == Self::ExtendL3 as u32 => Self::ExtendL3,
            value if value == Self::ResetL3 as u32 => Self::ResetL3,
            value if value == Self::ExtendL4 as u32 => Self::ExtendL4,
            value if value == Self::ResetL4 as u32 => Self::ResetL4,
            value if value == Self::NoIncrement as u32 => Self::NoIncrement,
            value if value == Self::DrtmReset as u32 => Self::DrtmReset,
            value if value == Self::Policy as u32 => Self::Policy,
            value if value == Self::Auth as u32 => Self::Auth,
            _ => {
                return Err(TpmErr::Rc(TpmRc::VALUE));
            },
        };

        Ok(result)
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 90, table 35, TPM_HT constants
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
struct TpmHt {
}

impl TpmHt {
    const PCR: u8 = 0x0u8;
    const NV_INDEX: u8 = 0x1u8;
    const HMAC_SESSION: u8 = 0x2u8;
    const POLICY_SESSION: u8 = 0x3u8;
    const EXTERNAL_NV: u8 = 0x11u8;
    const PERMANENT_NV: u8 = 0x12u8;
    const TRANSIENT: u8 = 0x80u8;
    const PERSISTENT: u8 = 0x81u8;
    const AC: u8 = 0x90u8;
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 92, table 36, TPM_RH constants
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u32)]
enum TpmRh {
    Owner = 0x40000001u32,
    Null = 0x40000007u32,
    RsPw = 0x40000009u32,
    Lockout = 0x4000000au32,
    Endorsement = 0x4000000bu32,
    Platform = 0x4000000cu32,
    PlatformNv = 0x4000000du32,
    Auth00 = 0x40000010u32,
    AuthFf = 0x4000010fu32,
    Act0 = 0x40000110u32,
    ActF = 0x4000011fu32,
    FwOwner = 0x40000140u32,
    FwEndorsement = 0x40000141u32,
    FwPlatform = 0x40000142u32,
    FwNull = 0x40000143u32,
    SvnOwnerBase = 0x40010000u32,
    SvnEndorsementBase = 0x40020000u32,
    SvnPlatformBase = 0x40030000u32,
    SvnNullBase = 0x40040000u32,
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 94, table 37, TPM_HC constants
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
struct TpmHc {
}

impl TpmHc {
    const HR_SHIFT: u32 = 24u32;
    const HR_PCR: u32 = (TpmHt::PCR as u32) << Self::HR_SHIFT;
    const HR_HMAC_SESSION: u32 = (TpmHt::HMAC_SESSION as u32) << Self::HR_SHIFT;
    const HR_POLICY_SESSION: u32 = (TpmHt::POLICY_SESSION as u32) << Self::HR_SHIFT;
    const HR_TRANSIENT: u32 = (TpmHt::TRANSIENT as u32) << Self::HR_SHIFT;
    const HR_PERSISTENT: u32 = (TpmHt::PERSISTENT as u32) << Self::HR_SHIFT;
    const HR_NV_INDEX: u32 = (TpmHt::NV_INDEX as u32) << Self::HR_SHIFT;
    const HR_EXTERNAL_NV: u32 = (TpmHt::EXTERNAL_NV as u32) << Self::HR_SHIFT;
    const HR_PERMANENT_NV: u32 = (TpmHt::PERMANENT_NV as u32) << Self::HR_SHIFT;
    const PCR_FIRST: u32 = Self::HR_PCR + 0u32;

    fn pcr_last(limits: &TpmLimits) -> Result<u32, ()> {
        let v0 = match Self::PCR_FIRST.checked_add(limits.implementation_pcr) {
            Some(v) => v,
            None => {
                return Err(());
            },
        };
        let v0 = match v0.checked_sub(1u32) {
            Some(v) => v,
            None => {
                return Err(());
            },
        };
        Ok(v0)
    }

    const HMAC_SESSION_FIRST: u32 = Self::HR_HMAC_SESSION + 0u32;

    fn hmac_session_last(limits: &TpmLimits) -> Result<u32, ()> {
        let v0 = match Self::HMAC_SESSION_FIRST.checked_add(limits.max_active_sessions) {
            Some(v) => v,
            None => {
                return Err(());
            },
        };
        let v0 = match v0.checked_sub(1u32) {
            Some(v) => v,
            None => {
                return Err(());
            },
        };
        Ok(v0)
    }

    const POLICY_SESSION_FIRST: u32 = Self::HR_POLICY_SESSION + 0u32;

    fn policy_session_last(limits: &TpmLimits) -> Result<u32, ()> {
        let v0 = match Self::POLICY_SESSION_FIRST.checked_add(limits.max_active_sessions) {
            Some(v) => v,
            None => {
                return Err(());
            },
        };
        let v0 = match v0.checked_sub(1u32) {
            Some(v) => v,
            None => {
                return Err(());
            },
        };
        Ok(v0)
    }

    const TRANSIENT_FIRST: u32 = Self::HR_TRANSIENT + 0u32;

    fn transient_last(limits: &TpmLimits) -> Result<u32, ()> {
        let v0 = match Self::TRANSIENT_FIRST.checked_add(limits.max_loaded_objects) {
            Some(v) => v,
            None => {
                return Err(());
            },
        };
        let v0 = match v0.checked_sub(1u32) {
            Some(v) => v,
            None => {
                return Err(());
            },
        };
        Ok(v0)
    }

    const PERSISTENT_FIRST: u32 = Self::HR_PERSISTENT + 0u32;
    const PERSISTENT_LAST: u32 = Self::PERSISTENT_FIRST + 0xffffffu32;
    const NV_INDEX_FIRST: u32 = Self::HR_NV_INDEX + 0u32;
    const NV_INDEX_LAST: u32 = Self::NV_INDEX_FIRST + 0xffffffu32;
    const EXTERNAL_NV_FIRST: u32 = Self::HR_EXTERNAL_NV + 0u32;
    const EXTERNAL_NV_LAST: u32 = Self::EXTERNAL_NV_FIRST + 0xffffffu32;
    const PERMANENT_NV_FIRST: u32 = Self::HR_PERMANENT_NV + 0u32;
    const PERMANENT_NV_LAST: u32 = Self::PERMANENT_NV_FIRST + 0xffffffu32;
    const SVN_OWNER_FIRST: u32 = TpmRh::SvnOwnerBase as u32 + 0x0u32;
    const SVN_OWNER_LAST: u32 = TpmRh::SvnOwnerBase as u32 + 0xffffu32;
    const SVN_ENDORSEMENT_FIRST: u32 = TpmRh::SvnEndorsementBase as u32 + 0x0u32;
    const SVN_ENDORSEMENT_LAST: u32 = TpmRh::SvnEndorsementBase as u32 + 0xffffu32;
    const SVN_PLATFORM_FIRST: u32 = TpmRh::SvnPlatformBase as u32 + 0x0u32;
    const SVN_PLATFORM_LAST: u32 = TpmRh::SvnPlatformBase as u32 + 0xffffu32;
    const SVN_NULL_FIRST: u32 = TpmRh::SvnNullBase as u32 + 0x0u32;
    const SVN_NULL_LAST: u32 = TpmRh::SvnNullBase as u32 + 0xffffu32;
    const HR_AC: u32 = (TpmHt::AC as u32) << Self::HR_SHIFT;
    const AC_FIRST: u32 = Self::HR_AC + 0u32;
    const AC_LAST: u32 = Self::HR_AC + 0xffffu32;
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 97, table 38, TPMA_ALGORITHM bits
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct TpmaAlgorithm {
    value: u32,
}

impl TpmaAlgorithm {
    pub fn new() -> Self {
        Self { value: 0u32 }
    }

    const ASYMMETRIC_MASK: u32 = 1u32 << 0u32;

    pub fn get_asymmetric(&self) -> bool {
        self.value & Self::ASYMMETRIC_MASK != 0
    }

    pub fn set_asymmetric(&mut self, value: bool) {
        if value {
            self.value |= Self::ASYMMETRIC_MASK;
        } else {
            self.value &= !Self::ASYMMETRIC_MASK;
        }
    }

    const SYMMETRIC_MASK: u32 = 1u32 << 1u32;

    pub fn get_symmetric(&self) -> bool {
        self.value & Self::SYMMETRIC_MASK != 0
    }

    pub fn set_symmetric(&mut self, value: bool) {
        if value {
            self.value |= Self::SYMMETRIC_MASK;
        } else {
            self.value &= !Self::SYMMETRIC_MASK;
        }
    }

    const HASH_MASK: u32 = 1u32 << 2u32;

    pub fn get_hash(&self) -> bool {
        self.value & Self::HASH_MASK != 0
    }

    pub fn set_hash(&mut self, value: bool) {
        if value {
            self.value |= Self::HASH_MASK;
        } else {
            self.value &= !Self::HASH_MASK;
        }
    }

    const OBJECT_MASK: u32 = 1u32 << 3u32;

    pub fn get_object(&self) -> bool {
        self.value & Self::OBJECT_MASK != 0
    }

    pub fn set_object(&mut self, value: bool) {
        if value {
            self.value |= Self::OBJECT_MASK;
        } else {
            self.value &= !Self::OBJECT_MASK;
        }
    }

    const SIGNING_MASK: u32 = 1u32 << 8u32;

    pub fn get_signing(&self) -> bool {
        self.value & Self::SIGNING_MASK != 0
    }

    pub fn set_signing(&mut self, value: bool) {
        if value {
            self.value |= Self::SIGNING_MASK;
        } else {
            self.value &= !Self::SIGNING_MASK;
        }
    }

    const ENCRYPTING_MASK: u32 = 1u32 << 9u32;

    pub fn get_encrypting(&self) -> bool {
        self.value & Self::ENCRYPTING_MASK != 0
    }

    pub fn set_encrypting(&mut self, value: bool) {
        if value {
            self.value |= Self::ENCRYPTING_MASK;
        } else {
            self.value &= !Self::ENCRYPTING_MASK;
        }
    }

    const METHOD_MASK: u32 = 1u32 << 10u32;

    pub fn get_method(&self) -> bool {
        self.value & Self::METHOD_MASK != 0
    }

    pub fn set_method(&mut self, value: bool) {
        if value {
            self.value |= Self::METHOD_MASK;
        } else {
            self.value &= !Self::METHOD_MASK;
        }
    }

    const RESERVED_MASK0: u32 = 0xffffffffu32 >> (32u32 - 1u32 - 7u32 + 4u32) << 4u32;
    const RESERVED_MASK1: u32 = 0xffffffffu32 >> (32u32 - 1u32 - 31u32 + 11u32) << 11u32;
    const RESERVED_MASK: u32 = Self::RESERVED_MASK0 | Self::RESERVED_MASK1;

    pub const fn marshalled_size() -> u16 {
        mem::size_of::<u32>() as u16
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u32(buf, self.value)
    }

    pub fn unmarshal(buf: &[u8]) -> Result<(&[u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u32(buf)?;
        let result = Self::try_from(value)?;
        Ok((buf, result))
    }
}

impl convert::TryFrom<u32> for TpmaAlgorithm {
    type Error = TpmErr;

    fn try_from(value: u32) -> Result<Self, TpmErr> {

        if value & Self::RESERVED_MASK != 0 {
            return Err(TpmErr::Rc(TpmRc::RESERVED_BITS));
        }

        Ok(Self { value })
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 98, table 39, TPMA_OBJECT bits
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct TpmaObject {
    value: u32,
}

impl TpmaObject {
    pub fn new() -> Self {
        Self { value: 0u32 }
    }

    const FIXED_TPM_MASK: u32 = 1u32 << 1u32;

    pub fn get_fixed_tpm(&self) -> bool {
        self.value & Self::FIXED_TPM_MASK != 0
    }

    pub fn set_fixed_tpm(&mut self, value: bool) {
        if value {
            self.value |= Self::FIXED_TPM_MASK;
        } else {
            self.value &= !Self::FIXED_TPM_MASK;
        }
    }

    const ST_CLEAR_MASK: u32 = 1u32 << 2u32;

    pub fn get_st_clear(&self) -> bool {
        self.value & Self::ST_CLEAR_MASK != 0
    }

    pub fn set_st_clear(&mut self, value: bool) {
        if value {
            self.value |= Self::ST_CLEAR_MASK;
        } else {
            self.value &= !Self::ST_CLEAR_MASK;
        }
    }

    const FIXED_PARENT_MASK: u32 = 1u32 << 4u32;

    pub fn get_fixed_parent(&self) -> bool {
        self.value & Self::FIXED_PARENT_MASK != 0
    }

    pub fn set_fixed_parent(&mut self, value: bool) {
        if value {
            self.value |= Self::FIXED_PARENT_MASK;
        } else {
            self.value &= !Self::FIXED_PARENT_MASK;
        }
    }

    const SENSITIVE_DATA_ORIGIN_MASK: u32 = 1u32 << 5u32;

    pub fn get_sensitive_data_origin(&self) -> bool {
        self.value & Self::SENSITIVE_DATA_ORIGIN_MASK != 0
    }

    pub fn set_sensitive_data_origin(&mut self, value: bool) {
        if value {
            self.value |= Self::SENSITIVE_DATA_ORIGIN_MASK;
        } else {
            self.value &= !Self::SENSITIVE_DATA_ORIGIN_MASK;
        }
    }

    const USER_WITH_AUTH_MASK: u32 = 1u32 << 6u32;

    pub fn get_user_with_auth(&self) -> bool {
        self.value & Self::USER_WITH_AUTH_MASK != 0
    }

    pub fn set_user_with_auth(&mut self, value: bool) {
        if value {
            self.value |= Self::USER_WITH_AUTH_MASK;
        } else {
            self.value &= !Self::USER_WITH_AUTH_MASK;
        }
    }

    const ADMIN_WITH_POLICY_MASK: u32 = 1u32 << 7u32;

    pub fn get_admin_with_policy(&self) -> bool {
        self.value & Self::ADMIN_WITH_POLICY_MASK != 0
    }

    pub fn set_admin_with_policy(&mut self, value: bool) {
        if value {
            self.value |= Self::ADMIN_WITH_POLICY_MASK;
        } else {
            self.value &= !Self::ADMIN_WITH_POLICY_MASK;
        }
    }

    const FIRMWARE_LIMITED_MASK: u32 = 1u32 << 8u32;

    pub fn get_firmware_limited(&self) -> bool {
        self.value & Self::FIRMWARE_LIMITED_MASK != 0
    }

    pub fn set_firmware_limited(&mut self, value: bool) {
        if value {
            self.value |= Self::FIRMWARE_LIMITED_MASK;
        } else {
            self.value &= !Self::FIRMWARE_LIMITED_MASK;
        }
    }

    const SVN_LIMITED_MASK: u32 = 1u32 << 9u32;

    pub fn get_svn_limited(&self) -> bool {
        self.value & Self::SVN_LIMITED_MASK != 0
    }

    pub fn set_svn_limited(&mut self, value: bool) {
        if value {
            self.value |= Self::SVN_LIMITED_MASK;
        } else {
            self.value &= !Self::SVN_LIMITED_MASK;
        }
    }

    const NO_DA_MASK: u32 = 1u32 << 10u32;

    pub fn get_no_da(&self) -> bool {
        self.value & Self::NO_DA_MASK != 0
    }

    pub fn set_no_da(&mut self, value: bool) {
        if value {
            self.value |= Self::NO_DA_MASK;
        } else {
            self.value &= !Self::NO_DA_MASK;
        }
    }

    const ENCRYPTED_DUPLICATION_MASK: u32 = 1u32 << 11u32;

    pub fn get_encrypted_duplication(&self) -> bool {
        self.value & Self::ENCRYPTED_DUPLICATION_MASK != 0
    }

    pub fn set_encrypted_duplication(&mut self, value: bool) {
        if value {
            self.value |= Self::ENCRYPTED_DUPLICATION_MASK;
        } else {
            self.value &= !Self::ENCRYPTED_DUPLICATION_MASK;
        }
    }

    const RESTRICTED_MASK: u32 = 1u32 << 16u32;

    pub fn get_restricted(&self) -> bool {
        self.value & Self::RESTRICTED_MASK != 0
    }

    pub fn set_restricted(&mut self, value: bool) {
        if value {
            self.value |= Self::RESTRICTED_MASK;
        } else {
            self.value &= !Self::RESTRICTED_MASK;
        }
    }

    const DECRYPT_MASK: u32 = 1u32 << 17u32;

    pub fn get_decrypt(&self) -> bool {
        self.value & Self::DECRYPT_MASK != 0
    }

    pub fn set_decrypt(&mut self, value: bool) {
        if value {
            self.value |= Self::DECRYPT_MASK;
        } else {
            self.value &= !Self::DECRYPT_MASK;
        }
    }

    const SIGN_ENCRYPT_MASK: u32 = 1u32 << 18u32;

    pub fn get_sign_encrypt(&self) -> bool {
        self.value & Self::SIGN_ENCRYPT_MASK != 0
    }

    pub fn set_sign_encrypt(&mut self, value: bool) {
        if value {
            self.value |= Self::SIGN_ENCRYPT_MASK;
        } else {
            self.value &= !Self::SIGN_ENCRYPT_MASK;
        }
    }

    const X509_SIGN_MASK: u32 = 1u32 << 19u32;

    pub fn get_x509_sign(&self) -> bool {
        self.value & Self::X509_SIGN_MASK != 0
    }

    pub fn set_x509_sign(&mut self, value: bool) {
        if value {
            self.value |= Self::X509_SIGN_MASK;
        } else {
            self.value &= !Self::X509_SIGN_MASK;
        }
    }

    const RESERVED_MASK0: u32 = 1u32 << 0u32;
    const RESERVED_MASK1: u32 = 1u32 << 3u32;
    const RESERVED_MASK2: u32 = 0xffffffffu32 >> (32u32 - 1u32 - 15u32 + 12u32) << 12u32;
    const RESERVED_MASK3: u32 = 0xffffffffu32 >> (32u32 - 1u32 - 31u32 + 20u32) << 20u32;
    const RESERVED_MASK: u32 = Self::RESERVED_MASK0 | Self::RESERVED_MASK1 | Self::RESERVED_MASK2 | Self::RESERVED_MASK3;

    pub const fn marshalled_size() -> u16 {
        mem::size_of::<u32>() as u16
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u32(buf, self.value)
    }

    pub fn unmarshal(buf: &[u8]) -> Result<(&[u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u32(buf)?;
        let result = Self::try_from(value)?;
        Ok((buf, result))
    }
}

impl convert::TryFrom<u32> for TpmaObject {
    type Error = TpmErr;

    fn try_from(value: u32) -> Result<Self, TpmErr> {

        if value & Self::RESERVED_MASK != 0 {
            return Err(TpmErr::Rc(TpmRc::RESERVED_BITS));
        }

        Ok(Self { value })
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 107, table 40, TPMA_SESSION bits
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct TpmaSession {
    value: u8,
}

impl TpmaSession {
    pub fn new() -> Self {
        Self { value: 0u8 }
    }

    const CONTINUE_SESSION_MASK: u8 = 1u8 << 0u32;

    pub fn get_continue_session(&self) -> bool {
        self.value & Self::CONTINUE_SESSION_MASK != 0
    }

    pub fn set_continue_session(&mut self, value: bool) {
        if value {
            self.value |= Self::CONTINUE_SESSION_MASK;
        } else {
            self.value &= !Self::CONTINUE_SESSION_MASK;
        }
    }

    const AUDIT_EXCLUSIVE_MASK: u8 = 1u8 << 1u32;

    pub fn get_audit_exclusive(&self) -> bool {
        self.value & Self::AUDIT_EXCLUSIVE_MASK != 0
    }

    pub fn set_audit_exclusive(&mut self, value: bool) {
        if value {
            self.value |= Self::AUDIT_EXCLUSIVE_MASK;
        } else {
            self.value &= !Self::AUDIT_EXCLUSIVE_MASK;
        }
    }

    const AUDIT_RESET_MASK: u8 = 1u8 << 2u32;

    pub fn get_audit_reset(&self) -> bool {
        self.value & Self::AUDIT_RESET_MASK != 0
    }

    pub fn set_audit_reset(&mut self, value: bool) {
        if value {
            self.value |= Self::AUDIT_RESET_MASK;
        } else {
            self.value &= !Self::AUDIT_RESET_MASK;
        }
    }

    const DECRYPT_MASK: u8 = 1u8 << 5u32;

    pub fn get_decrypt(&self) -> bool {
        self.value & Self::DECRYPT_MASK != 0
    }

    pub fn set_decrypt(&mut self, value: bool) {
        if value {
            self.value |= Self::DECRYPT_MASK;
        } else {
            self.value &= !Self::DECRYPT_MASK;
        }
    }

    const ENCRYPT_MASK: u8 = 1u8 << 6u32;

    pub fn get_encrypt(&self) -> bool {
        self.value & Self::ENCRYPT_MASK != 0
    }

    pub fn set_encrypt(&mut self, value: bool) {
        if value {
            self.value |= Self::ENCRYPT_MASK;
        } else {
            self.value &= !Self::ENCRYPT_MASK;
        }
    }

    const AUDIT_MASK: u8 = 1u8 << 7u32;

    pub fn get_audit(&self) -> bool {
        self.value & Self::AUDIT_MASK != 0
    }

    pub fn set_audit(&mut self, value: bool) {
        if value {
            self.value |= Self::AUDIT_MASK;
        } else {
            self.value &= !Self::AUDIT_MASK;
        }
    }

    const RESERVED_MASK: u8 = 0xffu8 >> (8u32 - 1u32 - 4u32 + 3u32) << 3u32;

    pub const fn marshalled_size() -> u16 {
        mem::size_of::<u8>() as u16
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u8(buf, self.value)
    }

    pub fn unmarshal(buf: &[u8]) -> Result<(&[u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u8(buf)?;
        let result = Self::try_from(value)?;
        Ok((buf, result))
    }
}

impl convert::TryFrom<u8> for TpmaSession {
    type Error = TpmErr;

    fn try_from(value: u8) -> Result<Self, TpmErr> {

        if value & Self::RESERVED_MASK != 0 {
            return Err(TpmErr::Rc(TpmRc::RESERVED_BITS));
        }

        Ok(Self { value })
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 109, table 41, TPMA_LOCALITY bits
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct TpmaLocality {
    value: u8,
}

impl TpmaLocality {
    pub fn new() -> Self {
        Self { value: 0u8 }
    }

    const TPM_LOC_ZERO_MASK: u8 = 1u8 << 0u32;

    pub fn get_tpm_loc_zero(&self) -> bool {
        self.value & Self::TPM_LOC_ZERO_MASK != 0
    }

    pub fn set_tpm_loc_zero(&mut self, value: bool) {
        if value {
            self.value |= Self::TPM_LOC_ZERO_MASK;
        } else {
            self.value &= !Self::TPM_LOC_ZERO_MASK;
        }
    }

    const TPM_LOC_ONE_MASK: u8 = 1u8 << 1u32;

    pub fn get_tpm_loc_one(&self) -> bool {
        self.value & Self::TPM_LOC_ONE_MASK != 0
    }

    pub fn set_tpm_loc_one(&mut self, value: bool) {
        if value {
            self.value |= Self::TPM_LOC_ONE_MASK;
        } else {
            self.value &= !Self::TPM_LOC_ONE_MASK;
        }
    }

    const TPM_LOC_TWO_MASK: u8 = 1u8 << 2u32;

    pub fn get_tpm_loc_two(&self) -> bool {
        self.value & Self::TPM_LOC_TWO_MASK != 0
    }

    pub fn set_tpm_loc_two(&mut self, value: bool) {
        if value {
            self.value |= Self::TPM_LOC_TWO_MASK;
        } else {
            self.value &= !Self::TPM_LOC_TWO_MASK;
        }
    }

    const TPM_LOC_THREE_MASK: u8 = 1u8 << 3u32;

    pub fn get_tpm_loc_three(&self) -> bool {
        self.value & Self::TPM_LOC_THREE_MASK != 0
    }

    pub fn set_tpm_loc_three(&mut self, value: bool) {
        if value {
            self.value |= Self::TPM_LOC_THREE_MASK;
        } else {
            self.value &= !Self::TPM_LOC_THREE_MASK;
        }
    }

    const TPM_LOC_FOUR_MASK: u8 = 1u8 << 4u32;

    pub fn get_tpm_loc_four(&self) -> bool {
        self.value & Self::TPM_LOC_FOUR_MASK != 0
    }

    pub fn set_tpm_loc_four(&mut self, value: bool) {
        if value {
            self.value |= Self::TPM_LOC_FOUR_MASK;
        } else {
            self.value &= !Self::TPM_LOC_FOUR_MASK;
        }
    }

    const EXTENDED_MASK: u8 = 0xffu8 >> (8u32 - 1u32 - 7u32 + 5u32) << 5u32;
    const EXTENDED_SHIFT: u32 = 5u32;

    pub fn get_extended(&self) -> u8 {
        (self.value & Self::EXTENDED_MASK) >> Self::EXTENDED_SHIFT
    }

    pub fn set_extended(&mut self, value: u8) {
        let value = value << Self::EXTENDED_SHIFT;
        debug_assert!(value & !Self::EXTENDED_MASK == 0, "invalid bitfield value");
        self.value &= !Self::EXTENDED_MASK;
        self.value |= value;
    }

    pub const fn marshalled_size() -> u16 {
        mem::size_of::<u8>() as u16
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u8(buf, self.value)
    }

    pub fn unmarshal(buf: &[u8]) -> Result<(&[u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u8(buf)?;
        let result = Self::from(value);
        Ok((buf, result))
    }
}

impl convert::From<u8> for TpmaLocality {
    fn from(value: u8) -> Self {
        Self { value }
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 109, table 42, TPMA_PERMANENT bits
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct TpmaPermanent {
    value: u32,
}

impl TpmaPermanent {
    pub fn new() -> Self {
        Self { value: 0u32 }
    }

    const OWNER_AUTH_SET_MASK: u32 = 1u32 << 0u32;

    pub fn get_owner_auth_set(&self) -> bool {
        self.value & Self::OWNER_AUTH_SET_MASK != 0
    }

    pub fn set_owner_auth_set(&mut self, value: bool) {
        if value {
            self.value |= Self::OWNER_AUTH_SET_MASK;
        } else {
            self.value &= !Self::OWNER_AUTH_SET_MASK;
        }
    }

    const ENDORSEMENT_AUTH_SET_MASK: u32 = 1u32 << 1u32;

    pub fn get_endorsement_auth_set(&self) -> bool {
        self.value & Self::ENDORSEMENT_AUTH_SET_MASK != 0
    }

    pub fn set_endorsement_auth_set(&mut self, value: bool) {
        if value {
            self.value |= Self::ENDORSEMENT_AUTH_SET_MASK;
        } else {
            self.value &= !Self::ENDORSEMENT_AUTH_SET_MASK;
        }
    }

    const LOCKOUT_AUTH_SET_MASK: u32 = 1u32 << 2u32;

    pub fn get_lockout_auth_set(&self) -> bool {
        self.value & Self::LOCKOUT_AUTH_SET_MASK != 0
    }

    pub fn set_lockout_auth_set(&mut self, value: bool) {
        if value {
            self.value |= Self::LOCKOUT_AUTH_SET_MASK;
        } else {
            self.value &= !Self::LOCKOUT_AUTH_SET_MASK;
        }
    }

    const DISABLE_CLEAR_MASK: u32 = 1u32 << 8u32;

    pub fn get_disable_clear(&self) -> bool {
        self.value & Self::DISABLE_CLEAR_MASK != 0
    }

    pub fn set_disable_clear(&mut self, value: bool) {
        if value {
            self.value |= Self::DISABLE_CLEAR_MASK;
        } else {
            self.value &= !Self::DISABLE_CLEAR_MASK;
        }
    }

    const IN_LOCKOUT_MASK: u32 = 1u32 << 9u32;

    pub fn get_in_lockout(&self) -> bool {
        self.value & Self::IN_LOCKOUT_MASK != 0
    }

    pub fn set_in_lockout(&mut self, value: bool) {
        if value {
            self.value |= Self::IN_LOCKOUT_MASK;
        } else {
            self.value &= !Self::IN_LOCKOUT_MASK;
        }
    }

    const TPM_GENERATED_EPS_MASK: u32 = 1u32 << 10u32;

    pub fn get_tpm_generated_eps(&self) -> bool {
        self.value & Self::TPM_GENERATED_EPS_MASK != 0
    }

    pub fn set_tpm_generated_eps(&mut self, value: bool) {
        if value {
            self.value |= Self::TPM_GENERATED_EPS_MASK;
        } else {
            self.value &= !Self::TPM_GENERATED_EPS_MASK;
        }
    }

    const RESERVED_MASK0: u32 = 0xffffffffu32 >> (32u32 - 1u32 - 7u32 + 3u32) << 3u32;
    const RESERVED_MASK1: u32 = 0xffffffffu32 >> (32u32 - 1u32 - 31u32 + 11u32) << 11u32;
    const RESERVED_MASK: u32 = Self::RESERVED_MASK0 | Self::RESERVED_MASK1;

    pub const fn marshalled_size() -> u16 {
        mem::size_of::<u32>() as u16
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u32(buf, self.value)
    }

    pub fn unmarshal(buf: &[u8]) -> Result<(&[u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u32(buf)?;
        let result = Self::try_from(value)?;
        Ok((buf, result))
    }
}

impl convert::TryFrom<u32> for TpmaPermanent {
    type Error = TpmErr;

    fn try_from(value: u32) -> Result<Self, TpmErr> {

        if value & Self::RESERVED_MASK != 0 {
            return Err(TpmErr::Rc(TpmRc::RESERVED_BITS));
        }

        Ok(Self { value })
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 110, table 43, TPMA_STARTUP_CLEAR bits
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct TpmaStartupClear {
    value: u32,
}

impl TpmaStartupClear {
    pub fn new() -> Self {
        Self { value: 0u32 }
    }

    const PH_ENABLE_MASK: u32 = 1u32 << 0u32;

    pub fn get_ph_enable(&self) -> bool {
        self.value & Self::PH_ENABLE_MASK != 0
    }

    pub fn set_ph_enable(&mut self, value: bool) {
        if value {
            self.value |= Self::PH_ENABLE_MASK;
        } else {
            self.value &= !Self::PH_ENABLE_MASK;
        }
    }

    const SH_ENABLE_MASK: u32 = 1u32 << 1u32;

    pub fn get_sh_enable(&self) -> bool {
        self.value & Self::SH_ENABLE_MASK != 0
    }

    pub fn set_sh_enable(&mut self, value: bool) {
        if value {
            self.value |= Self::SH_ENABLE_MASK;
        } else {
            self.value &= !Self::SH_ENABLE_MASK;
        }
    }

    const EH_ENABLE_MASK: u32 = 1u32 << 2u32;

    pub fn get_eh_enable(&self) -> bool {
        self.value & Self::EH_ENABLE_MASK != 0
    }

    pub fn set_eh_enable(&mut self, value: bool) {
        if value {
            self.value |= Self::EH_ENABLE_MASK;
        } else {
            self.value &= !Self::EH_ENABLE_MASK;
        }
    }

    const PH_ENABLE_NV_MASK: u32 = 1u32 << 3u32;

    pub fn get_ph_enable_nv(&self) -> bool {
        self.value & Self::PH_ENABLE_NV_MASK != 0
    }

    pub fn set_ph_enable_nv(&mut self, value: bool) {
        if value {
            self.value |= Self::PH_ENABLE_NV_MASK;
        } else {
            self.value &= !Self::PH_ENABLE_NV_MASK;
        }
    }

    const READ_ONLY_MASK: u32 = 1u32 << 4u32;

    pub fn get_read_only(&self) -> bool {
        self.value & Self::READ_ONLY_MASK != 0
    }

    pub fn set_read_only(&mut self, value: bool) {
        if value {
            self.value |= Self::READ_ONLY_MASK;
        } else {
            self.value &= !Self::READ_ONLY_MASK;
        }
    }

    const ORDERLY_MASK: u32 = 1u32 << 31u32;

    pub fn get_orderly(&self) -> bool {
        self.value & Self::ORDERLY_MASK != 0
    }

    pub fn set_orderly(&mut self, value: bool) {
        if value {
            self.value |= Self::ORDERLY_MASK;
        } else {
            self.value &= !Self::ORDERLY_MASK;
        }
    }

    const RESERVED_MASK: u32 = 0xffffffffu32 >> (32u32 - 1u32 - 30u32 + 5u32) << 5u32;

    pub const fn marshalled_size() -> u16 {
        mem::size_of::<u32>() as u16
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u32(buf, self.value)
    }

    pub fn unmarshal(buf: &[u8]) -> Result<(&[u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u32(buf)?;
        let result = Self::try_from(value)?;
        Ok((buf, result))
    }
}

impl convert::TryFrom<u32> for TpmaStartupClear {
    type Error = TpmErr;

    fn try_from(value: u32) -> Result<Self, TpmErr> {

        if value & Self::RESERVED_MASK != 0 {
            return Err(TpmErr::Rc(TpmRc::RESERVED_BITS));
        }

        Ok(Self { value })
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 112, table 44, TPMA_MEMORY bits
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct TpmaMemory {
    value: u32,
}

impl TpmaMemory {
    pub fn new() -> Self {
        Self { value: 0u32 }
    }

    const SHARED_RAM_MASK: u32 = 1u32 << 0u32;

    pub fn get_shared_ram(&self) -> bool {
        self.value & Self::SHARED_RAM_MASK != 0
    }

    pub fn set_shared_ram(&mut self, value: bool) {
        if value {
            self.value |= Self::SHARED_RAM_MASK;
        } else {
            self.value &= !Self::SHARED_RAM_MASK;
        }
    }

    const SHARED_NV_MASK: u32 = 1u32 << 1u32;

    pub fn get_shared_nv(&self) -> bool {
        self.value & Self::SHARED_NV_MASK != 0
    }

    pub fn set_shared_nv(&mut self, value: bool) {
        if value {
            self.value |= Self::SHARED_NV_MASK;
        } else {
            self.value &= !Self::SHARED_NV_MASK;
        }
    }

    const OBJECT_COPIED_TO_RAM_MASK: u32 = 1u32 << 2u32;

    pub fn get_object_copied_to_ram(&self) -> bool {
        self.value & Self::OBJECT_COPIED_TO_RAM_MASK != 0
    }

    pub fn set_object_copied_to_ram(&mut self, value: bool) {
        if value {
            self.value |= Self::OBJECT_COPIED_TO_RAM_MASK;
        } else {
            self.value &= !Self::OBJECT_COPIED_TO_RAM_MASK;
        }
    }

    const RESERVED_MASK: u32 = 0xffffffffu32 >> (32u32 - 1u32 - 31u32 + 3u32) << 3u32;

    pub const fn marshalled_size() -> u16 {
        mem::size_of::<u32>() as u16
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u32(buf, self.value)
    }

    pub fn unmarshal(buf: &[u8]) -> Result<(&[u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u32(buf)?;
        let result = Self::try_from(value)?;
        Ok((buf, result))
    }
}

impl convert::TryFrom<u32> for TpmaMemory {
    type Error = TpmErr;

    fn try_from(value: u32) -> Result<Self, TpmErr> {

        if value & Self::RESERVED_MASK != 0 {
            return Err(TpmErr::Rc(TpmRc::RESERVED_BITS));
        }

        Ok(Self { value })
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 113, table 45, TPMA_CC bits
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct TpmaCc {
    value: u32,
}

impl TpmaCc {
    pub fn new() -> Self {
        Self { value: 0u32 }
    }

    const COMMAND_INDEX_MASK: u32 = 0xffffffffu32 >> (32u32 - 1u32 - 15u32 + 0u32) << 0u32;
    const COMMAND_INDEX_SHIFT: u32 = 0u32;

    pub fn get_command_index(&self) -> u32 {
        (self.value & Self::COMMAND_INDEX_MASK) >> Self::COMMAND_INDEX_SHIFT
    }

    pub fn set_command_index(&mut self, value: u32) {
        let value = value << Self::COMMAND_INDEX_SHIFT;
        debug_assert!(value & !Self::COMMAND_INDEX_MASK == 0, "invalid bitfield value");
        self.value &= !Self::COMMAND_INDEX_MASK;
        self.value |= value;
    }

    const NV_MASK: u32 = 1u32 << 22u32;

    pub fn get_nv(&self) -> bool {
        self.value & Self::NV_MASK != 0
    }

    pub fn set_nv(&mut self, value: bool) {
        if value {
            self.value |= Self::NV_MASK;
        } else {
            self.value &= !Self::NV_MASK;
        }
    }

    const EXTENSIVE_MASK: u32 = 1u32 << 23u32;

    pub fn get_extensive(&self) -> bool {
        self.value & Self::EXTENSIVE_MASK != 0
    }

    pub fn set_extensive(&mut self, value: bool) {
        if value {
            self.value |= Self::EXTENSIVE_MASK;
        } else {
            self.value &= !Self::EXTENSIVE_MASK;
        }
    }

    const FLUSHED_MASK: u32 = 1u32 << 24u32;

    pub fn get_flushed(&self) -> bool {
        self.value & Self::FLUSHED_MASK != 0
    }

    pub fn set_flushed(&mut self, value: bool) {
        if value {
            self.value |= Self::FLUSHED_MASK;
        } else {
            self.value &= !Self::FLUSHED_MASK;
        }
    }

    const C_HANDLES_MASK: u32 = 0xffffffffu32 >> (32u32 - 1u32 - 27u32 + 25u32) << 25u32;
    const C_HANDLES_SHIFT: u32 = 25u32;

    pub fn get_c_handles(&self) -> u32 {
        (self.value & Self::C_HANDLES_MASK) >> Self::C_HANDLES_SHIFT
    }

    pub fn set_c_handles(&mut self, value: u32) {
        let value = value << Self::C_HANDLES_SHIFT;
        debug_assert!(value & !Self::C_HANDLES_MASK == 0, "invalid bitfield value");
        self.value &= !Self::C_HANDLES_MASK;
        self.value |= value;
    }

    const R_HANDLE_MASK: u32 = 1u32 << 28u32;

    pub fn get_r_handle(&self) -> bool {
        self.value & Self::R_HANDLE_MASK != 0
    }

    pub fn set_r_handle(&mut self, value: bool) {
        if value {
            self.value |= Self::R_HANDLE_MASK;
        } else {
            self.value &= !Self::R_HANDLE_MASK;
        }
    }

    const V_MASK: u32 = 1u32 << 29u32;

    pub fn get_v(&self) -> bool {
        self.value & Self::V_MASK != 0
    }

    pub fn set_v(&mut self, value: bool) {
        if value {
            self.value |= Self::V_MASK;
        } else {
            self.value &= !Self::V_MASK;
        }
    }

    const RES_MASK: u32 = 0xffffffffu32 >> (32u32 - 1u32 - 31u32 + 30u32) << 30u32;
    const RES_SHIFT: u32 = 30u32;

    pub fn get_res(&self) -> u32 {
        (self.value & Self::RES_MASK) >> Self::RES_SHIFT
    }

    pub fn set_res(&mut self, value: u32) {
        let value = value << Self::RES_SHIFT;
        debug_assert!(value & !Self::RES_MASK == 0, "invalid bitfield value");
        self.value &= !Self::RES_MASK;
        self.value |= value;
    }

    const RESERVED_MASK: u32 = 0xffffffffu32 >> (32u32 - 1u32 - 21u32 + 16u32) << 16u32;

    pub const fn marshalled_size() -> u16 {
        mem::size_of::<u32>() as u16
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u32(buf, self.value)
    }

    pub fn unmarshal(buf: &[u8]) -> Result<(&[u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u32(buf)?;
        let result = Self::try_from(value)?;
        Ok((buf, result))
    }
}

impl convert::TryFrom<u32> for TpmaCc {
    type Error = TpmErr;

    fn try_from(value: u32) -> Result<Self, TpmErr> {

        if value & Self::RESERVED_MASK != 0 {
            return Err(TpmErr::Rc(TpmRc::RESERVED_BITS));
        }

        Ok(Self { value })
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 115, table 46, TPMA_MODES bits
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct TpmaModes {
    value: u32,
}

impl TpmaModes {
    pub fn new() -> Self {
        Self { value: 0u32 }
    }

    const FIPS_140_2_MASK: u32 = 1u32 << 0u32;

    pub fn get_fips_140_2(&self) -> bool {
        self.value & Self::FIPS_140_2_MASK != 0
    }

    pub fn set_fips_140_2(&mut self, value: bool) {
        if value {
            self.value |= Self::FIPS_140_2_MASK;
        } else {
            self.value &= !Self::FIPS_140_2_MASK;
        }
    }

    const FIPS_140_3_MASK: u32 = 1u32 << 1u32;

    pub fn get_fips_140_3(&self) -> bool {
        self.value & Self::FIPS_140_3_MASK != 0
    }

    pub fn set_fips_140_3(&mut self, value: bool) {
        if value {
            self.value |= Self::FIPS_140_3_MASK;
        } else {
            self.value &= !Self::FIPS_140_3_MASK;
        }
    }

    const FIPS_140_3_INDICATOR_MASK: u32 = 0xffffffffu32 >> (32u32 - 1u32 - 3u32 + 2u32) << 2u32;
    const FIPS_140_3_INDICATOR_SHIFT: u32 = 2u32;

    pub fn get_fips_140_3_indicator(&self) -> u32 {
        (self.value & Self::FIPS_140_3_INDICATOR_MASK) >> Self::FIPS_140_3_INDICATOR_SHIFT
    }

    pub fn set_fips_140_3_indicator(&mut self, value: u32) {
        let value = value << Self::FIPS_140_3_INDICATOR_SHIFT;
        debug_assert!(value & !Self::FIPS_140_3_INDICATOR_MASK == 0, "invalid bitfield value");
        self.value &= !Self::FIPS_140_3_INDICATOR_MASK;
        self.value |= value;
    }

    const RESERVED_MASK: u32 = 0xffffffffu32 >> (32u32 - 1u32 - 31u32 + 4u32) << 4u32;

    pub const fn marshalled_size() -> u16 {
        mem::size_of::<u32>() as u16
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u32(buf, self.value)
    }

    pub fn unmarshal(buf: &[u8]) -> Result<(&[u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u32(buf)?;
        let result = Self::try_from(value)?;
        Ok((buf, result))
    }
}

impl convert::TryFrom<u32> for TpmaModes {
    type Error = TpmErr;

    fn try_from(value: u32) -> Result<Self, TpmErr> {

        if value & Self::RESERVED_MASK != 0 {
            return Err(TpmErr::Rc(TpmRc::RESERVED_BITS));
        }

        Ok(Self { value })
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 116, table 47, TPMA_X509_KEY_USAGE bits
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct TpmaX509KeyUsage {
    value: u32,
}

impl TpmaX509KeyUsage {
    pub fn new() -> Self {
        Self { value: 0u32 }
    }

    const DECIPHER_ONLY_MASK: u32 = 1u32 << 23u32;

    pub fn get_decipher_only(&self) -> bool {
        self.value & Self::DECIPHER_ONLY_MASK != 0
    }

    pub fn set_decipher_only(&mut self, value: bool) {
        if value {
            self.value |= Self::DECIPHER_ONLY_MASK;
        } else {
            self.value &= !Self::DECIPHER_ONLY_MASK;
        }
    }

    const ENCIPHER_ONLY_MASK: u32 = 1u32 << 24u32;

    pub fn get_encipher_only(&self) -> bool {
        self.value & Self::ENCIPHER_ONLY_MASK != 0
    }

    pub fn set_encipher_only(&mut self, value: bool) {
        if value {
            self.value |= Self::ENCIPHER_ONLY_MASK;
        } else {
            self.value &= !Self::ENCIPHER_ONLY_MASK;
        }
    }

    const CRLS_IGN_MASK: u32 = 1u32 << 25u32;

    pub fn get_crls_ign(&self) -> bool {
        self.value & Self::CRLS_IGN_MASK != 0
    }

    pub fn set_crls_ign(&mut self, value: bool) {
        if value {
            self.value |= Self::CRLS_IGN_MASK;
        } else {
            self.value &= !Self::CRLS_IGN_MASK;
        }
    }

    const CERT_SIGN_MASK: u32 = 1u32 << 26u32;

    pub fn get_cert_sign(&self) -> bool {
        self.value & Self::CERT_SIGN_MASK != 0
    }

    pub fn set_cert_sign(&mut self, value: bool) {
        if value {
            self.value |= Self::CERT_SIGN_MASK;
        } else {
            self.value &= !Self::CERT_SIGN_MASK;
        }
    }

    const AGREEMENT_MASK: u32 = 1u32 << 27u32;

    pub fn get_agreement(&self) -> bool {
        self.value & Self::AGREEMENT_MASK != 0
    }

    pub fn set_agreement(&mut self, value: bool) {
        if value {
            self.value |= Self::AGREEMENT_MASK;
        } else {
            self.value &= !Self::AGREEMENT_MASK;
        }
    }

    const DATA_ENCIPHERMENT_MASK: u32 = 1u32 << 28u32;

    pub fn get_data_encipherment(&self) -> bool {
        self.value & Self::DATA_ENCIPHERMENT_MASK != 0
    }

    pub fn set_data_encipherment(&mut self, value: bool) {
        if value {
            self.value |= Self::DATA_ENCIPHERMENT_MASK;
        } else {
            self.value &= !Self::DATA_ENCIPHERMENT_MASK;
        }
    }

    const ENCIPHERMENT_MASK: u32 = 1u32 << 29u32;

    pub fn get_encipherment(&self) -> bool {
        self.value & Self::ENCIPHERMENT_MASK != 0
    }

    pub fn set_encipherment(&mut self, value: bool) {
        if value {
            self.value |= Self::ENCIPHERMENT_MASK;
        } else {
            self.value &= !Self::ENCIPHERMENT_MASK;
        }
    }

    const NONREPUDIATION_CONTENT_COMMITMENT_MASK: u32 = 1u32 << 30u32;

    pub fn get_nonrepudiation_content_commitment(&self) -> bool {
        self.value & Self::NONREPUDIATION_CONTENT_COMMITMENT_MASK != 0
    }

    pub fn set_nonrepudiation_content_commitment(&mut self, value: bool) {
        if value {
            self.value |= Self::NONREPUDIATION_CONTENT_COMMITMENT_MASK;
        } else {
            self.value &= !Self::NONREPUDIATION_CONTENT_COMMITMENT_MASK;
        }
    }

    const DIGITAL_SIGNATURE_MASK: u32 = 1u32 << 31u32;

    pub fn get_digital_signature(&self) -> bool {
        self.value & Self::DIGITAL_SIGNATURE_MASK != 0
    }

    pub fn set_digital_signature(&mut self, value: bool) {
        if value {
            self.value |= Self::DIGITAL_SIGNATURE_MASK;
        } else {
            self.value &= !Self::DIGITAL_SIGNATURE_MASK;
        }
    }

    const RESERVED_MASK: u32 = 0xffffffffu32 >> (32u32 - 1u32 - 22u32 + 0u32) << 0u32;

    pub const fn marshalled_size() -> u16 {
        mem::size_of::<u32>() as u16
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u32(buf, self.value)
    }

    pub fn unmarshal(buf: &[u8]) -> Result<(&[u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u32(buf)?;
        let result = Self::try_from(value)?;
        Ok((buf, result))
    }
}

impl convert::TryFrom<u32> for TpmaX509KeyUsage {
    type Error = TpmErr;

    fn try_from(value: u32) -> Result<Self, TpmErr> {

        if value & Self::RESERVED_MASK != 0 {
            return Err(TpmErr::Rc(TpmRc::RESERVED_BITS));
        }

        Ok(Self { value })
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 117, table 48, TPMA_ACT bits
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct TpmaAct {
    value: u32,
}

impl TpmaAct {
    pub fn new() -> Self {
        Self { value: 0u32 }
    }

    const SIGNALED_MASK: u32 = 1u32 << 0u32;

    pub fn get_signaled(&self) -> bool {
        self.value & Self::SIGNALED_MASK != 0
    }

    pub fn set_signaled(&mut self, value: bool) {
        if value {
            self.value |= Self::SIGNALED_MASK;
        } else {
            self.value &= !Self::SIGNALED_MASK;
        }
    }

    const PRESERVE_SIGNALED_MASK: u32 = 1u32 << 1u32;

    pub fn get_preserve_signaled(&self) -> bool {
        self.value & Self::PRESERVE_SIGNALED_MASK != 0
    }

    pub fn set_preserve_signaled(&mut self, value: bool) {
        if value {
            self.value |= Self::PRESERVE_SIGNALED_MASK;
        } else {
            self.value &= !Self::PRESERVE_SIGNALED_MASK;
        }
    }

    const RESERVED_MASK: u32 = 0xffffffffu32 >> (32u32 - 1u32 - 31u32 + 2u32) << 2u32;

    pub const fn marshalled_size() -> u16 {
        mem::size_of::<u32>() as u16
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u32(buf, self.value)
    }

    pub fn unmarshal(buf: &[u8]) -> Result<(&[u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u32(buf)?;
        let result = Self::try_from(value)?;
        Ok((buf, result))
    }
}

impl convert::TryFrom<u32> for TpmaAct {
    type Error = TpmErr;

    fn try_from(value: u32) -> Result<Self, TpmErr> {

        if value & Self::RESERVED_MASK != 0 {
            return Err(TpmErr::Rc(TpmRc::RESERVED_BITS));
        }

        Ok(Self { value })
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 118, table 49, TPMI_YES_NO type
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct TpmiYesNo {
    pub value: u8,
}

impl TpmiYesNo {
    pub const fn marshalled_size() -> u16 {
        mem::size_of::<u8>() as u16
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u8(buf, self.value)
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u8(buf)?;

        if value == 0u8 {
            return Ok((buf, Self{value}))
        }

        if value == 1u8 {
            return Ok((buf, Self{value}))
        }

        return Err(TpmErr::Rc(TpmRc::VALUE));
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 118, table 50, TPMI_DH_OBJECT type (without conditional values)
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct TpmiDhObject {
    pub value: u32,
}

impl TpmiDhObject {
    pub const fn marshalled_size() -> u16 {
        mem::size_of::<u32>() as u16
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u32(buf, self.value)
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u32(buf)?;

        if value >= TpmHc::TRANSIENT_FIRST {
            let v0 = match TpmHc::transient_last(limits) {
                Ok(v) => v,
                Err(_) => {
                    debug_assert!(false, "Unexpected runtime constant evaluation failure");
                    return Err(TpmErr::InternalErr);
                },
            };
            if value <= v0 {
                return Ok((buf, Self{value}))
            }
        }

        if value >= TpmHc::PERSISTENT_FIRST {
            if value <= TpmHc::PERSISTENT_LAST {
                return Ok((buf, Self{value}))
            }
        }

        return Err(TpmErr::Rc(TpmRc::VALUE));
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 118, table 50, TPMI_DH_OBJECT type (with conditional values)
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct TpmiDhObjectWCV {
    pub value: u32,
}

impl TpmiDhObjectWCV {
    pub const fn marshalled_size() -> u16 {
        mem::size_of::<u32>() as u16
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u32(buf, self.value)
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u32(buf)?;

        if value >= TpmHc::TRANSIENT_FIRST {
            let v0 = match TpmHc::transient_last(limits) {
                Ok(v) => v,
                Err(_) => {
                    debug_assert!(false, "Unexpected runtime constant evaluation failure");
                    return Err(TpmErr::InternalErr);
                },
            };
            if value <= v0 {
                return Ok((buf, Self{value}))
            }
        }

        if value >= TpmHc::PERSISTENT_FIRST {
            if value <= TpmHc::PERSISTENT_LAST {
                return Ok((buf, Self{value}))
            }
        }

        if value == TpmRh::Null as u32 {
            return Ok((buf, Self{value}))
        }

        return Err(TpmErr::Rc(TpmRc::VALUE));
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 119, table 51, TPMI_DH_PARENT type
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct TpmiDhParent {
    pub value: u32,
}

impl TpmiDhParent {
    pub const fn marshalled_size() -> u16 {
        mem::size_of::<u32>() as u16
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u32(buf, self.value)
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u32(buf)?;

        if value >= TpmHc::TRANSIENT_FIRST {
            let v0 = match TpmHc::transient_last(limits) {
                Ok(v) => v,
                Err(_) => {
                    debug_assert!(false, "Unexpected runtime constant evaluation failure");
                    return Err(TpmErr::InternalErr);
                },
            };
            if value <= v0 {
                return Ok((buf, Self{value}))
            }
        }

        if value >= TpmHc::PERSISTENT_FIRST {
            if value <= TpmHc::PERSISTENT_LAST {
                return Ok((buf, Self{value}))
            }
        }

        if value == TpmRh::Owner as u32 {
            return Ok((buf, Self{value}))
        }

        if value == TpmRh::Platform as u32 {
            return Ok((buf, Self{value}))
        }

        if value == TpmRh::Endorsement as u32 {
            return Ok((buf, Self{value}))
        }

        if value == TpmRh::Null as u32 {
            return Ok((buf, Self{value}))
        }

        if value == TpmRh::FwOwner as u32 {
            return Ok((buf, Self{value}))
        }

        if value == TpmRh::FwPlatform as u32 {
            return Ok((buf, Self{value}))
        }

        if value == TpmRh::FwEndorsement as u32 {
            return Ok((buf, Self{value}))
        }

        if value == TpmRh::FwNull as u32 {
            return Ok((buf, Self{value}))
        }

        if value >= TpmHc::SVN_OWNER_FIRST {
            if value <= TpmHc::SVN_OWNER_LAST {
                return Ok((buf, Self{value}))
            }
        }

        if value >= TpmHc::SVN_PLATFORM_FIRST {
            if value <= TpmHc::SVN_PLATFORM_LAST {
                return Ok((buf, Self{value}))
            }
        }

        if value >= TpmHc::SVN_ENDORSEMENT_FIRST {
            if value <= TpmHc::SVN_ENDORSEMENT_LAST {
                return Ok((buf, Self{value}))
            }
        }

        if value >= TpmHc::SVN_NULL_FIRST {
            if value <= TpmHc::SVN_NULL_LAST {
                return Ok((buf, Self{value}))
            }
        }

        return Err(TpmErr::Rc(TpmRc::VALUE));
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 119, table 52, TPMI_DH_PERSISTENT type
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct TpmiDhPersistent {
    pub value: u32,
}

impl TpmiDhPersistent {
    pub const fn marshalled_size() -> u16 {
        mem::size_of::<u32>() as u16
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u32(buf, self.value)
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u32(buf)?;

        if value >= TpmHc::PERSISTENT_FIRST {
            if value <= TpmHc::PERSISTENT_LAST {
                return Ok((buf, Self{value}))
            }
        }

        return Err(TpmErr::Rc(TpmRc::VALUE));
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 119, table 53, TPMI_DH_ENTITY type (without conditional values)
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct TpmiDhEntity {
    pub value: u32,
}

impl TpmiDhEntity {
    pub const fn marshalled_size() -> u16 {
        mem::size_of::<u32>() as u16
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u32(buf, self.value)
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u32(buf)?;

        if value == TpmRh::Owner as u32 {
            return Ok((buf, Self{value}))
        }

        if value == TpmRh::Endorsement as u32 {
            return Ok((buf, Self{value}))
        }

        if value == TpmRh::Platform as u32 {
            return Ok((buf, Self{value}))
        }

        if value == TpmRh::Lockout as u32 {
            return Ok((buf, Self{value}))
        }

        if value >= TpmHc::TRANSIENT_FIRST {
            let v0 = match TpmHc::transient_last(limits) {
                Ok(v) => v,
                Err(_) => {
                    debug_assert!(false, "Unexpected runtime constant evaluation failure");
                    return Err(TpmErr::InternalErr);
                },
            };
            if value <= v0 {
                return Ok((buf, Self{value}))
            }
        }

        if value >= TpmHc::PERSISTENT_FIRST {
            if value <= TpmHc::PERSISTENT_LAST {
                return Ok((buf, Self{value}))
            }
        }

        if value >= TpmHc::NV_INDEX_FIRST {
            if value <= TpmHc::NV_INDEX_LAST {
                return Ok((buf, Self{value}))
            }
        }

        if value >= TpmHc::PCR_FIRST {
            let v0 = match TpmHc::pcr_last(limits) {
                Ok(v) => v,
                Err(_) => {
                    debug_assert!(false, "Unexpected runtime constant evaluation failure");
                    return Err(TpmErr::InternalErr);
                },
            };
            if value <= v0 {
                return Ok((buf, Self{value}))
            }
        }

        if value >= TpmRh::Auth00 as u32 {
            if value <= TpmRh::AuthFf as u32 {
                return Ok((buf, Self{value}))
            }
        }

        return Err(TpmErr::Rc(TpmRc::VALUE));
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 119, table 53, TPMI_DH_ENTITY type (with conditional values)
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct TpmiDhEntityWCV {
    pub value: u32,
}

impl TpmiDhEntityWCV {
    pub const fn marshalled_size() -> u16 {
        mem::size_of::<u32>() as u16
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u32(buf, self.value)
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u32(buf)?;

        if value == TpmRh::Owner as u32 {
            return Ok((buf, Self{value}))
        }

        if value == TpmRh::Endorsement as u32 {
            return Ok((buf, Self{value}))
        }

        if value == TpmRh::Platform as u32 {
            return Ok((buf, Self{value}))
        }

        if value == TpmRh::Lockout as u32 {
            return Ok((buf, Self{value}))
        }

        if value >= TpmHc::TRANSIENT_FIRST {
            let v0 = match TpmHc::transient_last(limits) {
                Ok(v) => v,
                Err(_) => {
                    debug_assert!(false, "Unexpected runtime constant evaluation failure");
                    return Err(TpmErr::InternalErr);
                },
            };
            if value <= v0 {
                return Ok((buf, Self{value}))
            }
        }

        if value >= TpmHc::PERSISTENT_FIRST {
            if value <= TpmHc::PERSISTENT_LAST {
                return Ok((buf, Self{value}))
            }
        }

        if value >= TpmHc::NV_INDEX_FIRST {
            if value <= TpmHc::NV_INDEX_LAST {
                return Ok((buf, Self{value}))
            }
        }

        if value >= TpmHc::PCR_FIRST {
            let v0 = match TpmHc::pcr_last(limits) {
                Ok(v) => v,
                Err(_) => {
                    debug_assert!(false, "Unexpected runtime constant evaluation failure");
                    return Err(TpmErr::InternalErr);
                },
            };
            if value <= v0 {
                return Ok((buf, Self{value}))
            }
        }

        if value >= TpmRh::Auth00 as u32 {
            if value <= TpmRh::AuthFf as u32 {
                return Ok((buf, Self{value}))
            }
        }

        if value == TpmRh::Null as u32 {
            return Ok((buf, Self{value}))
        }

        return Err(TpmErr::Rc(TpmRc::VALUE));
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 120, table 54, TPMI_DH_PCR type (without conditional values)
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct TpmiDhPcr {
    pub value: u32,
}

impl TpmiDhPcr {
    pub const fn marshalled_size() -> u16 {
        mem::size_of::<u32>() as u16
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u32(buf, self.value)
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u32(buf)?;

        if value >= TpmHc::PCR_FIRST {
            let v0 = match TpmHc::pcr_last(limits) {
                Ok(v) => v,
                Err(_) => {
                    debug_assert!(false, "Unexpected runtime constant evaluation failure");
                    return Err(TpmErr::InternalErr);
                },
            };
            if value <= v0 {
                return Ok((buf, Self{value}))
            }
        }

        return Err(TpmErr::Rc(TpmRc::VALUE));
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 120, table 54, TPMI_DH_PCR type (with conditional values)
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct TpmiDhPcrWCV {
    pub value: u32,
}

impl TpmiDhPcrWCV {
    pub const fn marshalled_size() -> u16 {
        mem::size_of::<u32>() as u16
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u32(buf, self.value)
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u32(buf)?;

        if value >= TpmHc::PCR_FIRST {
            let v0 = match TpmHc::pcr_last(limits) {
                Ok(v) => v,
                Err(_) => {
                    debug_assert!(false, "Unexpected runtime constant evaluation failure");
                    return Err(TpmErr::InternalErr);
                },
            };
            if value <= v0 {
                return Ok((buf, Self{value}))
            }
        }

        if value == TpmRh::Null as u32 {
            return Ok((buf, Self{value}))
        }

        return Err(TpmErr::Rc(TpmRc::VALUE));
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 120, table 55, TPMI_SH_AUTH_SESSION type (without conditional values)
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct TpmiShAuthSession {
    pub value: u32,
}

impl TpmiShAuthSession {
    pub const fn marshalled_size() -> u16 {
        mem::size_of::<u32>() as u16
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u32(buf, self.value)
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u32(buf)?;

        if value >= TpmHc::HMAC_SESSION_FIRST {
            let v0 = match TpmHc::hmac_session_last(limits) {
                Ok(v) => v,
                Err(_) => {
                    debug_assert!(false, "Unexpected runtime constant evaluation failure");
                    return Err(TpmErr::InternalErr);
                },
            };
            if value <= v0 {
                return Ok((buf, Self{value}))
            }
        }

        if value >= TpmHc::POLICY_SESSION_FIRST {
            let v0 = match TpmHc::policy_session_last(limits) {
                Ok(v) => v,
                Err(_) => {
                    debug_assert!(false, "Unexpected runtime constant evaluation failure");
                    return Err(TpmErr::InternalErr);
                },
            };
            if value <= v0 {
                return Ok((buf, Self{value}))
            }
        }

        return Err(TpmErr::Rc(TpmRc::VALUE));
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 120, table 55, TPMI_SH_AUTH_SESSION type (with conditional values)
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct TpmiShAuthSessionWCV {
    pub value: u32,
}

impl TpmiShAuthSessionWCV {
    pub const fn marshalled_size() -> u16 {
        mem::size_of::<u32>() as u16
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u32(buf, self.value)
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u32(buf)?;

        if value >= TpmHc::HMAC_SESSION_FIRST {
            let v0 = match TpmHc::hmac_session_last(limits) {
                Ok(v) => v,
                Err(_) => {
                    debug_assert!(false, "Unexpected runtime constant evaluation failure");
                    return Err(TpmErr::InternalErr);
                },
            };
            if value <= v0 {
                return Ok((buf, Self{value}))
            }
        }

        if value >= TpmHc::POLICY_SESSION_FIRST {
            let v0 = match TpmHc::policy_session_last(limits) {
                Ok(v) => v,
                Err(_) => {
                    debug_assert!(false, "Unexpected runtime constant evaluation failure");
                    return Err(TpmErr::InternalErr);
                },
            };
            if value <= v0 {
                return Ok((buf, Self{value}))
            }
        }

        if value == TpmRh::RsPw as u32 {
            return Ok((buf, Self{value}))
        }

        return Err(TpmErr::Rc(TpmRc::VALUE));
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 121, table 56, TPMI_SH_HMAC type
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct TpmiShHmac {
    pub value: u32,
}

impl TpmiShHmac {
    pub const fn marshalled_size() -> u16 {
        mem::size_of::<u32>() as u16
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u32(buf, self.value)
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u32(buf)?;

        if value >= TpmHc::HMAC_SESSION_FIRST {
            let v0 = match TpmHc::hmac_session_last(limits) {
                Ok(v) => v,
                Err(_) => {
                    debug_assert!(false, "Unexpected runtime constant evaluation failure");
                    return Err(TpmErr::InternalErr);
                },
            };
            if value <= v0 {
                return Ok((buf, Self{value}))
            }
        }

        return Err(TpmErr::Rc(TpmRc::VALUE));
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 121, table 57, TPMI_SH_POLICY type
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct TpmiShPolicy {
    pub value: u32,
}

impl TpmiShPolicy {
    pub const fn marshalled_size() -> u16 {
        mem::size_of::<u32>() as u16
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u32(buf, self.value)
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u32(buf)?;

        if value >= TpmHc::POLICY_SESSION_FIRST {
            let v0 = match TpmHc::policy_session_last(limits) {
                Ok(v) => v,
                Err(_) => {
                    debug_assert!(false, "Unexpected runtime constant evaluation failure");
                    return Err(TpmErr::InternalErr);
                },
            };
            if value <= v0 {
                return Ok((buf, Self{value}))
            }
        }

        return Err(TpmErr::Rc(TpmRc::VALUE));
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 121, table 58, TPMI_DH_CONTEXT type
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct TpmiDhContext {
    pub value: u32,
}

impl TpmiDhContext {
    pub const fn marshalled_size() -> u16 {
        mem::size_of::<u32>() as u16
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u32(buf, self.value)
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u32(buf)?;

        if value >= TpmHc::HMAC_SESSION_FIRST {
            let v0 = match TpmHc::hmac_session_last(limits) {
                Ok(v) => v,
                Err(_) => {
                    debug_assert!(false, "Unexpected runtime constant evaluation failure");
                    return Err(TpmErr::InternalErr);
                },
            };
            if value <= v0 {
                return Ok((buf, Self{value}))
            }
        }

        if value >= TpmHc::POLICY_SESSION_FIRST {
            let v0 = match TpmHc::policy_session_last(limits) {
                Ok(v) => v,
                Err(_) => {
                    debug_assert!(false, "Unexpected runtime constant evaluation failure");
                    return Err(TpmErr::InternalErr);
                },
            };
            if value <= v0 {
                return Ok((buf, Self{value}))
            }
        }

        if value >= TpmHc::TRANSIENT_FIRST {
            let v0 = match TpmHc::transient_last(limits) {
                Ok(v) => v,
                Err(_) => {
                    debug_assert!(false, "Unexpected runtime constant evaluation failure");
                    return Err(TpmErr::InternalErr);
                },
            };
            if value <= v0 {
                return Ok((buf, Self{value}))
            }
        }

        return Err(TpmErr::Rc(TpmRc::VALUE));
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 121, table 59, TPMI_DH_SAVED type
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct TpmiDhSaved {
    pub value: u32,
}

impl TpmiDhSaved {
    pub const fn marshalled_size() -> u16 {
        mem::size_of::<u32>() as u16
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u32(buf, self.value)
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u32(buf)?;

        if value >= TpmHc::HMAC_SESSION_FIRST {
            let v0 = match TpmHc::hmac_session_last(limits) {
                Ok(v) => v,
                Err(_) => {
                    debug_assert!(false, "Unexpected runtime constant evaluation failure");
                    return Err(TpmErr::InternalErr);
                },
            };
            if value <= v0 {
                return Ok((buf, Self{value}))
            }
        }

        if value >= TpmHc::POLICY_SESSION_FIRST {
            let v0 = match TpmHc::policy_session_last(limits) {
                Ok(v) => v,
                Err(_) => {
                    debug_assert!(false, "Unexpected runtime constant evaluation failure");
                    return Err(TpmErr::InternalErr);
                },
            };
            if value <= v0 {
                return Ok((buf, Self{value}))
            }
        }

        if value == 0x80000000u32 {
            return Ok((buf, Self{value}))
        }

        if value == 0x80000001u32 {
            return Ok((buf, Self{value}))
        }

        if value == 0x80000002u32 {
            return Ok((buf, Self{value}))
        }

        return Err(TpmErr::Rc(TpmRc::VALUE));
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 122, table 60, TPMI_RH_HIERARCHY type
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct TpmiRhHierarchy {
    pub value: u32,
}

impl TpmiRhHierarchy {
    pub const fn marshalled_size() -> u16 {
        mem::size_of::<u32>() as u16
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u32(buf, self.value)
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u32(buf)?;

        if value == TpmRh::Owner as u32 {
            return Ok((buf, Self{value}))
        }

        if value == TpmRh::Platform as u32 {
            return Ok((buf, Self{value}))
        }

        if value == TpmRh::Endorsement as u32 {
            return Ok((buf, Self{value}))
        }

        if value == TpmRh::Null as u32 {
            return Ok((buf, Self{value}))
        }

        if value == TpmRh::FwOwner as u32 {
            return Ok((buf, Self{value}))
        }

        if value == TpmRh::FwPlatform as u32 {
            return Ok((buf, Self{value}))
        }

        if value == TpmRh::FwEndorsement as u32 {
            return Ok((buf, Self{value}))
        }

        if value == TpmRh::FwNull as u32 {
            return Ok((buf, Self{value}))
        }

        if value >= TpmHc::SVN_OWNER_FIRST {
            if value <= TpmHc::SVN_OWNER_LAST {
                return Ok((buf, Self{value}))
            }
        }

        if value >= TpmHc::SVN_PLATFORM_FIRST {
            if value <= TpmHc::SVN_PLATFORM_LAST {
                return Ok((buf, Self{value}))
            }
        }

        if value >= TpmHc::SVN_ENDORSEMENT_FIRST {
            if value <= TpmHc::SVN_ENDORSEMENT_LAST {
                return Ok((buf, Self{value}))
            }
        }

        if value >= TpmHc::SVN_NULL_FIRST {
            if value <= TpmHc::SVN_NULL_LAST {
                return Ok((buf, Self{value}))
            }
        }

        return Err(TpmErr::Rc(TpmRc::VALUE));
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 122, table 61, TPMI_RH_ENABLES type (without conditional values)
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u32)]
pub enum TpmiRhEnables {
    Owner = TpmRh::Owner as u32,
    Platform = TpmRh::Platform as u32,
    Endorsement = TpmRh::Endorsement as u32,
    PlatformNv = TpmRh::PlatformNv as u32,
}

impl TpmiRhEnables {
    pub const fn marshalled_size() -> u16 {
        mem::size_of::<u32>() as u16
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u32(buf, *self as u32)
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u32(buf)?;
        let result = Self::try_from(value)?;
        Ok((buf, result))
    }
}

impl convert::TryFrom<u32> for TpmiRhEnables {
    type Error = TpmErr;

    fn try_from(value: u32) -> Result<Self, TpmErr> {
        let result = match value {
            value if value == Self::Owner as u32 => Self::Owner,
            value if value == Self::Platform as u32 => Self::Platform,
            value if value == Self::Endorsement as u32 => Self::Endorsement,
            value if value == Self::PlatformNv as u32 => Self::PlatformNv,
            _ => {
                return Err(TpmErr::Rc(TpmRc::VALUE));
            },
        };

        Ok(result)
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 122, table 61, TPMI_RH_ENABLES type (with conditional values)
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u32)]
pub enum TpmiRhEnablesWCV {
    Owner = TpmRh::Owner as u32,
    Platform = TpmRh::Platform as u32,
    Endorsement = TpmRh::Endorsement as u32,
    PlatformNv = TpmRh::PlatformNv as u32,
    Null = TpmRh::Null as u32,
}

impl TpmiRhEnablesWCV {
    pub const fn marshalled_size() -> u16 {
        mem::size_of::<u32>() as u16
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u32(buf, *self as u32)
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u32(buf)?;
        let result = Self::try_from(value)?;
        Ok((buf, result))
    }
}

impl convert::TryFrom<u32> for TpmiRhEnablesWCV {
    type Error = TpmErr;

    fn try_from(value: u32) -> Result<Self, TpmErr> {
        let result = match value {
            value if value == Self::Owner as u32 => Self::Owner,
            value if value == Self::Platform as u32 => Self::Platform,
            value if value == Self::Endorsement as u32 => Self::Endorsement,
            value if value == Self::PlatformNv as u32 => Self::PlatformNv,
            value if value == Self::Null as u32 => Self::Null,
            _ => {
                return Err(TpmErr::Rc(TpmRc::VALUE));
            },
        };

        Ok(result)
    }
}

impl convert::From<TpmiRhEnables> for TpmiRhEnablesWCV {
    fn from(value: TpmiRhEnables) -> Self {
        match value {
            TpmiRhEnables::Owner => Self::Owner,
            TpmiRhEnables::Platform => Self::Platform,
            TpmiRhEnables::Endorsement => Self::Endorsement,
            TpmiRhEnables::PlatformNv => Self::PlatformNv,
        }
    }
}

impl convert::TryFrom<TpmiRhEnablesWCV> for TpmiRhEnables {
    type Error = TpmErr;

    fn try_from(value: TpmiRhEnablesWCV) -> Result<Self, TpmErr> {
        let result = match value {
            TpmiRhEnablesWCV::Owner => Self::Owner,
            TpmiRhEnablesWCV::Platform => Self::Platform,
            TpmiRhEnablesWCV::Endorsement => Self::Endorsement,
            TpmiRhEnablesWCV::PlatformNv => Self::PlatformNv,
            TpmiRhEnablesWCV::Null => {
                return Err(TpmErr::Rc(TpmRc::VALUE));
            },
        };
        Ok(result)
    }
}

impl cmp::PartialEq<TpmiRhEnables> for TpmiRhEnablesWCV {
    fn eq(&self, other: &TpmiRhEnables) -> bool {
        *self as u32 == *other as u32
    }
}

impl cmp::PartialEq<TpmiRhEnablesWCV> for TpmiRhEnables {
    fn eq(&self, other: &TpmiRhEnablesWCV) -> bool {
        other.eq(self)
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 123, table 62, TPMI_RH_HIERARCHY_AUTH type (without conditional values)
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u32)]
pub enum TpmiRhHierarchyAuth {
    Owner = TpmRh::Owner as u32,
    Platform = TpmRh::Platform as u32,
    Endorsement = TpmRh::Endorsement as u32,
    Lockout = TpmRh::Lockout as u32,
}

impl TpmiRhHierarchyAuth {
    pub const fn marshalled_size() -> u16 {
        mem::size_of::<u32>() as u16
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u32(buf, *self as u32)
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u32(buf)?;
        let result = Self::try_from(value)?;
        Ok((buf, result))
    }
}

impl convert::TryFrom<u32> for TpmiRhHierarchyAuth {
    type Error = TpmErr;

    fn try_from(value: u32) -> Result<Self, TpmErr> {
        let result = match value {
            value if value == Self::Owner as u32 => Self::Owner,
            value if value == Self::Platform as u32 => Self::Platform,
            value if value == Self::Endorsement as u32 => Self::Endorsement,
            value if value == Self::Lockout as u32 => Self::Lockout,
            _ => {
                return Err(TpmErr::Rc(TpmRc::VALUE));
            },
        };

        Ok(result)
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 123, table 62, TPMI_RH_HIERARCHY_AUTH type (with conditional values)
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u32)]
pub enum TpmiRhHierarchyAuthWCV {
    Owner = TpmRh::Owner as u32,
    Platform = TpmRh::Platform as u32,
    Endorsement = TpmRh::Endorsement as u32,
    Lockout = TpmRh::Lockout as u32,
    Null = TpmRh::Null as u32,
}

impl TpmiRhHierarchyAuthWCV {
    pub const fn marshalled_size() -> u16 {
        mem::size_of::<u32>() as u16
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u32(buf, *self as u32)
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u32(buf)?;
        let result = Self::try_from(value)?;
        Ok((buf, result))
    }
}

impl convert::TryFrom<u32> for TpmiRhHierarchyAuthWCV {
    type Error = TpmErr;

    fn try_from(value: u32) -> Result<Self, TpmErr> {
        let result = match value {
            value if value == Self::Owner as u32 => Self::Owner,
            value if value == Self::Platform as u32 => Self::Platform,
            value if value == Self::Endorsement as u32 => Self::Endorsement,
            value if value == Self::Lockout as u32 => Self::Lockout,
            value if value == Self::Null as u32 => Self::Null,
            _ => {
                return Err(TpmErr::Rc(TpmRc::VALUE));
            },
        };

        Ok(result)
    }
}

impl convert::From<TpmiRhHierarchyAuth> for TpmiRhHierarchyAuthWCV {
    fn from(value: TpmiRhHierarchyAuth) -> Self {
        match value {
            TpmiRhHierarchyAuth::Owner => Self::Owner,
            TpmiRhHierarchyAuth::Platform => Self::Platform,
            TpmiRhHierarchyAuth::Endorsement => Self::Endorsement,
            TpmiRhHierarchyAuth::Lockout => Self::Lockout,
        }
    }
}

impl convert::TryFrom<TpmiRhHierarchyAuthWCV> for TpmiRhHierarchyAuth {
    type Error = TpmErr;

    fn try_from(value: TpmiRhHierarchyAuthWCV) -> Result<Self, TpmErr> {
        let result = match value {
            TpmiRhHierarchyAuthWCV::Owner => Self::Owner,
            TpmiRhHierarchyAuthWCV::Platform => Self::Platform,
            TpmiRhHierarchyAuthWCV::Endorsement => Self::Endorsement,
            TpmiRhHierarchyAuthWCV::Lockout => Self::Lockout,
            TpmiRhHierarchyAuthWCV::Null => {
                return Err(TpmErr::Rc(TpmRc::VALUE));
            },
        };
        Ok(result)
    }
}

impl cmp::PartialEq<TpmiRhHierarchyAuth> for TpmiRhHierarchyAuthWCV {
    fn eq(&self, other: &TpmiRhHierarchyAuth) -> bool {
        *self as u32 == *other as u32
    }
}

impl cmp::PartialEq<TpmiRhHierarchyAuthWCV> for TpmiRhHierarchyAuth {
    fn eq(&self, other: &TpmiRhHierarchyAuthWCV) -> bool {
        other.eq(self)
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 123, table 63, TPMI_RH_HIERARCHY_POLICY type
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct TpmiRhHierarchyPolicy {
    pub value: u32,
}

impl TpmiRhHierarchyPolicy {
    pub const fn marshalled_size() -> u16 {
        mem::size_of::<u32>() as u16
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u32(buf, self.value)
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u32(buf)?;

        if value == TpmRh::Owner as u32 {
            return Ok((buf, Self{value}))
        }

        if value == TpmRh::Platform as u32 {
            return Ok((buf, Self{value}))
        }

        if value == TpmRh::Endorsement as u32 {
            return Ok((buf, Self{value}))
        }

        if value == TpmRh::Lockout as u32 {
            return Ok((buf, Self{value}))
        }

        if value >= TpmRh::Act0 as u32 {
            if value <= TpmRh::ActF as u32 {
                return Ok((buf, Self{value}))
            }
        }

        return Err(TpmErr::Rc(TpmRc::VALUE));
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 123, table 64, TPMI_RH_BASE_HIERARCHY type
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u32)]
pub enum TpmiRhBaseHierarchy {
    Owner = TpmRh::Owner as u32,
    Platform = TpmRh::Platform as u32,
    Endorsement = TpmRh::Endorsement as u32,
}

impl TpmiRhBaseHierarchy {
    pub const fn marshalled_size() -> u16 {
        mem::size_of::<u32>() as u16
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u32(buf, *self as u32)
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u32(buf)?;
        let result = Self::try_from(value)?;
        Ok((buf, result))
    }
}

impl convert::TryFrom<u32> for TpmiRhBaseHierarchy {
    type Error = TpmErr;

    fn try_from(value: u32) -> Result<Self, TpmErr> {
        let result = match value {
            value if value == Self::Owner as u32 => Self::Owner,
            value if value == Self::Platform as u32 => Self::Platform,
            value if value == Self::Endorsement as u32 => Self::Endorsement,
            _ => {
                return Err(TpmErr::Rc(TpmRc::VALUE));
            },
        };

        Ok(result)
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 124, table 65, TPMI_RH_PLATFORM type
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u32)]
pub enum TpmiRhPlatform {
    Platform = TpmRh::Platform as u32,
}

impl TpmiRhPlatform {
    pub const fn marshalled_size() -> u16 {
        mem::size_of::<u32>() as u16
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u32(buf, *self as u32)
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u32(buf)?;
        let result = Self::try_from(value)?;
        Ok((buf, result))
    }
}

impl convert::TryFrom<u32> for TpmiRhPlatform {
    type Error = TpmErr;

    fn try_from(value: u32) -> Result<Self, TpmErr> {
        let result = match value {
            value if value == Self::Platform as u32 => Self::Platform,
            _ => {
                return Err(TpmErr::Rc(TpmRc::VALUE));
            },
        };

        Ok(result)
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 124, table 66, TPMI_RH_OWNER type (without conditional values)
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u32)]
pub enum TpmiRhOwner {
    Owner = TpmRh::Owner as u32,
}

impl TpmiRhOwner {
    pub const fn marshalled_size() -> u16 {
        mem::size_of::<u32>() as u16
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u32(buf, *self as u32)
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u32(buf)?;
        let result = Self::try_from(value)?;
        Ok((buf, result))
    }
}

impl convert::TryFrom<u32> for TpmiRhOwner {
    type Error = TpmErr;

    fn try_from(value: u32) -> Result<Self, TpmErr> {
        let result = match value {
            value if value == Self::Owner as u32 => Self::Owner,
            _ => {
                return Err(TpmErr::Rc(TpmRc::VALUE));
            },
        };

        Ok(result)
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 124, table 66, TPMI_RH_OWNER type (with conditional values)
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u32)]
pub enum TpmiRhOwnerWCV {
    Owner = TpmRh::Owner as u32,
    Null = TpmRh::Null as u32,
}

impl TpmiRhOwnerWCV {
    pub const fn marshalled_size() -> u16 {
        mem::size_of::<u32>() as u16
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u32(buf, *self as u32)
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u32(buf)?;
        let result = Self::try_from(value)?;
        Ok((buf, result))
    }
}

impl convert::TryFrom<u32> for TpmiRhOwnerWCV {
    type Error = TpmErr;

    fn try_from(value: u32) -> Result<Self, TpmErr> {
        let result = match value {
            value if value == Self::Owner as u32 => Self::Owner,
            value if value == Self::Null as u32 => Self::Null,
            _ => {
                return Err(TpmErr::Rc(TpmRc::VALUE));
            },
        };

        Ok(result)
    }
}

impl convert::From<TpmiRhOwner> for TpmiRhOwnerWCV {
    fn from(value: TpmiRhOwner) -> Self {
        match value {
            TpmiRhOwner::Owner => Self::Owner,
        }
    }
}

impl convert::TryFrom<TpmiRhOwnerWCV> for TpmiRhOwner {
    type Error = TpmErr;

    fn try_from(value: TpmiRhOwnerWCV) -> Result<Self, TpmErr> {
        let result = match value {
            TpmiRhOwnerWCV::Owner => Self::Owner,
            TpmiRhOwnerWCV::Null => {
                return Err(TpmErr::Rc(TpmRc::VALUE));
            },
        };
        Ok(result)
    }
}

impl cmp::PartialEq<TpmiRhOwner> for TpmiRhOwnerWCV {
    fn eq(&self, other: &TpmiRhOwner) -> bool {
        *self as u32 == *other as u32
    }
}

impl cmp::PartialEq<TpmiRhOwnerWCV> for TpmiRhOwner {
    fn eq(&self, other: &TpmiRhOwnerWCV) -> bool {
        other.eq(self)
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 124, table 67, TPMI_RH_ENDORSEMENT type (without conditional values)
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u32)]
pub enum TpmiRhEndorsement {
    Endorsement = TpmRh::Endorsement as u32,
}

impl TpmiRhEndorsement {
    pub const fn marshalled_size() -> u16 {
        mem::size_of::<u32>() as u16
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u32(buf, *self as u32)
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u32(buf)?;
        let result = Self::try_from(value)?;
        Ok((buf, result))
    }
}

impl convert::TryFrom<u32> for TpmiRhEndorsement {
    type Error = TpmErr;

    fn try_from(value: u32) -> Result<Self, TpmErr> {
        let result = match value {
            value if value == Self::Endorsement as u32 => Self::Endorsement,
            _ => {
                return Err(TpmErr::Rc(TpmRc::VALUE));
            },
        };

        Ok(result)
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 124, table 67, TPMI_RH_ENDORSEMENT type (with conditional values)
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u32)]
pub enum TpmiRhEndorsementWCV {
    Endorsement = TpmRh::Endorsement as u32,
    Null = TpmRh::Null as u32,
}

impl TpmiRhEndorsementWCV {
    pub const fn marshalled_size() -> u16 {
        mem::size_of::<u32>() as u16
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u32(buf, *self as u32)
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u32(buf)?;
        let result = Self::try_from(value)?;
        Ok((buf, result))
    }
}

impl convert::TryFrom<u32> for TpmiRhEndorsementWCV {
    type Error = TpmErr;

    fn try_from(value: u32) -> Result<Self, TpmErr> {
        let result = match value {
            value if value == Self::Endorsement as u32 => Self::Endorsement,
            value if value == Self::Null as u32 => Self::Null,
            _ => {
                return Err(TpmErr::Rc(TpmRc::VALUE));
            },
        };

        Ok(result)
    }
}

impl convert::From<TpmiRhEndorsement> for TpmiRhEndorsementWCV {
    fn from(value: TpmiRhEndorsement) -> Self {
        match value {
            TpmiRhEndorsement::Endorsement => Self::Endorsement,
        }
    }
}

impl convert::TryFrom<TpmiRhEndorsementWCV> for TpmiRhEndorsement {
    type Error = TpmErr;

    fn try_from(value: TpmiRhEndorsementWCV) -> Result<Self, TpmErr> {
        let result = match value {
            TpmiRhEndorsementWCV::Endorsement => Self::Endorsement,
            TpmiRhEndorsementWCV::Null => {
                return Err(TpmErr::Rc(TpmRc::VALUE));
            },
        };
        Ok(result)
    }
}

impl cmp::PartialEq<TpmiRhEndorsement> for TpmiRhEndorsementWCV {
    fn eq(&self, other: &TpmiRhEndorsement) -> bool {
        *self as u32 == *other as u32
    }
}

impl cmp::PartialEq<TpmiRhEndorsementWCV> for TpmiRhEndorsement {
    fn eq(&self, other: &TpmiRhEndorsementWCV) -> bool {
        other.eq(self)
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 124, table 68, TPMI_RH_PROVISION type
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u32)]
pub enum TpmiRhProvision {
    Owner = TpmRh::Owner as u32,
    Platform = TpmRh::Platform as u32,
}

impl TpmiRhProvision {
    pub const fn marshalled_size() -> u16 {
        mem::size_of::<u32>() as u16
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u32(buf, *self as u32)
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u32(buf)?;
        let result = Self::try_from(value)?;
        Ok((buf, result))
    }
}

impl convert::TryFrom<u32> for TpmiRhProvision {
    type Error = TpmErr;

    fn try_from(value: u32) -> Result<Self, TpmErr> {
        let result = match value {
            value if value == Self::Owner as u32 => Self::Owner,
            value if value == Self::Platform as u32 => Self::Platform,
            _ => {
                return Err(TpmErr::Rc(TpmRc::VALUE));
            },
        };

        Ok(result)
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 125, table 69, TPMI_RH_CLEAR type
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u32)]
pub enum TpmiRhClear {
    Lockout = TpmRh::Lockout as u32,
    Platform = TpmRh::Platform as u32,
}

impl TpmiRhClear {
    pub const fn marshalled_size() -> u16 {
        mem::size_of::<u32>() as u16
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u32(buf, *self as u32)
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u32(buf)?;
        let result = Self::try_from(value)?;
        Ok((buf, result))
    }
}

impl convert::TryFrom<u32> for TpmiRhClear {
    type Error = TpmErr;

    fn try_from(value: u32) -> Result<Self, TpmErr> {
        let result = match value {
            value if value == Self::Lockout as u32 => Self::Lockout,
            value if value == Self::Platform as u32 => Self::Platform,
            _ => {
                return Err(TpmErr::Rc(TpmRc::VALUE));
            },
        };

        Ok(result)
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 125, table 70, TPMI_RH_NV_AUTH type
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct TpmiRhNvAuth {
    pub value: u32,
}

impl TpmiRhNvAuth {
    pub const fn marshalled_size() -> u16 {
        mem::size_of::<u32>() as u16
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u32(buf, self.value)
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u32(buf)?;

        if value == TpmRh::Platform as u32 {
            return Ok((buf, Self{value}))
        }

        if value == TpmRh::Owner as u32 {
            return Ok((buf, Self{value}))
        }

        if value >= TpmHc::NV_INDEX_FIRST {
            if value <= TpmHc::NV_INDEX_LAST {
                return Ok((buf, Self{value}))
            }
        }

        return Err(TpmErr::Rc(TpmRc::VALUE));
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 125, table 71, TPMI_RH_LOCKOUT type
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u32)]
pub enum TpmiRhLockout {
    Lockout = TpmRh::Lockout as u32,
}

impl TpmiRhLockout {
    pub const fn marshalled_size() -> u16 {
        mem::size_of::<u32>() as u16
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u32(buf, *self as u32)
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u32(buf)?;
        let result = Self::try_from(value)?;
        Ok((buf, result))
    }
}

impl convert::TryFrom<u32> for TpmiRhLockout {
    type Error = TpmErr;

    fn try_from(value: u32) -> Result<Self, TpmErr> {
        let result = match value {
            value if value == Self::Lockout as u32 => Self::Lockout,
            _ => {
                return Err(TpmErr::Rc(TpmRc::VALUE));
            },
        };

        Ok(result)
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 126, table 72, TPMI_RH_NV_INDEX type
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct TpmiRhNvIndex {
    pub value: u32,
}

impl TpmiRhNvIndex {
    pub const fn marshalled_size() -> u16 {
        mem::size_of::<u32>() as u16
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u32(buf, self.value)
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u32(buf)?;

        if value >= TpmHc::NV_INDEX_FIRST {
            if value <= TpmHc::NV_INDEX_LAST {
                return Ok((buf, Self{value}))
            }
        }

        if value >= TpmHc::EXTERNAL_NV_FIRST {
            if value <= TpmHc::EXTERNAL_NV_LAST {
                return Ok((buf, Self{value}))
            }
        }

        if value >= TpmHc::PERMANENT_NV_FIRST {
            if value <= TpmHc::PERMANENT_NV_LAST {
                return Ok((buf, Self{value}))
            }
        }

        return Err(TpmErr::Rc(TpmRc::VALUE));
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 126, table 73, TPMI_RH_NV_DEFINED_INDEX type
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct TpmiRhNvDefinedIndex {
    pub value: u32,
}

impl TpmiRhNvDefinedIndex {
    pub const fn marshalled_size() -> u16 {
        mem::size_of::<u32>() as u16
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u32(buf, self.value)
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u32(buf)?;

        if value >= TpmHc::NV_INDEX_FIRST {
            if value <= TpmHc::NV_INDEX_LAST {
                return Ok((buf, Self{value}))
            }
        }

        if value >= TpmHc::EXTERNAL_NV_FIRST {
            if value <= TpmHc::EXTERNAL_NV_LAST {
                return Ok((buf, Self{value}))
            }
        }

        return Err(TpmErr::Rc(TpmRc::VALUE));
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 126, table 74, TPMI_RH_NV_LEGACY_INDEX type
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct TpmiRhNvLegacyIndex {
    pub value: u32,
}

impl TpmiRhNvLegacyIndex {
    pub const fn marshalled_size() -> u16 {
        mem::size_of::<u32>() as u16
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u32(buf, self.value)
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u32(buf)?;

        if value >= TpmHc::NV_INDEX_FIRST {
            if value <= TpmHc::NV_INDEX_LAST {
                return Ok((buf, Self{value}))
            }
        }

        return Err(TpmErr::Rc(TpmRc::VALUE));
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 126, table 75, TPMI_RH_NV_EXP_INDEX type
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct TpmiRhNvExpIndex {
    pub value: u32,
}

impl TpmiRhNvExpIndex {
    pub const fn marshalled_size() -> u16 {
        mem::size_of::<u32>() as u16
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u32(buf, self.value)
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u32(buf)?;

        if value >= TpmHc::EXTERNAL_NV_FIRST {
            if value <= TpmHc::EXTERNAL_NV_LAST {
                return Ok((buf, Self{value}))
            }
        }

        return Err(TpmErr::Rc(TpmRc::VALUE));
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 127, table 76, TPMI_RH_AC type
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct TpmiRhAc {
    pub value: u32,
}

impl TpmiRhAc {
    pub const fn marshalled_size() -> u16 {
        mem::size_of::<u32>() as u16
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u32(buf, self.value)
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u32(buf)?;

        if value >= TpmHc::AC_FIRST {
            if value <= TpmHc::AC_LAST {
                return Ok((buf, Self{value}))
            }
        }

        return Err(TpmErr::Rc(TpmRc::VALUE));
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 127, table 77, TPMI_RH_ACT type
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct TpmiRhAct {
    pub value: u32,
}

impl TpmiRhAct {
    pub const fn marshalled_size() -> u16 {
        mem::size_of::<u32>() as u16
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u32(buf, self.value)
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u32(buf)?;

        if value >= TpmRh::Act0 as u32 {
            if value <= TpmRh::ActF as u32 {
                return Ok((buf, Self{value}))
            }
        }

        return Err(TpmErr::Rc(TpmRc::VALUE));
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 127, table 78, TPMI_ALG_HASH type (without conditional values)
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[cfg_attr(any(feature = "sha1", feature = "sha256", feature = "sha384", feature = "sha3_256", feature = "sha3_384", feature = "sha3_512", feature = "sha512", feature = "sm3_256"), repr(u16))]
pub enum TpmiAlgHash {
    #[cfg(feature = "sha1")]
    Sha1 = TpmAlgId::Sha1 as u16,
    #[cfg(feature = "sha256")]
    Sha256 = TpmAlgId::Sha256 as u16,
    #[cfg(feature = "sha384")]
    Sha384 = TpmAlgId::Sha384 as u16,
    #[cfg(feature = "sha512")]
    Sha512 = TpmAlgId::Sha512 as u16,
    #[cfg(feature = "sm3_256")]
    Sm3_256 = TpmAlgId::Sm3_256 as u16,
    #[cfg(feature = "sha3_256")]
    Sha3_256 = TpmAlgId::Sha3_256 as u16,
    #[cfg(feature = "sha3_384")]
    Sha3_384 = TpmAlgId::Sha3_384 as u16,
    #[cfg(feature = "sha3_512")]
    Sha3_512 = TpmAlgId::Sha3_512 as u16,
}

impl TpmiAlgHash {
    pub const fn marshalled_size() -> u16 {
        mem::size_of::<u16>() as u16
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u16(buf, *self as u16)
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u16(buf)?;
        let result = Self::try_from(value)?;
        Ok((buf, result))
    }
}

impl convert::TryFrom<u16> for TpmiAlgHash {
    type Error = TpmErr;

    fn try_from(value: u16) -> Result<Self, TpmErr> {
        let result = match value {
            #[cfg(feature = "sha1")]
            value if value == Self::Sha1 as u16 => Self::Sha1,
            #[cfg(feature = "sha256")]
            value if value == Self::Sha256 as u16 => Self::Sha256,
            #[cfg(feature = "sha384")]
            value if value == Self::Sha384 as u16 => Self::Sha384,
            #[cfg(feature = "sha512")]
            value if value == Self::Sha512 as u16 => Self::Sha512,
            #[cfg(feature = "sm3_256")]
            value if value == Self::Sm3_256 as u16 => Self::Sm3_256,
            #[cfg(feature = "sha3_256")]
            value if value == Self::Sha3_256 as u16 => Self::Sha3_256,
            #[cfg(feature = "sha3_384")]
            value if value == Self::Sha3_384 as u16 => Self::Sha3_384,
            #[cfg(feature = "sha3_512")]
            value if value == Self::Sha3_512 as u16 => Self::Sha3_512,
            _ => {
                return Err(TpmErr::Rc(TpmRc::HASH));
            },
        };

        Ok(result)
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 127, table 78, TPMI_ALG_HASH type (with conditional values)
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u16)]
pub enum TpmiAlgHashWCV {
    #[cfg(feature = "sha1")]
    Sha1 = TpmAlgId::Sha1 as u16,
    #[cfg(feature = "sha256")]
    Sha256 = TpmAlgId::Sha256 as u16,
    #[cfg(feature = "sha384")]
    Sha384 = TpmAlgId::Sha384 as u16,
    #[cfg(feature = "sha512")]
    Sha512 = TpmAlgId::Sha512 as u16,
    #[cfg(feature = "sm3_256")]
    Sm3_256 = TpmAlgId::Sm3_256 as u16,
    #[cfg(feature = "sha3_256")]
    Sha3_256 = TpmAlgId::Sha3_256 as u16,
    #[cfg(feature = "sha3_384")]
    Sha3_384 = TpmAlgId::Sha3_384 as u16,
    #[cfg(feature = "sha3_512")]
    Sha3_512 = TpmAlgId::Sha3_512 as u16,
    Null = TpmAlgId::Null as u16,
}

impl TpmiAlgHashWCV {
    pub const fn marshalled_size() -> u16 {
        mem::size_of::<u16>() as u16
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u16(buf, *self as u16)
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u16(buf)?;
        let result = Self::try_from(value)?;
        Ok((buf, result))
    }
}

impl convert::TryFrom<u16> for TpmiAlgHashWCV {
    type Error = TpmErr;

    fn try_from(value: u16) -> Result<Self, TpmErr> {
        let result = match value {
            #[cfg(feature = "sha1")]
            value if value == Self::Sha1 as u16 => Self::Sha1,
            #[cfg(feature = "sha256")]
            value if value == Self::Sha256 as u16 => Self::Sha256,
            #[cfg(feature = "sha384")]
            value if value == Self::Sha384 as u16 => Self::Sha384,
            #[cfg(feature = "sha512")]
            value if value == Self::Sha512 as u16 => Self::Sha512,
            #[cfg(feature = "sm3_256")]
            value if value == Self::Sm3_256 as u16 => Self::Sm3_256,
            #[cfg(feature = "sha3_256")]
            value if value == Self::Sha3_256 as u16 => Self::Sha3_256,
            #[cfg(feature = "sha3_384")]
            value if value == Self::Sha3_384 as u16 => Self::Sha3_384,
            #[cfg(feature = "sha3_512")]
            value if value == Self::Sha3_512 as u16 => Self::Sha3_512,
            value if value == Self::Null as u16 => Self::Null,
            _ => {
                return Err(TpmErr::Rc(TpmRc::HASH));
            },
        };

        Ok(result)
    }
}

impl convert::From<TpmiAlgHash> for TpmiAlgHashWCV {
    fn from(value: TpmiAlgHash) -> Self {
        match value {
            #[cfg(feature = "sha1")]
            TpmiAlgHash::Sha1 => Self::Sha1,
            #[cfg(feature = "sha256")]
            TpmiAlgHash::Sha256 => Self::Sha256,
            #[cfg(feature = "sha384")]
            TpmiAlgHash::Sha384 => Self::Sha384,
            #[cfg(feature = "sha512")]
            TpmiAlgHash::Sha512 => Self::Sha512,
            #[cfg(feature = "sm3_256")]
            TpmiAlgHash::Sm3_256 => Self::Sm3_256,
            #[cfg(feature = "sha3_256")]
            TpmiAlgHash::Sha3_256 => Self::Sha3_256,
            #[cfg(feature = "sha3_384")]
            TpmiAlgHash::Sha3_384 => Self::Sha3_384,
            #[cfg(feature = "sha3_512")]
            TpmiAlgHash::Sha3_512 => Self::Sha3_512,
        }
    }
}

impl convert::TryFrom<TpmiAlgHashWCV> for TpmiAlgHash {
    type Error = TpmErr;

    fn try_from(value: TpmiAlgHashWCV) -> Result<Self, TpmErr> {
        let result = match value {
            #[cfg(feature = "sha1")]
            TpmiAlgHashWCV::Sha1 => Self::Sha1,
            #[cfg(feature = "sha256")]
            TpmiAlgHashWCV::Sha256 => Self::Sha256,
            #[cfg(feature = "sha384")]
            TpmiAlgHashWCV::Sha384 => Self::Sha384,
            #[cfg(feature = "sha512")]
            TpmiAlgHashWCV::Sha512 => Self::Sha512,
            #[cfg(feature = "sm3_256")]
            TpmiAlgHashWCV::Sm3_256 => Self::Sm3_256,
            #[cfg(feature = "sha3_256")]
            TpmiAlgHashWCV::Sha3_256 => Self::Sha3_256,
            #[cfg(feature = "sha3_384")]
            TpmiAlgHashWCV::Sha3_384 => Self::Sha3_384,
            #[cfg(feature = "sha3_512")]
            TpmiAlgHashWCV::Sha3_512 => Self::Sha3_512,
            TpmiAlgHashWCV::Null => {
                return Err(TpmErr::Rc(TpmRc::HASH));
            },
        };
        Ok(result)
    }
}

impl cmp::PartialEq<TpmiAlgHash> for TpmiAlgHashWCV {
    fn eq(&self, other: &TpmiAlgHash) -> bool {
        *self as u16 == *other as u16
    }
}

impl cmp::PartialEq<TpmiAlgHashWCV> for TpmiAlgHash {
    fn eq(&self, other: &TpmiAlgHashWCV) -> bool {
        other.eq(self)
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 127, table 79, TPMI_ALG_ASYM type (without conditional values)
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[cfg_attr(any(feature = "ecc", feature = "rsa"), repr(u16))]
pub enum TpmiAlgAsym {
    #[cfg(feature = "rsa")]
    Rsa = TpmAlgId::Rsa as u16,
    #[cfg(feature = "ecc")]
    Ecc = TpmAlgId::Ecc as u16,
}

impl TpmiAlgAsym {
    pub const fn marshalled_size() -> u16 {
        mem::size_of::<u16>() as u16
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u16(buf, *self as u16)
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u16(buf)?;
        let result = Self::try_from(value)?;
        Ok((buf, result))
    }
}

impl convert::TryFrom<u16> for TpmiAlgAsym {
    type Error = TpmErr;

    fn try_from(value: u16) -> Result<Self, TpmErr> {
        let result = match value {
            #[cfg(feature = "rsa")]
            value if value == Self::Rsa as u16 => Self::Rsa,
            #[cfg(feature = "ecc")]
            value if value == Self::Ecc as u16 => Self::Ecc,
            _ => {
                return Err(TpmErr::Rc(TpmRc::ASYMMETRIC));
            },
        };

        Ok(result)
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 127, table 79, TPMI_ALG_ASYM type (with conditional values)
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u16)]
pub enum TpmiAlgAsymWCV {
    #[cfg(feature = "rsa")]
    Rsa = TpmAlgId::Rsa as u16,
    #[cfg(feature = "ecc")]
    Ecc = TpmAlgId::Ecc as u16,
    Null = TpmAlgId::Null as u16,
}

impl TpmiAlgAsymWCV {
    pub const fn marshalled_size() -> u16 {
        mem::size_of::<u16>() as u16
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u16(buf, *self as u16)
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u16(buf)?;
        let result = Self::try_from(value)?;
        Ok((buf, result))
    }
}

impl convert::TryFrom<u16> for TpmiAlgAsymWCV {
    type Error = TpmErr;

    fn try_from(value: u16) -> Result<Self, TpmErr> {
        let result = match value {
            #[cfg(feature = "rsa")]
            value if value == Self::Rsa as u16 => Self::Rsa,
            #[cfg(feature = "ecc")]
            value if value == Self::Ecc as u16 => Self::Ecc,
            value if value == Self::Null as u16 => Self::Null,
            _ => {
                return Err(TpmErr::Rc(TpmRc::ASYMMETRIC));
            },
        };

        Ok(result)
    }
}

impl convert::From<TpmiAlgAsym> for TpmiAlgAsymWCV {
    fn from(value: TpmiAlgAsym) -> Self {
        match value {
            #[cfg(feature = "rsa")]
            TpmiAlgAsym::Rsa => Self::Rsa,
            #[cfg(feature = "ecc")]
            TpmiAlgAsym::Ecc => Self::Ecc,
        }
    }
}

impl convert::TryFrom<TpmiAlgAsymWCV> for TpmiAlgAsym {
    type Error = TpmErr;

    fn try_from(value: TpmiAlgAsymWCV) -> Result<Self, TpmErr> {
        let result = match value {
            #[cfg(feature = "rsa")]
            TpmiAlgAsymWCV::Rsa => Self::Rsa,
            #[cfg(feature = "ecc")]
            TpmiAlgAsymWCV::Ecc => Self::Ecc,
            TpmiAlgAsymWCV::Null => {
                return Err(TpmErr::Rc(TpmRc::ASYMMETRIC));
            },
        };
        Ok(result)
    }
}

impl cmp::PartialEq<TpmiAlgAsym> for TpmiAlgAsymWCV {
    fn eq(&self, other: &TpmiAlgAsym) -> bool {
        *self as u16 == *other as u16
    }
}

impl cmp::PartialEq<TpmiAlgAsymWCV> for TpmiAlgAsym {
    fn eq(&self, other: &TpmiAlgAsymWCV) -> bool {
        other.eq(self)
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 128, table 80, TPMI_ALG_SYM type (without conditional values)
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u16)]
pub enum TpmiAlgSym {
    #[cfg(feature = "tdes")]
    Tdes = TpmAlgId::Tdes as u16,
    #[cfg(feature = "aes")]
    Aes = TpmAlgId::Aes as u16,
    #[cfg(feature = "sm4")]
    Sm4 = TpmAlgId::Sm4 as u16,
    #[cfg(feature = "camellia")]
    Camellia = TpmAlgId::Camellia as u16,
    Xor = TpmAlgId::Xor as u16,
}

impl TpmiAlgSym {
    pub const fn marshalled_size() -> u16 {
        mem::size_of::<u16>() as u16
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u16(buf, *self as u16)
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u16(buf)?;
        let result = Self::try_from(value)?;
        Ok((buf, result))
    }
}

impl convert::TryFrom<u16> for TpmiAlgSym {
    type Error = TpmErr;

    fn try_from(value: u16) -> Result<Self, TpmErr> {
        let result = match value {
            #[cfg(feature = "tdes")]
            value if value == Self::Tdes as u16 => Self::Tdes,
            #[cfg(feature = "aes")]
            value if value == Self::Aes as u16 => Self::Aes,
            #[cfg(feature = "sm4")]
            value if value == Self::Sm4 as u16 => Self::Sm4,
            #[cfg(feature = "camellia")]
            value if value == Self::Camellia as u16 => Self::Camellia,
            value if value == Self::Xor as u16 => Self::Xor,
            _ => {
                return Err(TpmErr::Rc(TpmRc::SYMMETRIC));
            },
        };

        Ok(result)
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 128, table 80, TPMI_ALG_SYM type (with conditional values)
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u16)]
pub enum TpmiAlgSymWCV {
    #[cfg(feature = "tdes")]
    Tdes = TpmAlgId::Tdes as u16,
    #[cfg(feature = "aes")]
    Aes = TpmAlgId::Aes as u16,
    #[cfg(feature = "sm4")]
    Sm4 = TpmAlgId::Sm4 as u16,
    #[cfg(feature = "camellia")]
    Camellia = TpmAlgId::Camellia as u16,
    Xor = TpmAlgId::Xor as u16,
    Null = TpmAlgId::Null as u16,
}

impl TpmiAlgSymWCV {
    pub const fn marshalled_size() -> u16 {
        mem::size_of::<u16>() as u16
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u16(buf, *self as u16)
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u16(buf)?;
        let result = Self::try_from(value)?;
        Ok((buf, result))
    }
}

impl convert::TryFrom<u16> for TpmiAlgSymWCV {
    type Error = TpmErr;

    fn try_from(value: u16) -> Result<Self, TpmErr> {
        let result = match value {
            #[cfg(feature = "tdes")]
            value if value == Self::Tdes as u16 => Self::Tdes,
            #[cfg(feature = "aes")]
            value if value == Self::Aes as u16 => Self::Aes,
            #[cfg(feature = "sm4")]
            value if value == Self::Sm4 as u16 => Self::Sm4,
            #[cfg(feature = "camellia")]
            value if value == Self::Camellia as u16 => Self::Camellia,
            value if value == Self::Xor as u16 => Self::Xor,
            value if value == Self::Null as u16 => Self::Null,
            _ => {
                return Err(TpmErr::Rc(TpmRc::SYMMETRIC));
            },
        };

        Ok(result)
    }
}

impl convert::From<TpmiAlgSym> for TpmiAlgSymWCV {
    fn from(value: TpmiAlgSym) -> Self {
        match value {
            #[cfg(feature = "tdes")]
            TpmiAlgSym::Tdes => Self::Tdes,
            #[cfg(feature = "aes")]
            TpmiAlgSym::Aes => Self::Aes,
            #[cfg(feature = "sm4")]
            TpmiAlgSym::Sm4 => Self::Sm4,
            #[cfg(feature = "camellia")]
            TpmiAlgSym::Camellia => Self::Camellia,
            TpmiAlgSym::Xor => Self::Xor,
        }
    }
}

impl convert::TryFrom<TpmiAlgSymWCV> for TpmiAlgSym {
    type Error = TpmErr;

    fn try_from(value: TpmiAlgSymWCV) -> Result<Self, TpmErr> {
        let result = match value {
            #[cfg(feature = "tdes")]
            TpmiAlgSymWCV::Tdes => Self::Tdes,
            #[cfg(feature = "aes")]
            TpmiAlgSymWCV::Aes => Self::Aes,
            #[cfg(feature = "sm4")]
            TpmiAlgSymWCV::Sm4 => Self::Sm4,
            #[cfg(feature = "camellia")]
            TpmiAlgSymWCV::Camellia => Self::Camellia,
            TpmiAlgSymWCV::Xor => Self::Xor,
            TpmiAlgSymWCV::Null => {
                return Err(TpmErr::Rc(TpmRc::SYMMETRIC));
            },
        };
        Ok(result)
    }
}

impl cmp::PartialEq<TpmiAlgSym> for TpmiAlgSymWCV {
    fn eq(&self, other: &TpmiAlgSym) -> bool {
        *self as u16 == *other as u16
    }
}

impl cmp::PartialEq<TpmiAlgSymWCV> for TpmiAlgSym {
    fn eq(&self, other: &TpmiAlgSymWCV) -> bool {
        other.eq(self)
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 128, table 81, TPMI_ALG_SYM_OBJECT type (without conditional values)
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[cfg_attr(any(feature = "aes", feature = "camellia", feature = "sm4", feature = "tdes"), repr(u16))]
pub enum TpmiAlgSymObject {
    #[cfg(feature = "tdes")]
    Tdes = TpmAlgId::Tdes as u16,
    #[cfg(feature = "aes")]
    Aes = TpmAlgId::Aes as u16,
    #[cfg(feature = "sm4")]
    Sm4 = TpmAlgId::Sm4 as u16,
    #[cfg(feature = "camellia")]
    Camellia = TpmAlgId::Camellia as u16,
}

impl TpmiAlgSymObject {
    pub const fn marshalled_size() -> u16 {
        mem::size_of::<u16>() as u16
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u16(buf, *self as u16)
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u16(buf)?;
        let result = Self::try_from(value)?;
        Ok((buf, result))
    }
}

impl convert::TryFrom<u16> for TpmiAlgSymObject {
    type Error = TpmErr;

    fn try_from(value: u16) -> Result<Self, TpmErr> {
        let result = match value {
            #[cfg(feature = "tdes")]
            value if value == Self::Tdes as u16 => Self::Tdes,
            #[cfg(feature = "aes")]
            value if value == Self::Aes as u16 => Self::Aes,
            #[cfg(feature = "sm4")]
            value if value == Self::Sm4 as u16 => Self::Sm4,
            #[cfg(feature = "camellia")]
            value if value == Self::Camellia as u16 => Self::Camellia,
            _ => {
                return Err(TpmErr::Rc(TpmRc::SYMMETRIC));
            },
        };

        Ok(result)
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 128, table 81, TPMI_ALG_SYM_OBJECT type (with conditional values)
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u16)]
pub enum TpmiAlgSymObjectWCV {
    #[cfg(feature = "tdes")]
    Tdes = TpmAlgId::Tdes as u16,
    #[cfg(feature = "aes")]
    Aes = TpmAlgId::Aes as u16,
    #[cfg(feature = "sm4")]
    Sm4 = TpmAlgId::Sm4 as u16,
    #[cfg(feature = "camellia")]
    Camellia = TpmAlgId::Camellia as u16,
    Null = TpmAlgId::Null as u16,
}

impl TpmiAlgSymObjectWCV {
    pub const fn marshalled_size() -> u16 {
        mem::size_of::<u16>() as u16
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u16(buf, *self as u16)
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u16(buf)?;
        let result = Self::try_from(value)?;
        Ok((buf, result))
    }
}

impl convert::TryFrom<u16> for TpmiAlgSymObjectWCV {
    type Error = TpmErr;

    fn try_from(value: u16) -> Result<Self, TpmErr> {
        let result = match value {
            #[cfg(feature = "tdes")]
            value if value == Self::Tdes as u16 => Self::Tdes,
            #[cfg(feature = "aes")]
            value if value == Self::Aes as u16 => Self::Aes,
            #[cfg(feature = "sm4")]
            value if value == Self::Sm4 as u16 => Self::Sm4,
            #[cfg(feature = "camellia")]
            value if value == Self::Camellia as u16 => Self::Camellia,
            value if value == Self::Null as u16 => Self::Null,
            _ => {
                return Err(TpmErr::Rc(TpmRc::SYMMETRIC));
            },
        };

        Ok(result)
    }
}

impl convert::From<TpmiAlgSymObject> for TpmiAlgSymObjectWCV {
    fn from(value: TpmiAlgSymObject) -> Self {
        match value {
            #[cfg(feature = "tdes")]
            TpmiAlgSymObject::Tdes => Self::Tdes,
            #[cfg(feature = "aes")]
            TpmiAlgSymObject::Aes => Self::Aes,
            #[cfg(feature = "sm4")]
            TpmiAlgSymObject::Sm4 => Self::Sm4,
            #[cfg(feature = "camellia")]
            TpmiAlgSymObject::Camellia => Self::Camellia,
        }
    }
}

impl convert::TryFrom<TpmiAlgSymObjectWCV> for TpmiAlgSymObject {
    type Error = TpmErr;

    fn try_from(value: TpmiAlgSymObjectWCV) -> Result<Self, TpmErr> {
        let result = match value {
            #[cfg(feature = "tdes")]
            TpmiAlgSymObjectWCV::Tdes => Self::Tdes,
            #[cfg(feature = "aes")]
            TpmiAlgSymObjectWCV::Aes => Self::Aes,
            #[cfg(feature = "sm4")]
            TpmiAlgSymObjectWCV::Sm4 => Self::Sm4,
            #[cfg(feature = "camellia")]
            TpmiAlgSymObjectWCV::Camellia => Self::Camellia,
            TpmiAlgSymObjectWCV::Null => {
                return Err(TpmErr::Rc(TpmRc::SYMMETRIC));
            },
        };
        Ok(result)
    }
}

impl cmp::PartialEq<TpmiAlgSymObject> for TpmiAlgSymObjectWCV {
    fn eq(&self, other: &TpmiAlgSymObject) -> bool {
        *self as u16 == *other as u16
    }
}

impl cmp::PartialEq<TpmiAlgSymObjectWCV> for TpmiAlgSymObject {
    fn eq(&self, other: &TpmiAlgSymObjectWCV) -> bool {
        other.eq(self)
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 129, table 82, TPMI_ALG_SYM_MODE type (without conditional values)
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[cfg_attr(any(feature = "cbc", feature = "cfb", feature = "cmac", feature = "ctr", feature = "ecb", feature = "ofb"), repr(u16))]
pub enum TpmiAlgSymMode {
    #[cfg(feature = "ctr")]
    Ctr = TpmAlgId::Ctr as u16,
    #[cfg(feature = "ofb")]
    Ofb = TpmAlgId::Ofb as u16,
    #[cfg(feature = "cbc")]
    Cbc = TpmAlgId::Cbc as u16,
    #[cfg(feature = "cfb")]
    Cfb = TpmAlgId::Cfb as u16,
    #[cfg(feature = "ecb")]
    Ecb = TpmAlgId::Ecb as u16,
    #[cfg(feature = "cmac")]
    Cmac = TpmAlgId::Cmac as u16,
}

impl TpmiAlgSymMode {
    pub const fn marshalled_size() -> u16 {
        mem::size_of::<u16>() as u16
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u16(buf, *self as u16)
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u16(buf)?;
        let result = Self::try_from(value)?;
        Ok((buf, result))
    }
}

impl convert::TryFrom<u16> for TpmiAlgSymMode {
    type Error = TpmErr;

    fn try_from(value: u16) -> Result<Self, TpmErr> {
        let result = match value {
            #[cfg(feature = "ctr")]
            value if value == Self::Ctr as u16 => Self::Ctr,
            #[cfg(feature = "ofb")]
            value if value == Self::Ofb as u16 => Self::Ofb,
            #[cfg(feature = "cbc")]
            value if value == Self::Cbc as u16 => Self::Cbc,
            #[cfg(feature = "cfb")]
            value if value == Self::Cfb as u16 => Self::Cfb,
            #[cfg(feature = "ecb")]
            value if value == Self::Ecb as u16 => Self::Ecb,
            #[cfg(feature = "cmac")]
            value if value == Self::Cmac as u16 => Self::Cmac,
            _ => {
                return Err(TpmErr::Rc(TpmRc::MODE));
            },
        };

        Ok(result)
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 129, table 82, TPMI_ALG_SYM_MODE type (with conditional values)
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u16)]
pub enum TpmiAlgSymModeWCV {
    #[cfg(feature = "ctr")]
    Ctr = TpmAlgId::Ctr as u16,
    #[cfg(feature = "ofb")]
    Ofb = TpmAlgId::Ofb as u16,
    #[cfg(feature = "cbc")]
    Cbc = TpmAlgId::Cbc as u16,
    #[cfg(feature = "cfb")]
    Cfb = TpmAlgId::Cfb as u16,
    #[cfg(feature = "ecb")]
    Ecb = TpmAlgId::Ecb as u16,
    #[cfg(feature = "cmac")]
    Cmac = TpmAlgId::Cmac as u16,
    Null = TpmAlgId::Null as u16,
}

impl TpmiAlgSymModeWCV {
    pub const fn marshalled_size() -> u16 {
        mem::size_of::<u16>() as u16
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u16(buf, *self as u16)
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u16(buf)?;
        let result = Self::try_from(value)?;
        Ok((buf, result))
    }
}

impl convert::TryFrom<u16> for TpmiAlgSymModeWCV {
    type Error = TpmErr;

    fn try_from(value: u16) -> Result<Self, TpmErr> {
        let result = match value {
            #[cfg(feature = "ctr")]
            value if value == Self::Ctr as u16 => Self::Ctr,
            #[cfg(feature = "ofb")]
            value if value == Self::Ofb as u16 => Self::Ofb,
            #[cfg(feature = "cbc")]
            value if value == Self::Cbc as u16 => Self::Cbc,
            #[cfg(feature = "cfb")]
            value if value == Self::Cfb as u16 => Self::Cfb,
            #[cfg(feature = "ecb")]
            value if value == Self::Ecb as u16 => Self::Ecb,
            #[cfg(feature = "cmac")]
            value if value == Self::Cmac as u16 => Self::Cmac,
            value if value == Self::Null as u16 => Self::Null,
            _ => {
                return Err(TpmErr::Rc(TpmRc::MODE));
            },
        };

        Ok(result)
    }
}

impl convert::From<TpmiAlgSymMode> for TpmiAlgSymModeWCV {
    fn from(value: TpmiAlgSymMode) -> Self {
        match value {
            #[cfg(feature = "ctr")]
            TpmiAlgSymMode::Ctr => Self::Ctr,
            #[cfg(feature = "ofb")]
            TpmiAlgSymMode::Ofb => Self::Ofb,
            #[cfg(feature = "cbc")]
            TpmiAlgSymMode::Cbc => Self::Cbc,
            #[cfg(feature = "cfb")]
            TpmiAlgSymMode::Cfb => Self::Cfb,
            #[cfg(feature = "ecb")]
            TpmiAlgSymMode::Ecb => Self::Ecb,
            #[cfg(feature = "cmac")]
            TpmiAlgSymMode::Cmac => Self::Cmac,
        }
    }
}

impl convert::TryFrom<TpmiAlgSymModeWCV> for TpmiAlgSymMode {
    type Error = TpmErr;

    fn try_from(value: TpmiAlgSymModeWCV) -> Result<Self, TpmErr> {
        let result = match value {
            #[cfg(feature = "ctr")]
            TpmiAlgSymModeWCV::Ctr => Self::Ctr,
            #[cfg(feature = "ofb")]
            TpmiAlgSymModeWCV::Ofb => Self::Ofb,
            #[cfg(feature = "cbc")]
            TpmiAlgSymModeWCV::Cbc => Self::Cbc,
            #[cfg(feature = "cfb")]
            TpmiAlgSymModeWCV::Cfb => Self::Cfb,
            #[cfg(feature = "ecb")]
            TpmiAlgSymModeWCV::Ecb => Self::Ecb,
            #[cfg(feature = "cmac")]
            TpmiAlgSymModeWCV::Cmac => Self::Cmac,
            TpmiAlgSymModeWCV::Null => {
                return Err(TpmErr::Rc(TpmRc::MODE));
            },
        };
        Ok(result)
    }
}

impl cmp::PartialEq<TpmiAlgSymMode> for TpmiAlgSymModeWCV {
    fn eq(&self, other: &TpmiAlgSymMode) -> bool {
        *self as u16 == *other as u16
    }
}

impl cmp::PartialEq<TpmiAlgSymModeWCV> for TpmiAlgSymMode {
    fn eq(&self, other: &TpmiAlgSymModeWCV) -> bool {
        other.eq(self)
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 129, table 83, TPMI_ALG_KDF type (without conditional values)
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[cfg_attr(any(feature = "kdf1_sp800_108", feature = "kdf2", feature = "mgf1", all(feature = "ecc", feature = "kdf1_sp800_56a")), repr(u16))]
pub enum TpmiAlgKdf {
    #[cfg(feature = "mgf1")]
    Mgf1 = TpmAlgId::Mgf1 as u16,
    #[cfg(all(feature = "ecc", feature = "kdf1_sp800_56a"))]
    Kdf1Sp800_56a = TpmAlgId::Kdf1Sp800_56a as u16,
    #[cfg(feature = "kdf2")]
    Kdf2 = TpmAlgId::Kdf2 as u16,
    #[cfg(feature = "kdf1_sp800_108")]
    Kdf1Sp800_108 = TpmAlgId::Kdf1Sp800_108 as u16,
}

impl TpmiAlgKdf {
    pub const fn marshalled_size() -> u16 {
        mem::size_of::<u16>() as u16
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u16(buf, *self as u16)
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u16(buf)?;
        let result = Self::try_from(value)?;
        Ok((buf, result))
    }
}

impl convert::TryFrom<u16> for TpmiAlgKdf {
    type Error = TpmErr;

    fn try_from(value: u16) -> Result<Self, TpmErr> {
        let result = match value {
            #[cfg(feature = "mgf1")]
            value if value == Self::Mgf1 as u16 => Self::Mgf1,
            #[cfg(all(feature = "ecc", feature = "kdf1_sp800_56a"))]
            value if value == Self::Kdf1Sp800_56a as u16 => Self::Kdf1Sp800_56a,
            #[cfg(feature = "kdf2")]
            value if value == Self::Kdf2 as u16 => Self::Kdf2,
            #[cfg(feature = "kdf1_sp800_108")]
            value if value == Self::Kdf1Sp800_108 as u16 => Self::Kdf1Sp800_108,
            _ => {
                return Err(TpmErr::Rc(TpmRc::KDF));
            },
        };

        Ok(result)
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 129, table 83, TPMI_ALG_KDF type (with conditional values)
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u16)]
pub enum TpmiAlgKdfWCV {
    #[cfg(feature = "mgf1")]
    Mgf1 = TpmAlgId::Mgf1 as u16,
    #[cfg(all(feature = "ecc", feature = "kdf1_sp800_56a"))]
    Kdf1Sp800_56a = TpmAlgId::Kdf1Sp800_56a as u16,
    #[cfg(feature = "kdf2")]
    Kdf2 = TpmAlgId::Kdf2 as u16,
    #[cfg(feature = "kdf1_sp800_108")]
    Kdf1Sp800_108 = TpmAlgId::Kdf1Sp800_108 as u16,
    Null = TpmAlgId::Null as u16,
}

impl TpmiAlgKdfWCV {
    pub const fn marshalled_size() -> u16 {
        mem::size_of::<u16>() as u16
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u16(buf, *self as u16)
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u16(buf)?;
        let result = Self::try_from(value)?;
        Ok((buf, result))
    }
}

impl convert::TryFrom<u16> for TpmiAlgKdfWCV {
    type Error = TpmErr;

    fn try_from(value: u16) -> Result<Self, TpmErr> {
        let result = match value {
            #[cfg(feature = "mgf1")]
            value if value == Self::Mgf1 as u16 => Self::Mgf1,
            #[cfg(all(feature = "ecc", feature = "kdf1_sp800_56a"))]
            value if value == Self::Kdf1Sp800_56a as u16 => Self::Kdf1Sp800_56a,
            #[cfg(feature = "kdf2")]
            value if value == Self::Kdf2 as u16 => Self::Kdf2,
            #[cfg(feature = "kdf1_sp800_108")]
            value if value == Self::Kdf1Sp800_108 as u16 => Self::Kdf1Sp800_108,
            value if value == Self::Null as u16 => Self::Null,
            _ => {
                return Err(TpmErr::Rc(TpmRc::KDF));
            },
        };

        Ok(result)
    }
}

impl convert::From<TpmiAlgKdf> for TpmiAlgKdfWCV {
    fn from(value: TpmiAlgKdf) -> Self {
        match value {
            #[cfg(feature = "mgf1")]
            TpmiAlgKdf::Mgf1 => Self::Mgf1,
            #[cfg(all(feature = "ecc", feature = "kdf1_sp800_56a"))]
            TpmiAlgKdf::Kdf1Sp800_56a => Self::Kdf1Sp800_56a,
            #[cfg(feature = "kdf2")]
            TpmiAlgKdf::Kdf2 => Self::Kdf2,
            #[cfg(feature = "kdf1_sp800_108")]
            TpmiAlgKdf::Kdf1Sp800_108 => Self::Kdf1Sp800_108,
        }
    }
}

impl convert::TryFrom<TpmiAlgKdfWCV> for TpmiAlgKdf {
    type Error = TpmErr;

    fn try_from(value: TpmiAlgKdfWCV) -> Result<Self, TpmErr> {
        let result = match value {
            #[cfg(feature = "mgf1")]
            TpmiAlgKdfWCV::Mgf1 => Self::Mgf1,
            #[cfg(all(feature = "ecc", feature = "kdf1_sp800_56a"))]
            TpmiAlgKdfWCV::Kdf1Sp800_56a => Self::Kdf1Sp800_56a,
            #[cfg(feature = "kdf2")]
            TpmiAlgKdfWCV::Kdf2 => Self::Kdf2,
            #[cfg(feature = "kdf1_sp800_108")]
            TpmiAlgKdfWCV::Kdf1Sp800_108 => Self::Kdf1Sp800_108,
            TpmiAlgKdfWCV::Null => {
                return Err(TpmErr::Rc(TpmRc::KDF));
            },
        };
        Ok(result)
    }
}

impl cmp::PartialEq<TpmiAlgKdf> for TpmiAlgKdfWCV {
    fn eq(&self, other: &TpmiAlgKdf) -> bool {
        *self as u16 == *other as u16
    }
}

impl cmp::PartialEq<TpmiAlgKdfWCV> for TpmiAlgKdf {
    fn eq(&self, other: &TpmiAlgKdfWCV) -> bool {
        other.eq(self)
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 129, table 84, TPMI_ALG_SIG_SCHEME type (without conditional values)
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[cfg_attr(any(feature = "hmac", all(feature = "ecc", feature = "ecdaa"), all(feature = "ecc", feature = "ecdsa"), all(feature = "ecc", feature = "ecschnorr"), all(feature = "ecc", feature = "eddsa"), all(feature = "ecc", feature = "eddsa_ph"), all(feature = "ecc", feature = "sm2"), all(feature = "rsa", feature = "rsapss"), all(feature = "rsa", feature = "rsassa")), repr(u16))]
pub enum TpmiAlgSigScheme {
    #[cfg(all(feature = "rsa", feature = "rsassa"))]
    Rsassa = TpmAlgId::Rsassa as u16,
    #[cfg(all(feature = "rsa", feature = "rsapss"))]
    Rsapss = TpmAlgId::Rsapss as u16,
    #[cfg(all(feature = "ecc", feature = "ecdsa"))]
    Ecdsa = TpmAlgId::Ecdsa as u16,
    #[cfg(all(feature = "ecc", feature = "ecdaa"))]
    Ecdaa = TpmAlgId::Ecdaa as u16,
    #[cfg(all(feature = "ecc", feature = "sm2"))]
    Sm2 = TpmAlgId::Sm2 as u16,
    #[cfg(all(feature = "ecc", feature = "ecschnorr"))]
    Ecschnorr = TpmAlgId::Ecschnorr as u16,
    #[cfg(all(feature = "ecc", feature = "eddsa"))]
    Eddsa = TpmAlgId::Eddsa as u16,
    #[cfg(all(feature = "ecc", feature = "eddsa_ph"))]
    EddsaPh = TpmAlgId::EddsaPh as u16,
    #[cfg(feature = "hmac")]
    Hmac = TpmAlgId::Hmac as u16,
}

impl TpmiAlgSigScheme {
    pub const fn marshalled_size() -> u16 {
        mem::size_of::<u16>() as u16
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u16(buf, *self as u16)
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u16(buf)?;
        let result = Self::try_from(value)?;
        Ok((buf, result))
    }
}

impl convert::TryFrom<u16> for TpmiAlgSigScheme {
    type Error = TpmErr;

    fn try_from(value: u16) -> Result<Self, TpmErr> {
        let result = match value {
            #[cfg(all(feature = "rsa", feature = "rsassa"))]
            value if value == Self::Rsassa as u16 => Self::Rsassa,
            #[cfg(all(feature = "rsa", feature = "rsapss"))]
            value if value == Self::Rsapss as u16 => Self::Rsapss,
            #[cfg(all(feature = "ecc", feature = "ecdsa"))]
            value if value == Self::Ecdsa as u16 => Self::Ecdsa,
            #[cfg(all(feature = "ecc", feature = "ecdaa"))]
            value if value == Self::Ecdaa as u16 => Self::Ecdaa,
            #[cfg(all(feature = "ecc", feature = "sm2"))]
            value if value == Self::Sm2 as u16 => Self::Sm2,
            #[cfg(all(feature = "ecc", feature = "ecschnorr"))]
            value if value == Self::Ecschnorr as u16 => Self::Ecschnorr,
            #[cfg(all(feature = "ecc", feature = "eddsa"))]
            value if value == Self::Eddsa as u16 => Self::Eddsa,
            #[cfg(all(feature = "ecc", feature = "eddsa_ph"))]
            value if value == Self::EddsaPh as u16 => Self::EddsaPh,
            #[cfg(feature = "hmac")]
            value if value == Self::Hmac as u16 => Self::Hmac,
            _ => {
                return Err(TpmErr::Rc(TpmRc::SCHEME));
            },
        };

        Ok(result)
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 129, table 84, TPMI_ALG_SIG_SCHEME type (with conditional values)
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u16)]
pub enum TpmiAlgSigSchemeWCV {
    #[cfg(all(feature = "rsa", feature = "rsassa"))]
    Rsassa = TpmAlgId::Rsassa as u16,
    #[cfg(all(feature = "rsa", feature = "rsapss"))]
    Rsapss = TpmAlgId::Rsapss as u16,
    #[cfg(all(feature = "ecc", feature = "ecdsa"))]
    Ecdsa = TpmAlgId::Ecdsa as u16,
    #[cfg(all(feature = "ecc", feature = "ecdaa"))]
    Ecdaa = TpmAlgId::Ecdaa as u16,
    #[cfg(all(feature = "ecc", feature = "sm2"))]
    Sm2 = TpmAlgId::Sm2 as u16,
    #[cfg(all(feature = "ecc", feature = "ecschnorr"))]
    Ecschnorr = TpmAlgId::Ecschnorr as u16,
    #[cfg(all(feature = "ecc", feature = "eddsa"))]
    Eddsa = TpmAlgId::Eddsa as u16,
    #[cfg(all(feature = "ecc", feature = "eddsa_ph"))]
    EddsaPh = TpmAlgId::EddsaPh as u16,
    #[cfg(feature = "hmac")]
    Hmac = TpmAlgId::Hmac as u16,
    Null = TpmAlgId::Null as u16,
}

impl TpmiAlgSigSchemeWCV {
    pub const fn marshalled_size() -> u16 {
        mem::size_of::<u16>() as u16
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u16(buf, *self as u16)
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u16(buf)?;
        let result = Self::try_from(value)?;
        Ok((buf, result))
    }
}

impl convert::TryFrom<u16> for TpmiAlgSigSchemeWCV {
    type Error = TpmErr;

    fn try_from(value: u16) -> Result<Self, TpmErr> {
        let result = match value {
            #[cfg(all(feature = "rsa", feature = "rsassa"))]
            value if value == Self::Rsassa as u16 => Self::Rsassa,
            #[cfg(all(feature = "rsa", feature = "rsapss"))]
            value if value == Self::Rsapss as u16 => Self::Rsapss,
            #[cfg(all(feature = "ecc", feature = "ecdsa"))]
            value if value == Self::Ecdsa as u16 => Self::Ecdsa,
            #[cfg(all(feature = "ecc", feature = "ecdaa"))]
            value if value == Self::Ecdaa as u16 => Self::Ecdaa,
            #[cfg(all(feature = "ecc", feature = "sm2"))]
            value if value == Self::Sm2 as u16 => Self::Sm2,
            #[cfg(all(feature = "ecc", feature = "ecschnorr"))]
            value if value == Self::Ecschnorr as u16 => Self::Ecschnorr,
            #[cfg(all(feature = "ecc", feature = "eddsa"))]
            value if value == Self::Eddsa as u16 => Self::Eddsa,
            #[cfg(all(feature = "ecc", feature = "eddsa_ph"))]
            value if value == Self::EddsaPh as u16 => Self::EddsaPh,
            #[cfg(feature = "hmac")]
            value if value == Self::Hmac as u16 => Self::Hmac,
            value if value == Self::Null as u16 => Self::Null,
            _ => {
                return Err(TpmErr::Rc(TpmRc::SCHEME));
            },
        };

        Ok(result)
    }
}

impl convert::From<TpmiAlgSigScheme> for TpmiAlgSigSchemeWCV {
    fn from(value: TpmiAlgSigScheme) -> Self {
        match value {
            #[cfg(all(feature = "rsa", feature = "rsassa"))]
            TpmiAlgSigScheme::Rsassa => Self::Rsassa,
            #[cfg(all(feature = "rsa", feature = "rsapss"))]
            TpmiAlgSigScheme::Rsapss => Self::Rsapss,
            #[cfg(all(feature = "ecc", feature = "ecdsa"))]
            TpmiAlgSigScheme::Ecdsa => Self::Ecdsa,
            #[cfg(all(feature = "ecc", feature = "ecdaa"))]
            TpmiAlgSigScheme::Ecdaa => Self::Ecdaa,
            #[cfg(all(feature = "ecc", feature = "sm2"))]
            TpmiAlgSigScheme::Sm2 => Self::Sm2,
            #[cfg(all(feature = "ecc", feature = "ecschnorr"))]
            TpmiAlgSigScheme::Ecschnorr => Self::Ecschnorr,
            #[cfg(all(feature = "ecc", feature = "eddsa"))]
            TpmiAlgSigScheme::Eddsa => Self::Eddsa,
            #[cfg(all(feature = "ecc", feature = "eddsa_ph"))]
            TpmiAlgSigScheme::EddsaPh => Self::EddsaPh,
            #[cfg(feature = "hmac")]
            TpmiAlgSigScheme::Hmac => Self::Hmac,
        }
    }
}

impl convert::TryFrom<TpmiAlgSigSchemeWCV> for TpmiAlgSigScheme {
    type Error = TpmErr;

    fn try_from(value: TpmiAlgSigSchemeWCV) -> Result<Self, TpmErr> {
        let result = match value {
            #[cfg(all(feature = "rsa", feature = "rsassa"))]
            TpmiAlgSigSchemeWCV::Rsassa => Self::Rsassa,
            #[cfg(all(feature = "rsa", feature = "rsapss"))]
            TpmiAlgSigSchemeWCV::Rsapss => Self::Rsapss,
            #[cfg(all(feature = "ecc", feature = "ecdsa"))]
            TpmiAlgSigSchemeWCV::Ecdsa => Self::Ecdsa,
            #[cfg(all(feature = "ecc", feature = "ecdaa"))]
            TpmiAlgSigSchemeWCV::Ecdaa => Self::Ecdaa,
            #[cfg(all(feature = "ecc", feature = "sm2"))]
            TpmiAlgSigSchemeWCV::Sm2 => Self::Sm2,
            #[cfg(all(feature = "ecc", feature = "ecschnorr"))]
            TpmiAlgSigSchemeWCV::Ecschnorr => Self::Ecschnorr,
            #[cfg(all(feature = "ecc", feature = "eddsa"))]
            TpmiAlgSigSchemeWCV::Eddsa => Self::Eddsa,
            #[cfg(all(feature = "ecc", feature = "eddsa_ph"))]
            TpmiAlgSigSchemeWCV::EddsaPh => Self::EddsaPh,
            #[cfg(feature = "hmac")]
            TpmiAlgSigSchemeWCV::Hmac => Self::Hmac,
            TpmiAlgSigSchemeWCV::Null => {
                return Err(TpmErr::Rc(TpmRc::SCHEME));
            },
        };
        Ok(result)
    }
}

impl cmp::PartialEq<TpmiAlgSigScheme> for TpmiAlgSigSchemeWCV {
    fn eq(&self, other: &TpmiAlgSigScheme) -> bool {
        *self as u16 == *other as u16
    }
}

impl cmp::PartialEq<TpmiAlgSigSchemeWCV> for TpmiAlgSigScheme {
    fn eq(&self, other: &TpmiAlgSigSchemeWCV) -> bool {
        other.eq(self)
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 130, table 85, TPMI_ECC_KEY_EXCHANGE type (without conditional values)
#[cfg(feature = "ecc")]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[cfg_attr(any(feature = "ecdh", feature = "ecmqv"), repr(u16))]
pub enum TpmiEccKeyExchange {
    #[cfg(feature = "ecdh")]
    Ecdh = TpmAlgId::Ecdh as u16,
    #[cfg(feature = "ecmqv")]
    Ecmqv = TpmAlgId::Ecmqv as u16,
}

#[cfg(feature = "ecc")]
impl TpmiEccKeyExchange {
    pub const fn marshalled_size() -> u16 {
        mem::size_of::<u16>() as u16
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u16(buf, *self as u16)
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u16(buf)?;
        let result = Self::try_from(value)?;
        Ok((buf, result))
    }
}

#[cfg(feature = "ecc")]
impl convert::TryFrom<u16> for TpmiEccKeyExchange {
    type Error = TpmErr;

    fn try_from(value: u16) -> Result<Self, TpmErr> {
        let result = match value {
            #[cfg(feature = "ecdh")]
            value if value == Self::Ecdh as u16 => Self::Ecdh,
            #[cfg(feature = "ecmqv")]
            value if value == Self::Ecmqv as u16 => Self::Ecmqv,
            _ => {
                return Err(TpmErr::Rc(TpmRc::SCHEME));
            },
        };

        Ok(result)
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 130, table 85, TPMI_ECC_KEY_EXCHANGE type (with conditional values)
#[cfg(feature = "ecc")]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u16)]
pub enum TpmiEccKeyExchangeWCV {
    #[cfg(feature = "ecdh")]
    Ecdh = TpmAlgId::Ecdh as u16,
    #[cfg(feature = "ecmqv")]
    Ecmqv = TpmAlgId::Ecmqv as u16,
    Null = TpmAlgId::Null as u16,
}

#[cfg(feature = "ecc")]
impl TpmiEccKeyExchangeWCV {
    pub const fn marshalled_size() -> u16 {
        mem::size_of::<u16>() as u16
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u16(buf, *self as u16)
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u16(buf)?;
        let result = Self::try_from(value)?;
        Ok((buf, result))
    }
}

#[cfg(feature = "ecc")]
impl convert::TryFrom<u16> for TpmiEccKeyExchangeWCV {
    type Error = TpmErr;

    fn try_from(value: u16) -> Result<Self, TpmErr> {
        let result = match value {
            #[cfg(feature = "ecdh")]
            value if value == Self::Ecdh as u16 => Self::Ecdh,
            #[cfg(feature = "ecmqv")]
            value if value == Self::Ecmqv as u16 => Self::Ecmqv,
            value if value == Self::Null as u16 => Self::Null,
            _ => {
                return Err(TpmErr::Rc(TpmRc::SCHEME));
            },
        };

        Ok(result)
    }
}

#[cfg(feature = "ecc")]
impl convert::From<TpmiEccKeyExchange> for TpmiEccKeyExchangeWCV {
    fn from(value: TpmiEccKeyExchange) -> Self {
        match value {
            #[cfg(feature = "ecdh")]
            TpmiEccKeyExchange::Ecdh => Self::Ecdh,
            #[cfg(feature = "ecmqv")]
            TpmiEccKeyExchange::Ecmqv => Self::Ecmqv,
        }
    }
}

#[cfg(feature = "ecc")]
impl convert::TryFrom<TpmiEccKeyExchangeWCV> for TpmiEccKeyExchange {
    type Error = TpmErr;

    fn try_from(value: TpmiEccKeyExchangeWCV) -> Result<Self, TpmErr> {
        let result = match value {
            #[cfg(feature = "ecdh")]
            TpmiEccKeyExchangeWCV::Ecdh => Self::Ecdh,
            #[cfg(feature = "ecmqv")]
            TpmiEccKeyExchangeWCV::Ecmqv => Self::Ecmqv,
            TpmiEccKeyExchangeWCV::Null => {
                return Err(TpmErr::Rc(TpmRc::SCHEME));
            },
        };
        Ok(result)
    }
}

#[cfg(feature = "ecc")]
impl cmp::PartialEq<TpmiEccKeyExchange> for TpmiEccKeyExchangeWCV {
    fn eq(&self, other: &TpmiEccKeyExchange) -> bool {
        *self as u16 == *other as u16
    }
}

#[cfg(feature = "ecc")]
impl cmp::PartialEq<TpmiEccKeyExchangeWCV> for TpmiEccKeyExchange {
    fn eq(&self, other: &TpmiEccKeyExchangeWCV) -> bool {
        other.eq(self)
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 130, table 86, TPMI_ST_COMMAND_TAG type
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u16)]
pub enum TpmiStCommandTag {
    NoSessions = TpmSt::NoSessions as u16,
    Sessions = TpmSt::Sessions as u16,
}

impl TpmiStCommandTag {
    pub const fn marshalled_size() -> u16 {
        mem::size_of::<u16>() as u16
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u16(buf, *self as u16)
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u16(buf)?;
        let result = Self::try_from(value)?;
        Ok((buf, result))
    }
}

impl convert::TryFrom<u16> for TpmiStCommandTag {
    type Error = TpmErr;

    fn try_from(value: u16) -> Result<Self, TpmErr> {
        let result = match value {
            value if value == Self::NoSessions as u16 => Self::NoSessions,
            value if value == Self::Sessions as u16 => Self::Sessions,
            _ => {
                return Err(TpmErr::Rc(TpmRc::BAD_TAG));
            },
        };

        Ok(result)
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 130, table 87, TPMI_ALG_MAC_SCHEME type (without conditional values)
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[cfg_attr(any(feature = "cmac", feature = "sha1", feature = "sha256", feature = "sha384", feature = "sha3_256", feature = "sha3_384", feature = "sha3_512", feature = "sha512", feature = "sm3_256"), repr(u16))]
pub enum TpmiAlgMacScheme {
    #[cfg(feature = "cmac")]
    Cmac = TpmAlgId::Cmac as u16,
    #[cfg(feature = "sha1")]
    Sha1 = TpmAlgId::Sha1 as u16,
    #[cfg(feature = "sha256")]
    Sha256 = TpmAlgId::Sha256 as u16,
    #[cfg(feature = "sha384")]
    Sha384 = TpmAlgId::Sha384 as u16,
    #[cfg(feature = "sha512")]
    Sha512 = TpmAlgId::Sha512 as u16,
    #[cfg(feature = "sm3_256")]
    Sm3_256 = TpmAlgId::Sm3_256 as u16,
    #[cfg(feature = "sha3_256")]
    Sha3_256 = TpmAlgId::Sha3_256 as u16,
    #[cfg(feature = "sha3_384")]
    Sha3_384 = TpmAlgId::Sha3_384 as u16,
    #[cfg(feature = "sha3_512")]
    Sha3_512 = TpmAlgId::Sha3_512 as u16,
}

impl TpmiAlgMacScheme {
    pub const fn marshalled_size() -> u16 {
        mem::size_of::<u16>() as u16
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u16(buf, *self as u16)
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u16(buf)?;
        let result = Self::try_from(value)?;
        Ok((buf, result))
    }
}

impl convert::TryFrom<u16> for TpmiAlgMacScheme {
    type Error = TpmErr;

    fn try_from(value: u16) -> Result<Self, TpmErr> {
        let result = match value {
            #[cfg(feature = "cmac")]
            value if value == Self::Cmac as u16 => Self::Cmac,
            #[cfg(feature = "sha1")]
            value if value == Self::Sha1 as u16 => Self::Sha1,
            #[cfg(feature = "sha256")]
            value if value == Self::Sha256 as u16 => Self::Sha256,
            #[cfg(feature = "sha384")]
            value if value == Self::Sha384 as u16 => Self::Sha384,
            #[cfg(feature = "sha512")]
            value if value == Self::Sha512 as u16 => Self::Sha512,
            #[cfg(feature = "sm3_256")]
            value if value == Self::Sm3_256 as u16 => Self::Sm3_256,
            #[cfg(feature = "sha3_256")]
            value if value == Self::Sha3_256 as u16 => Self::Sha3_256,
            #[cfg(feature = "sha3_384")]
            value if value == Self::Sha3_384 as u16 => Self::Sha3_384,
            #[cfg(feature = "sha3_512")]
            value if value == Self::Sha3_512 as u16 => Self::Sha3_512,
            _ => {
                return Err(TpmErr::Rc(TpmRc::SYMMETRIC));
            },
        };

        Ok(result)
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 130, table 87, TPMI_ALG_MAC_SCHEME type (with conditional values)
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u16)]
pub enum TpmiAlgMacSchemeWCV {
    #[cfg(feature = "cmac")]
    Cmac = TpmAlgId::Cmac as u16,
    #[cfg(feature = "sha1")]
    Sha1 = TpmAlgId::Sha1 as u16,
    #[cfg(feature = "sha256")]
    Sha256 = TpmAlgId::Sha256 as u16,
    #[cfg(feature = "sha384")]
    Sha384 = TpmAlgId::Sha384 as u16,
    #[cfg(feature = "sha512")]
    Sha512 = TpmAlgId::Sha512 as u16,
    #[cfg(feature = "sm3_256")]
    Sm3_256 = TpmAlgId::Sm3_256 as u16,
    #[cfg(feature = "sha3_256")]
    Sha3_256 = TpmAlgId::Sha3_256 as u16,
    #[cfg(feature = "sha3_384")]
    Sha3_384 = TpmAlgId::Sha3_384 as u16,
    #[cfg(feature = "sha3_512")]
    Sha3_512 = TpmAlgId::Sha3_512 as u16,
    Null = TpmAlgId::Null as u16,
}

impl TpmiAlgMacSchemeWCV {
    pub const fn marshalled_size() -> u16 {
        mem::size_of::<u16>() as u16
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u16(buf, *self as u16)
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u16(buf)?;
        let result = Self::try_from(value)?;
        Ok((buf, result))
    }
}

impl convert::TryFrom<u16> for TpmiAlgMacSchemeWCV {
    type Error = TpmErr;

    fn try_from(value: u16) -> Result<Self, TpmErr> {
        let result = match value {
            #[cfg(feature = "cmac")]
            value if value == Self::Cmac as u16 => Self::Cmac,
            #[cfg(feature = "sha1")]
            value if value == Self::Sha1 as u16 => Self::Sha1,
            #[cfg(feature = "sha256")]
            value if value == Self::Sha256 as u16 => Self::Sha256,
            #[cfg(feature = "sha384")]
            value if value == Self::Sha384 as u16 => Self::Sha384,
            #[cfg(feature = "sha512")]
            value if value == Self::Sha512 as u16 => Self::Sha512,
            #[cfg(feature = "sm3_256")]
            value if value == Self::Sm3_256 as u16 => Self::Sm3_256,
            #[cfg(feature = "sha3_256")]
            value if value == Self::Sha3_256 as u16 => Self::Sha3_256,
            #[cfg(feature = "sha3_384")]
            value if value == Self::Sha3_384 as u16 => Self::Sha3_384,
            #[cfg(feature = "sha3_512")]
            value if value == Self::Sha3_512 as u16 => Self::Sha3_512,
            value if value == Self::Null as u16 => Self::Null,
            _ => {
                return Err(TpmErr::Rc(TpmRc::SYMMETRIC));
            },
        };

        Ok(result)
    }
}

impl convert::From<TpmiAlgMacScheme> for TpmiAlgMacSchemeWCV {
    fn from(value: TpmiAlgMacScheme) -> Self {
        match value {
            #[cfg(feature = "cmac")]
            TpmiAlgMacScheme::Cmac => Self::Cmac,
            #[cfg(feature = "sha1")]
            TpmiAlgMacScheme::Sha1 => Self::Sha1,
            #[cfg(feature = "sha256")]
            TpmiAlgMacScheme::Sha256 => Self::Sha256,
            #[cfg(feature = "sha384")]
            TpmiAlgMacScheme::Sha384 => Self::Sha384,
            #[cfg(feature = "sha512")]
            TpmiAlgMacScheme::Sha512 => Self::Sha512,
            #[cfg(feature = "sm3_256")]
            TpmiAlgMacScheme::Sm3_256 => Self::Sm3_256,
            #[cfg(feature = "sha3_256")]
            TpmiAlgMacScheme::Sha3_256 => Self::Sha3_256,
            #[cfg(feature = "sha3_384")]
            TpmiAlgMacScheme::Sha3_384 => Self::Sha3_384,
            #[cfg(feature = "sha3_512")]
            TpmiAlgMacScheme::Sha3_512 => Self::Sha3_512,
        }
    }
}

impl convert::TryFrom<TpmiAlgMacSchemeWCV> for TpmiAlgMacScheme {
    type Error = TpmErr;

    fn try_from(value: TpmiAlgMacSchemeWCV) -> Result<Self, TpmErr> {
        let result = match value {
            #[cfg(feature = "cmac")]
            TpmiAlgMacSchemeWCV::Cmac => Self::Cmac,
            #[cfg(feature = "sha1")]
            TpmiAlgMacSchemeWCV::Sha1 => Self::Sha1,
            #[cfg(feature = "sha256")]
            TpmiAlgMacSchemeWCV::Sha256 => Self::Sha256,
            #[cfg(feature = "sha384")]
            TpmiAlgMacSchemeWCV::Sha384 => Self::Sha384,
            #[cfg(feature = "sha512")]
            TpmiAlgMacSchemeWCV::Sha512 => Self::Sha512,
            #[cfg(feature = "sm3_256")]
            TpmiAlgMacSchemeWCV::Sm3_256 => Self::Sm3_256,
            #[cfg(feature = "sha3_256")]
            TpmiAlgMacSchemeWCV::Sha3_256 => Self::Sha3_256,
            #[cfg(feature = "sha3_384")]
            TpmiAlgMacSchemeWCV::Sha3_384 => Self::Sha3_384,
            #[cfg(feature = "sha3_512")]
            TpmiAlgMacSchemeWCV::Sha3_512 => Self::Sha3_512,
            TpmiAlgMacSchemeWCV::Null => {
                return Err(TpmErr::Rc(TpmRc::SYMMETRIC));
            },
        };
        Ok(result)
    }
}

impl cmp::PartialEq<TpmiAlgMacScheme> for TpmiAlgMacSchemeWCV {
    fn eq(&self, other: &TpmiAlgMacScheme) -> bool {
        *self as u16 == *other as u16
    }
}

impl cmp::PartialEq<TpmiAlgMacSchemeWCV> for TpmiAlgMacScheme {
    fn eq(&self, other: &TpmiAlgMacSchemeWCV) -> bool {
        other.eq(self)
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 130, table 88, TPMI_ALG_CIPHER_MODE type (without conditional values)
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[cfg_attr(any(feature = "cbc", feature = "cfb", feature = "ctr", feature = "ecb", feature = "ofb"), repr(u16))]
pub enum TpmiAlgCipherMode {
    #[cfg(feature = "ctr")]
    Ctr = TpmAlgId::Ctr as u16,
    #[cfg(feature = "ofb")]
    Ofb = TpmAlgId::Ofb as u16,
    #[cfg(feature = "cbc")]
    Cbc = TpmAlgId::Cbc as u16,
    #[cfg(feature = "cfb")]
    Cfb = TpmAlgId::Cfb as u16,
    #[cfg(feature = "ecb")]
    Ecb = TpmAlgId::Ecb as u16,
}

impl TpmiAlgCipherMode {
    pub const fn marshalled_size() -> u16 {
        mem::size_of::<u16>() as u16
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u16(buf, *self as u16)
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u16(buf)?;
        let result = Self::try_from(value)?;
        Ok((buf, result))
    }
}

impl convert::TryFrom<u16> for TpmiAlgCipherMode {
    type Error = TpmErr;

    fn try_from(value: u16) -> Result<Self, TpmErr> {
        let result = match value {
            #[cfg(feature = "ctr")]
            value if value == Self::Ctr as u16 => Self::Ctr,
            #[cfg(feature = "ofb")]
            value if value == Self::Ofb as u16 => Self::Ofb,
            #[cfg(feature = "cbc")]
            value if value == Self::Cbc as u16 => Self::Cbc,
            #[cfg(feature = "cfb")]
            value if value == Self::Cfb as u16 => Self::Cfb,
            #[cfg(feature = "ecb")]
            value if value == Self::Ecb as u16 => Self::Ecb,
            _ => {
                return Err(TpmErr::Rc(TpmRc::MODE));
            },
        };

        Ok(result)
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 130, table 88, TPMI_ALG_CIPHER_MODE type (with conditional values)
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u16)]
pub enum TpmiAlgCipherModeWCV {
    #[cfg(feature = "ctr")]
    Ctr = TpmAlgId::Ctr as u16,
    #[cfg(feature = "ofb")]
    Ofb = TpmAlgId::Ofb as u16,
    #[cfg(feature = "cbc")]
    Cbc = TpmAlgId::Cbc as u16,
    #[cfg(feature = "cfb")]
    Cfb = TpmAlgId::Cfb as u16,
    #[cfg(feature = "ecb")]
    Ecb = TpmAlgId::Ecb as u16,
    Null = TpmAlgId::Null as u16,
}

impl TpmiAlgCipherModeWCV {
    pub const fn marshalled_size() -> u16 {
        mem::size_of::<u16>() as u16
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u16(buf, *self as u16)
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u16(buf)?;
        let result = Self::try_from(value)?;
        Ok((buf, result))
    }
}

impl convert::TryFrom<u16> for TpmiAlgCipherModeWCV {
    type Error = TpmErr;

    fn try_from(value: u16) -> Result<Self, TpmErr> {
        let result = match value {
            #[cfg(feature = "ctr")]
            value if value == Self::Ctr as u16 => Self::Ctr,
            #[cfg(feature = "ofb")]
            value if value == Self::Ofb as u16 => Self::Ofb,
            #[cfg(feature = "cbc")]
            value if value == Self::Cbc as u16 => Self::Cbc,
            #[cfg(feature = "cfb")]
            value if value == Self::Cfb as u16 => Self::Cfb,
            #[cfg(feature = "ecb")]
            value if value == Self::Ecb as u16 => Self::Ecb,
            value if value == Self::Null as u16 => Self::Null,
            _ => {
                return Err(TpmErr::Rc(TpmRc::MODE));
            },
        };

        Ok(result)
    }
}

impl convert::From<TpmiAlgCipherMode> for TpmiAlgCipherModeWCV {
    fn from(value: TpmiAlgCipherMode) -> Self {
        match value {
            #[cfg(feature = "ctr")]
            TpmiAlgCipherMode::Ctr => Self::Ctr,
            #[cfg(feature = "ofb")]
            TpmiAlgCipherMode::Ofb => Self::Ofb,
            #[cfg(feature = "cbc")]
            TpmiAlgCipherMode::Cbc => Self::Cbc,
            #[cfg(feature = "cfb")]
            TpmiAlgCipherMode::Cfb => Self::Cfb,
            #[cfg(feature = "ecb")]
            TpmiAlgCipherMode::Ecb => Self::Ecb,
        }
    }
}

impl convert::TryFrom<TpmiAlgCipherModeWCV> for TpmiAlgCipherMode {
    type Error = TpmErr;

    fn try_from(value: TpmiAlgCipherModeWCV) -> Result<Self, TpmErr> {
        let result = match value {
            #[cfg(feature = "ctr")]
            TpmiAlgCipherModeWCV::Ctr => Self::Ctr,
            #[cfg(feature = "ofb")]
            TpmiAlgCipherModeWCV::Ofb => Self::Ofb,
            #[cfg(feature = "cbc")]
            TpmiAlgCipherModeWCV::Cbc => Self::Cbc,
            #[cfg(feature = "cfb")]
            TpmiAlgCipherModeWCV::Cfb => Self::Cfb,
            #[cfg(feature = "ecb")]
            TpmiAlgCipherModeWCV::Ecb => Self::Ecb,
            TpmiAlgCipherModeWCV::Null => {
                return Err(TpmErr::Rc(TpmRc::MODE));
            },
        };
        Ok(result)
    }
}

impl cmp::PartialEq<TpmiAlgCipherMode> for TpmiAlgCipherModeWCV {
    fn eq(&self, other: &TpmiAlgCipherMode) -> bool {
        *self as u16 == *other as u16
    }
}

impl cmp::PartialEq<TpmiAlgCipherModeWCV> for TpmiAlgCipherMode {
    fn eq(&self, other: &TpmiAlgCipherModeWCV) -> bool {
        other.eq(self)
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 132, table 89, TPMS_ALGORITHM_DESCRIPTION structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct TpmsAlgorithmDescription {
    pub alg: TpmAlgId,
    pub attributes: TpmaAlgorithm,
}

impl TpmsAlgorithmDescription {
    pub const fn marshalled_size() -> u16 {
        tpms_algorithm_description_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.alg.marshal(buf)?;

        let buf = self.attributes.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_alg) = match TpmAlgId::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_attributes) = match TpmaAlgorithm::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{alg: unmarshalled_alg, attributes: unmarshalled_attributes}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpms_algorithm_description_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmAlgId::marshalled_size();
    size += TpmaAlgorithm::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 132, table 90, TPMU_HA union
struct TpmuHa {}

impl TpmuHa {
    const fn marshalled_max_size() -> u16 {
        let mut size: u16 = 0;

        #[cfg(feature = "sha1")]
        {
            let sha1_size = 20u16;
            if sha1_size > size {
                size = sha1_size;
            }
        }

        #[cfg(feature = "sha256")]
        {
            let sha256_size = 32u16;
            if sha256_size > size {
                size = sha256_size;
            }
        }

        #[cfg(feature = "sha384")]
        {
            let sha384_size = 48u16;
            if sha384_size > size {
                size = sha384_size;
            }
        }

        #[cfg(feature = "sha512")]
        {
            let sha512_size = 64u16;
            if sha512_size > size {
                size = sha512_size;
            }
        }

        #[cfg(feature = "sm3_256")]
        {
            let sm3_256_size = 32u16;
            if sm3_256_size > size {
                size = sm3_256_size;
            }
        }

        #[cfg(feature = "sha3_256")]
        {
            let sha3_256_size = 32u16;
            if sha3_256_size > size {
                size = sha3_256_size;
            }
        }

        #[cfg(feature = "sha3_384")]
        {
            let sha3_384_size = 48u16;
            if sha3_384_size > size {
                size = sha3_384_size;
            }
        }

        #[cfg(feature = "sha3_512")]
        {
            let sha3_512_size = 64u16;
            if sha3_512_size > size {
                size = sha3_512_size;
            }
        }

        size
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 133, table 91, TPMT_HA structure (without conditional values)
#[derive(Debug, PartialEq)]
#[cfg_attr(any(feature = "sha1", feature = "sha256", feature = "sha384", feature = "sha3_256", feature = "sha3_384", feature = "sha3_512", feature = "sha512", feature = "sm3_256"), repr(u16))]
pub enum TpmtHa<'a> {
    #[cfg(feature = "sha1")]
    Sha1(TpmBuffer<'a>) = TpmAlgId::Sha1 as u16,
    #[cfg(feature = "sha256")]
    Sha256(TpmBuffer<'a>) = TpmAlgId::Sha256 as u16,
    #[cfg(feature = "sha384")]
    Sha384(TpmBuffer<'a>) = TpmAlgId::Sha384 as u16,
    #[cfg(feature = "sha512")]
    Sha512(TpmBuffer<'a>) = TpmAlgId::Sha512 as u16,
    #[cfg(feature = "sm3_256")]
    Sm3_256(TpmBuffer<'a>) = TpmAlgId::Sm3_256 as u16,
    #[cfg(feature = "sha3_256")]
    Sha3_256(TpmBuffer<'a>) = TpmAlgId::Sha3_256 as u16,
    #[cfg(feature = "sha3_384")]
    Sha3_384(TpmBuffer<'a>) = TpmAlgId::Sha3_384 as u16,
    #[cfg(feature = "sha3_512")]
    Sha3_512(TpmBuffer<'a>) = TpmAlgId::Sha3_512 as u16,
}

impl<'a> TpmtHa<'a> {
    pub const fn marshalled_max_size() -> u16 {
        tpmt_ha_marshalled_max_size()
    }

    const fn marshalled_selector_size() -> u16 {
        TpmiAlgHash::marshalled_size()
    }

    fn marshalled_data_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;
        match self {
            #[cfg(feature = "sha1")]
            Self::Sha1(_) => {
                let digest_size = match usize::try_from(20u32) {
                    Ok(digest_size) => digest_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(digest_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(feature = "sha256")]
            Self::Sha256(_) => {
                let digest_size = match usize::try_from(32u32) {
                    Ok(digest_size) => digest_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(digest_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(feature = "sha384")]
            Self::Sha384(_) => {
                let digest_size = match usize::try_from(48u32) {
                    Ok(digest_size) => digest_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(digest_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(feature = "sha512")]
            Self::Sha512(_) => {
                let digest_size = match usize::try_from(64u32) {
                    Ok(digest_size) => digest_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(digest_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(feature = "sm3_256")]
            Self::Sm3_256(_) => {
                let digest_size = match usize::try_from(32u32) {
                    Ok(digest_size) => digest_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(digest_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(feature = "sha3_256")]
            Self::Sha3_256(_) => {
                let digest_size = match usize::try_from(32u32) {
                    Ok(digest_size) => digest_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(digest_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(feature = "sha3_384")]
            Self::Sha3_384(_) => {
                let digest_size = match usize::try_from(48u32) {
                    Ok(digest_size) => digest_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(digest_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(feature = "sha3_512")]
            Self::Sha3_512(_) => {
                let digest_size = match usize::try_from(64u32) {
                    Ok(digest_size) => digest_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(digest_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(not(any(feature = "sha1", feature = "sha256", feature = "sha384", feature = "sha3_256", feature = "sha3_384", feature = "sha3_512", feature = "sha512", feature = "sm3_256")))]
            _ => unreachable!(),
        };

        Ok(size)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let selector_size = match usize::try_from(Self::marshalled_selector_size()) {
            Ok(selector_size) => selector_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(selector_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let data_size = match self.marshalled_data_size() {
            Ok(data_size) => data_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(data_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = match self {
            #[cfg(feature = "sha1")]
            Self::Sha1(digest) => {
                let selector = TpmAlgId::Sha1 as u16;
                let buf = marshal_u16(buf, selector)?;

                let expected_digest_size = match usize::try_from(20u32) {
                    Ok(expected_digest_size) => expected_digest_size,
                    Err(_) => {
                        return Err(TpmErr::InternalErr);
                    },
                };
                if digest.len() != expected_digest_size {
                    return Err(TpmErr::Rc(TpmRc::SIZE));
                }
                let buf = marshal_bytes(buf, &digest)?;

                buf
            },
            #[cfg(feature = "sha256")]
            Self::Sha256(digest) => {
                let selector = TpmAlgId::Sha256 as u16;
                let buf = marshal_u16(buf, selector)?;

                let expected_digest_size = match usize::try_from(32u32) {
                    Ok(expected_digest_size) => expected_digest_size,
                    Err(_) => {
                        return Err(TpmErr::InternalErr);
                    },
                };
                if digest.len() != expected_digest_size {
                    return Err(TpmErr::Rc(TpmRc::SIZE));
                }
                let buf = marshal_bytes(buf, &digest)?;

                buf
            },
            #[cfg(feature = "sha384")]
            Self::Sha384(digest) => {
                let selector = TpmAlgId::Sha384 as u16;
                let buf = marshal_u16(buf, selector)?;

                let expected_digest_size = match usize::try_from(48u32) {
                    Ok(expected_digest_size) => expected_digest_size,
                    Err(_) => {
                        return Err(TpmErr::InternalErr);
                    },
                };
                if digest.len() != expected_digest_size {
                    return Err(TpmErr::Rc(TpmRc::SIZE));
                }
                let buf = marshal_bytes(buf, &digest)?;

                buf
            },
            #[cfg(feature = "sha512")]
            Self::Sha512(digest) => {
                let selector = TpmAlgId::Sha512 as u16;
                let buf = marshal_u16(buf, selector)?;

                let expected_digest_size = match usize::try_from(64u32) {
                    Ok(expected_digest_size) => expected_digest_size,
                    Err(_) => {
                        return Err(TpmErr::InternalErr);
                    },
                };
                if digest.len() != expected_digest_size {
                    return Err(TpmErr::Rc(TpmRc::SIZE));
                }
                let buf = marshal_bytes(buf, &digest)?;

                buf
            },
            #[cfg(feature = "sm3_256")]
            Self::Sm3_256(digest) => {
                let selector = TpmAlgId::Sm3_256 as u16;
                let buf = marshal_u16(buf, selector)?;

                let expected_digest_size = match usize::try_from(32u32) {
                    Ok(expected_digest_size) => expected_digest_size,
                    Err(_) => {
                        return Err(TpmErr::InternalErr);
                    },
                };
                if digest.len() != expected_digest_size {
                    return Err(TpmErr::Rc(TpmRc::SIZE));
                }
                let buf = marshal_bytes(buf, &digest)?;

                buf
            },
            #[cfg(feature = "sha3_256")]
            Self::Sha3_256(digest) => {
                let selector = TpmAlgId::Sha3_256 as u16;
                let buf = marshal_u16(buf, selector)?;

                let expected_digest_size = match usize::try_from(32u32) {
                    Ok(expected_digest_size) => expected_digest_size,
                    Err(_) => {
                        return Err(TpmErr::InternalErr);
                    },
                };
                if digest.len() != expected_digest_size {
                    return Err(TpmErr::Rc(TpmRc::SIZE));
                }
                let buf = marshal_bytes(buf, &digest)?;

                buf
            },
            #[cfg(feature = "sha3_384")]
            Self::Sha3_384(digest) => {
                let selector = TpmAlgId::Sha3_384 as u16;
                let buf = marshal_u16(buf, selector)?;

                let expected_digest_size = match usize::try_from(48u32) {
                    Ok(expected_digest_size) => expected_digest_size,
                    Err(_) => {
                        return Err(TpmErr::InternalErr);
                    },
                };
                if digest.len() != expected_digest_size {
                    return Err(TpmErr::Rc(TpmRc::SIZE));
                }
                let buf = marshal_bytes(buf, &digest)?;

                buf
            },
            #[cfg(feature = "sha3_512")]
            Self::Sha3_512(digest) => {
                let selector = TpmAlgId::Sha3_512 as u16;
                let buf = marshal_u16(buf, selector)?;

                let expected_digest_size = match usize::try_from(64u32) {
                    Ok(expected_digest_size) => expected_digest_size,
                    Err(_) => {
                        return Err(TpmErr::InternalErr);
                    },
                };
                if digest.len() != expected_digest_size {
                    return Err(TpmErr::Rc(TpmRc::SIZE));
                }
                let buf = marshal_bytes(buf, &digest)?;

                buf
            },
            #[cfg(not(any(feature = "sha1", feature = "sha256", feature = "sha384", feature = "sha3_256", feature = "sha3_384", feature = "sha3_512", feature = "sha512", feature = "sm3_256")))]
            _ => unreachable!(),
        };
        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_hash_alg) = match unmarshal_u16(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, r) = match unmarshalled_hash_alg {
            #[cfg(feature = "sha1")]
            value if value == TpmAlgId::Sha1 as u16 => {
                let digest_size: u32 = 20u32;
                let digest_size = match usize::try_from(digest_size) {
                    Ok(digest_size) => digest_size,
                    Err(_) => {
                        return Err(TpmErr::Rc(TpmRc::INSUFFICIENT));
                    },
                };
                let (unmarshalled_digest, buf) = match split_slice_at(buf, digest_size) {
                    Ok((unmarshalled_digest, buf)) => (unmarshalled_digest, buf),
                    Err(e) => {
                        return Err(e);
                    },
                };
                let unmarshalled_digest = TpmBuffer::from(unmarshalled_digest);

                (buf, Self::Sha1(unmarshalled_digest))
            },
            #[cfg(feature = "sha256")]
            value if value == TpmAlgId::Sha256 as u16 => {
                let digest_size: u32 = 32u32;
                let digest_size = match usize::try_from(digest_size) {
                    Ok(digest_size) => digest_size,
                    Err(_) => {
                        return Err(TpmErr::Rc(TpmRc::INSUFFICIENT));
                    },
                };
                let (unmarshalled_digest, buf) = match split_slice_at(buf, digest_size) {
                    Ok((unmarshalled_digest, buf)) => (unmarshalled_digest, buf),
                    Err(e) => {
                        return Err(e);
                    },
                };
                let unmarshalled_digest = TpmBuffer::from(unmarshalled_digest);

                (buf, Self::Sha256(unmarshalled_digest))
            },
            #[cfg(feature = "sha384")]
            value if value == TpmAlgId::Sha384 as u16 => {
                let digest_size: u32 = 48u32;
                let digest_size = match usize::try_from(digest_size) {
                    Ok(digest_size) => digest_size,
                    Err(_) => {
                        return Err(TpmErr::Rc(TpmRc::INSUFFICIENT));
                    },
                };
                let (unmarshalled_digest, buf) = match split_slice_at(buf, digest_size) {
                    Ok((unmarshalled_digest, buf)) => (unmarshalled_digest, buf),
                    Err(e) => {
                        return Err(e);
                    },
                };
                let unmarshalled_digest = TpmBuffer::from(unmarshalled_digest);

                (buf, Self::Sha384(unmarshalled_digest))
            },
            #[cfg(feature = "sha512")]
            value if value == TpmAlgId::Sha512 as u16 => {
                let digest_size: u32 = 64u32;
                let digest_size = match usize::try_from(digest_size) {
                    Ok(digest_size) => digest_size,
                    Err(_) => {
                        return Err(TpmErr::Rc(TpmRc::INSUFFICIENT));
                    },
                };
                let (unmarshalled_digest, buf) = match split_slice_at(buf, digest_size) {
                    Ok((unmarshalled_digest, buf)) => (unmarshalled_digest, buf),
                    Err(e) => {
                        return Err(e);
                    },
                };
                let unmarshalled_digest = TpmBuffer::from(unmarshalled_digest);

                (buf, Self::Sha512(unmarshalled_digest))
            },
            #[cfg(feature = "sm3_256")]
            value if value == TpmAlgId::Sm3_256 as u16 => {
                let digest_size: u32 = 32u32;
                let digest_size = match usize::try_from(digest_size) {
                    Ok(digest_size) => digest_size,
                    Err(_) => {
                        return Err(TpmErr::Rc(TpmRc::INSUFFICIENT));
                    },
                };
                let (unmarshalled_digest, buf) = match split_slice_at(buf, digest_size) {
                    Ok((unmarshalled_digest, buf)) => (unmarshalled_digest, buf),
                    Err(e) => {
                        return Err(e);
                    },
                };
                let unmarshalled_digest = TpmBuffer::from(unmarshalled_digest);

                (buf, Self::Sm3_256(unmarshalled_digest))
            },
            #[cfg(feature = "sha3_256")]
            value if value == TpmAlgId::Sha3_256 as u16 => {
                let digest_size: u32 = 32u32;
                let digest_size = match usize::try_from(digest_size) {
                    Ok(digest_size) => digest_size,
                    Err(_) => {
                        return Err(TpmErr::Rc(TpmRc::INSUFFICIENT));
                    },
                };
                let (unmarshalled_digest, buf) = match split_slice_at(buf, digest_size) {
                    Ok((unmarshalled_digest, buf)) => (unmarshalled_digest, buf),
                    Err(e) => {
                        return Err(e);
                    },
                };
                let unmarshalled_digest = TpmBuffer::from(unmarshalled_digest);

                (buf, Self::Sha3_256(unmarshalled_digest))
            },
            #[cfg(feature = "sha3_384")]
            value if value == TpmAlgId::Sha3_384 as u16 => {
                let digest_size: u32 = 48u32;
                let digest_size = match usize::try_from(digest_size) {
                    Ok(digest_size) => digest_size,
                    Err(_) => {
                        return Err(TpmErr::Rc(TpmRc::INSUFFICIENT));
                    },
                };
                let (unmarshalled_digest, buf) = match split_slice_at(buf, digest_size) {
                    Ok((unmarshalled_digest, buf)) => (unmarshalled_digest, buf),
                    Err(e) => {
                        return Err(e);
                    },
                };
                let unmarshalled_digest = TpmBuffer::from(unmarshalled_digest);

                (buf, Self::Sha3_384(unmarshalled_digest))
            },
            #[cfg(feature = "sha3_512")]
            value if value == TpmAlgId::Sha3_512 as u16 => {
                let digest_size: u32 = 64u32;
                let digest_size = match usize::try_from(digest_size) {
                    Ok(digest_size) => digest_size,
                    Err(_) => {
                        return Err(TpmErr::Rc(TpmRc::INSUFFICIENT));
                    },
                };
                let (unmarshalled_digest, buf) = match split_slice_at(buf, digest_size) {
                    Ok((unmarshalled_digest, buf)) => (unmarshalled_digest, buf),
                    Err(e) => {
                        return Err(e);
                    },
                };
                let unmarshalled_digest = TpmBuffer::from(unmarshalled_digest);

                (buf, Self::Sha3_512(unmarshalled_digest))
            },
            _ => {
                return Err(TpmErr::Rc(TpmRc::HASH));
            },
        };

        Ok((buf, r))
    }

    pub fn unmarshal(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<TpmtHa<'static>, TpmErr> {
        match self {
            #[cfg(feature = "sha1")]
            Self::Sha1(digest) => {
                let digest_orig = digest;
                let digest = copy_vec_from_slice(digest_orig)?;
                let digest = TpmBuffer::Owned(digest);

                Ok(TpmtHa::Sha1(
                    digest,
                ))
            },
            #[cfg(feature = "sha256")]
            Self::Sha256(digest) => {
                let digest_orig = digest;
                let digest = copy_vec_from_slice(digest_orig)?;
                let digest = TpmBuffer::Owned(digest);

                Ok(TpmtHa::Sha256(
                    digest,
                ))
            },
            #[cfg(feature = "sha384")]
            Self::Sha384(digest) => {
                let digest_orig = digest;
                let digest = copy_vec_from_slice(digest_orig)?;
                let digest = TpmBuffer::Owned(digest);

                Ok(TpmtHa::Sha384(
                    digest,
                ))
            },
            #[cfg(feature = "sha512")]
            Self::Sha512(digest) => {
                let digest_orig = digest;
                let digest = copy_vec_from_slice(digest_orig)?;
                let digest = TpmBuffer::Owned(digest);

                Ok(TpmtHa::Sha512(
                    digest,
                ))
            },
            #[cfg(feature = "sm3_256")]
            Self::Sm3_256(digest) => {
                let digest_orig = digest;
                let digest = copy_vec_from_slice(digest_orig)?;
                let digest = TpmBuffer::Owned(digest);

                Ok(TpmtHa::Sm3_256(
                    digest,
                ))
            },
            #[cfg(feature = "sha3_256")]
            Self::Sha3_256(digest) => {
                let digest_orig = digest;
                let digest = copy_vec_from_slice(digest_orig)?;
                let digest = TpmBuffer::Owned(digest);

                Ok(TpmtHa::Sha3_256(
                    digest,
                ))
            },
            #[cfg(feature = "sha3_384")]
            Self::Sha3_384(digest) => {
                let digest_orig = digest;
                let digest = copy_vec_from_slice(digest_orig)?;
                let digest = TpmBuffer::Owned(digest);

                Ok(TpmtHa::Sha3_384(
                    digest,
                ))
            },
            #[cfg(feature = "sha3_512")]
            Self::Sha3_512(digest) => {
                let digest_orig = digest;
                let digest = copy_vec_from_slice(digest_orig)?;
                let digest = TpmBuffer::Owned(digest);

                Ok(TpmtHa::Sha3_512(
                    digest,
                ))
            },
            #[cfg(not(any(feature = "sha1", feature = "sha256", feature = "sha384", feature = "sha3_256", feature = "sha3_384", feature = "sha3_512", feature = "sha512", feature = "sm3_256")))]
            _ => unreachable!(),
        }
    }

    pub fn try_clone(&self) -> Result<Box<TpmtHa<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<TpmtHa<'static>, TpmErr> {
        match self {
            #[cfg(feature = "sha1")]
            Self::Sha1(digest) => {
                let digest = digest.into_owned()?;
                Ok(TpmtHa::Sha1(digest))
            },
            #[cfg(feature = "sha256")]
            Self::Sha256(digest) => {
                let digest = digest.into_owned()?;
                Ok(TpmtHa::Sha256(digest))
            },
            #[cfg(feature = "sha384")]
            Self::Sha384(digest) => {
                let digest = digest.into_owned()?;
                Ok(TpmtHa::Sha384(digest))
            },
            #[cfg(feature = "sha512")]
            Self::Sha512(digest) => {
                let digest = digest.into_owned()?;
                Ok(TpmtHa::Sha512(digest))
            },
            #[cfg(feature = "sm3_256")]
            Self::Sm3_256(digest) => {
                let digest = digest.into_owned()?;
                Ok(TpmtHa::Sm3_256(digest))
            },
            #[cfg(feature = "sha3_256")]
            Self::Sha3_256(digest) => {
                let digest = digest.into_owned()?;
                Ok(TpmtHa::Sha3_256(digest))
            },
            #[cfg(feature = "sha3_384")]
            Self::Sha3_384(digest) => {
                let digest = digest.into_owned()?;
                Ok(TpmtHa::Sha3_384(digest))
            },
            #[cfg(feature = "sha3_512")]
            Self::Sha3_512(digest) => {
                let digest = digest.into_owned()?;
                Ok(TpmtHa::Sha3_512(digest))
            },
            #[cfg(not(any(feature = "sha1", feature = "sha256", feature = "sha384", feature = "sha3_256", feature = "sha3_384", feature = "sha3_512", feature = "sha512", feature = "sm3_256")))]
            _ => unreachable!(),
        }
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<TpmtHa<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

const fn tpmt_ha_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiAlgHash::marshalled_size();
    size += TpmuHa::marshalled_max_size();

    size
}

impl<'a> convert::From<&TpmtHa<'a>> for TpmiAlgHash {
    fn from(value: &TpmtHa<'a>) -> Self {
        match value {
            #[cfg(feature = "sha1")]
            TpmtHa::Sha1(_) => Self::Sha1,
            #[cfg(feature = "sha256")]
            TpmtHa::Sha256(_) => Self::Sha256,
            #[cfg(feature = "sha384")]
            TpmtHa::Sha384(_) => Self::Sha384,
            #[cfg(feature = "sha512")]
            TpmtHa::Sha512(_) => Self::Sha512,
            #[cfg(feature = "sm3_256")]
            TpmtHa::Sm3_256(_) => Self::Sm3_256,
            #[cfg(feature = "sha3_256")]
            TpmtHa::Sha3_256(_) => Self::Sha3_256,
            #[cfg(feature = "sha3_384")]
            TpmtHa::Sha3_384(_) => Self::Sha3_384,
            #[cfg(feature = "sha3_512")]
            TpmtHa::Sha3_512(_) => Self::Sha3_512,
            #[cfg(not(any(feature = "sha1", feature = "sha256", feature = "sha384", feature = "sha3_256", feature = "sha3_384", feature = "sha3_512", feature = "sha512", feature = "sm3_256")))]
            _ => unreachable!(),
        }
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 133, table 91, TPMT_HA structure (with conditional values)
#[derive(Debug, PartialEq)]
#[repr(u16)]
pub enum TpmtHaWCV<'a> {
    #[cfg(feature = "sha1")]
    Sha1(TpmBuffer<'a>) = TpmAlgId::Sha1 as u16,
    #[cfg(feature = "sha256")]
    Sha256(TpmBuffer<'a>) = TpmAlgId::Sha256 as u16,
    #[cfg(feature = "sha384")]
    Sha384(TpmBuffer<'a>) = TpmAlgId::Sha384 as u16,
    #[cfg(feature = "sha512")]
    Sha512(TpmBuffer<'a>) = TpmAlgId::Sha512 as u16,
    #[cfg(feature = "sm3_256")]
    Sm3_256(TpmBuffer<'a>) = TpmAlgId::Sm3_256 as u16,
    #[cfg(feature = "sha3_256")]
    Sha3_256(TpmBuffer<'a>) = TpmAlgId::Sha3_256 as u16,
    #[cfg(feature = "sha3_384")]
    Sha3_384(TpmBuffer<'a>) = TpmAlgId::Sha3_384 as u16,
    #[cfg(feature = "sha3_512")]
    Sha3_512(TpmBuffer<'a>) = TpmAlgId::Sha3_512 as u16,
    Null = TpmAlgId::Null as u16,
}

impl<'a> TpmtHaWCV<'a> {
    pub const fn marshalled_max_size() -> u16 {
        tpmt_ha_wcv_marshalled_max_size()
    }

    const fn marshalled_selector_size() -> u16 {
        TpmiAlgHashWCV::marshalled_size()
    }

    fn marshalled_data_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;
        match self {
            #[cfg(feature = "sha1")]
            Self::Sha1(_) => {
                let digest_size = match usize::try_from(20u32) {
                    Ok(digest_size) => digest_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(digest_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(feature = "sha256")]
            Self::Sha256(_) => {
                let digest_size = match usize::try_from(32u32) {
                    Ok(digest_size) => digest_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(digest_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(feature = "sha384")]
            Self::Sha384(_) => {
                let digest_size = match usize::try_from(48u32) {
                    Ok(digest_size) => digest_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(digest_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(feature = "sha512")]
            Self::Sha512(_) => {
                let digest_size = match usize::try_from(64u32) {
                    Ok(digest_size) => digest_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(digest_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(feature = "sm3_256")]
            Self::Sm3_256(_) => {
                let digest_size = match usize::try_from(32u32) {
                    Ok(digest_size) => digest_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(digest_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(feature = "sha3_256")]
            Self::Sha3_256(_) => {
                let digest_size = match usize::try_from(32u32) {
                    Ok(digest_size) => digest_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(digest_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(feature = "sha3_384")]
            Self::Sha3_384(_) => {
                let digest_size = match usize::try_from(48u32) {
                    Ok(digest_size) => digest_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(digest_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(feature = "sha3_512")]
            Self::Sha3_512(_) => {
                let digest_size = match usize::try_from(64u32) {
                    Ok(digest_size) => digest_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(digest_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            Self::Null => (),
        };

        Ok(size)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let selector_size = match usize::try_from(Self::marshalled_selector_size()) {
            Ok(selector_size) => selector_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(selector_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let data_size = match self.marshalled_data_size() {
            Ok(data_size) => data_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(data_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = match self {
            #[cfg(feature = "sha1")]
            Self::Sha1(digest) => {
                let selector = TpmAlgId::Sha1 as u16;
                let buf = marshal_u16(buf, selector)?;

                let expected_digest_size = match usize::try_from(20u32) {
                    Ok(expected_digest_size) => expected_digest_size,
                    Err(_) => {
                        return Err(TpmErr::InternalErr);
                    },
                };
                if digest.len() != expected_digest_size {
                    return Err(TpmErr::Rc(TpmRc::SIZE));
                }
                let buf = marshal_bytes(buf, &digest)?;

                buf
            },
            #[cfg(feature = "sha256")]
            Self::Sha256(digest) => {
                let selector = TpmAlgId::Sha256 as u16;
                let buf = marshal_u16(buf, selector)?;

                let expected_digest_size = match usize::try_from(32u32) {
                    Ok(expected_digest_size) => expected_digest_size,
                    Err(_) => {
                        return Err(TpmErr::InternalErr);
                    },
                };
                if digest.len() != expected_digest_size {
                    return Err(TpmErr::Rc(TpmRc::SIZE));
                }
                let buf = marshal_bytes(buf, &digest)?;

                buf
            },
            #[cfg(feature = "sha384")]
            Self::Sha384(digest) => {
                let selector = TpmAlgId::Sha384 as u16;
                let buf = marshal_u16(buf, selector)?;

                let expected_digest_size = match usize::try_from(48u32) {
                    Ok(expected_digest_size) => expected_digest_size,
                    Err(_) => {
                        return Err(TpmErr::InternalErr);
                    },
                };
                if digest.len() != expected_digest_size {
                    return Err(TpmErr::Rc(TpmRc::SIZE));
                }
                let buf = marshal_bytes(buf, &digest)?;

                buf
            },
            #[cfg(feature = "sha512")]
            Self::Sha512(digest) => {
                let selector = TpmAlgId::Sha512 as u16;
                let buf = marshal_u16(buf, selector)?;

                let expected_digest_size = match usize::try_from(64u32) {
                    Ok(expected_digest_size) => expected_digest_size,
                    Err(_) => {
                        return Err(TpmErr::InternalErr);
                    },
                };
                if digest.len() != expected_digest_size {
                    return Err(TpmErr::Rc(TpmRc::SIZE));
                }
                let buf = marshal_bytes(buf, &digest)?;

                buf
            },
            #[cfg(feature = "sm3_256")]
            Self::Sm3_256(digest) => {
                let selector = TpmAlgId::Sm3_256 as u16;
                let buf = marshal_u16(buf, selector)?;

                let expected_digest_size = match usize::try_from(32u32) {
                    Ok(expected_digest_size) => expected_digest_size,
                    Err(_) => {
                        return Err(TpmErr::InternalErr);
                    },
                };
                if digest.len() != expected_digest_size {
                    return Err(TpmErr::Rc(TpmRc::SIZE));
                }
                let buf = marshal_bytes(buf, &digest)?;

                buf
            },
            #[cfg(feature = "sha3_256")]
            Self::Sha3_256(digest) => {
                let selector = TpmAlgId::Sha3_256 as u16;
                let buf = marshal_u16(buf, selector)?;

                let expected_digest_size = match usize::try_from(32u32) {
                    Ok(expected_digest_size) => expected_digest_size,
                    Err(_) => {
                        return Err(TpmErr::InternalErr);
                    },
                };
                if digest.len() != expected_digest_size {
                    return Err(TpmErr::Rc(TpmRc::SIZE));
                }
                let buf = marshal_bytes(buf, &digest)?;

                buf
            },
            #[cfg(feature = "sha3_384")]
            Self::Sha3_384(digest) => {
                let selector = TpmAlgId::Sha3_384 as u16;
                let buf = marshal_u16(buf, selector)?;

                let expected_digest_size = match usize::try_from(48u32) {
                    Ok(expected_digest_size) => expected_digest_size,
                    Err(_) => {
                        return Err(TpmErr::InternalErr);
                    },
                };
                if digest.len() != expected_digest_size {
                    return Err(TpmErr::Rc(TpmRc::SIZE));
                }
                let buf = marshal_bytes(buf, &digest)?;

                buf
            },
            #[cfg(feature = "sha3_512")]
            Self::Sha3_512(digest) => {
                let selector = TpmAlgId::Sha3_512 as u16;
                let buf = marshal_u16(buf, selector)?;

                let expected_digest_size = match usize::try_from(64u32) {
                    Ok(expected_digest_size) => expected_digest_size,
                    Err(_) => {
                        return Err(TpmErr::InternalErr);
                    },
                };
                if digest.len() != expected_digest_size {
                    return Err(TpmErr::Rc(TpmRc::SIZE));
                }
                let buf = marshal_bytes(buf, &digest)?;

                buf
            },
            Self::Null => {
                let selector = TpmAlgId::Null as u16;
                let buf = marshal_u16(buf, selector)?;

                buf
            },
        };
        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_hash_alg) = match unmarshal_u16(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, r) = match unmarshalled_hash_alg {
            #[cfg(feature = "sha1")]
            value if value == TpmAlgId::Sha1 as u16 => {
                let digest_size: u32 = 20u32;
                let digest_size = match usize::try_from(digest_size) {
                    Ok(digest_size) => digest_size,
                    Err(_) => {
                        return Err(TpmErr::Rc(TpmRc::INSUFFICIENT));
                    },
                };
                let (unmarshalled_digest, buf) = match split_slice_at(buf, digest_size) {
                    Ok((unmarshalled_digest, buf)) => (unmarshalled_digest, buf),
                    Err(e) => {
                        return Err(e);
                    },
                };
                let unmarshalled_digest = TpmBuffer::from(unmarshalled_digest);

                (buf, Self::Sha1(unmarshalled_digest))
            },
            #[cfg(feature = "sha256")]
            value if value == TpmAlgId::Sha256 as u16 => {
                let digest_size: u32 = 32u32;
                let digest_size = match usize::try_from(digest_size) {
                    Ok(digest_size) => digest_size,
                    Err(_) => {
                        return Err(TpmErr::Rc(TpmRc::INSUFFICIENT));
                    },
                };
                let (unmarshalled_digest, buf) = match split_slice_at(buf, digest_size) {
                    Ok((unmarshalled_digest, buf)) => (unmarshalled_digest, buf),
                    Err(e) => {
                        return Err(e);
                    },
                };
                let unmarshalled_digest = TpmBuffer::from(unmarshalled_digest);

                (buf, Self::Sha256(unmarshalled_digest))
            },
            #[cfg(feature = "sha384")]
            value if value == TpmAlgId::Sha384 as u16 => {
                let digest_size: u32 = 48u32;
                let digest_size = match usize::try_from(digest_size) {
                    Ok(digest_size) => digest_size,
                    Err(_) => {
                        return Err(TpmErr::Rc(TpmRc::INSUFFICIENT));
                    },
                };
                let (unmarshalled_digest, buf) = match split_slice_at(buf, digest_size) {
                    Ok((unmarshalled_digest, buf)) => (unmarshalled_digest, buf),
                    Err(e) => {
                        return Err(e);
                    },
                };
                let unmarshalled_digest = TpmBuffer::from(unmarshalled_digest);

                (buf, Self::Sha384(unmarshalled_digest))
            },
            #[cfg(feature = "sha512")]
            value if value == TpmAlgId::Sha512 as u16 => {
                let digest_size: u32 = 64u32;
                let digest_size = match usize::try_from(digest_size) {
                    Ok(digest_size) => digest_size,
                    Err(_) => {
                        return Err(TpmErr::Rc(TpmRc::INSUFFICIENT));
                    },
                };
                let (unmarshalled_digest, buf) = match split_slice_at(buf, digest_size) {
                    Ok((unmarshalled_digest, buf)) => (unmarshalled_digest, buf),
                    Err(e) => {
                        return Err(e);
                    },
                };
                let unmarshalled_digest = TpmBuffer::from(unmarshalled_digest);

                (buf, Self::Sha512(unmarshalled_digest))
            },
            #[cfg(feature = "sm3_256")]
            value if value == TpmAlgId::Sm3_256 as u16 => {
                let digest_size: u32 = 32u32;
                let digest_size = match usize::try_from(digest_size) {
                    Ok(digest_size) => digest_size,
                    Err(_) => {
                        return Err(TpmErr::Rc(TpmRc::INSUFFICIENT));
                    },
                };
                let (unmarshalled_digest, buf) = match split_slice_at(buf, digest_size) {
                    Ok((unmarshalled_digest, buf)) => (unmarshalled_digest, buf),
                    Err(e) => {
                        return Err(e);
                    },
                };
                let unmarshalled_digest = TpmBuffer::from(unmarshalled_digest);

                (buf, Self::Sm3_256(unmarshalled_digest))
            },
            #[cfg(feature = "sha3_256")]
            value if value == TpmAlgId::Sha3_256 as u16 => {
                let digest_size: u32 = 32u32;
                let digest_size = match usize::try_from(digest_size) {
                    Ok(digest_size) => digest_size,
                    Err(_) => {
                        return Err(TpmErr::Rc(TpmRc::INSUFFICIENT));
                    },
                };
                let (unmarshalled_digest, buf) = match split_slice_at(buf, digest_size) {
                    Ok((unmarshalled_digest, buf)) => (unmarshalled_digest, buf),
                    Err(e) => {
                        return Err(e);
                    },
                };
                let unmarshalled_digest = TpmBuffer::from(unmarshalled_digest);

                (buf, Self::Sha3_256(unmarshalled_digest))
            },
            #[cfg(feature = "sha3_384")]
            value if value == TpmAlgId::Sha3_384 as u16 => {
                let digest_size: u32 = 48u32;
                let digest_size = match usize::try_from(digest_size) {
                    Ok(digest_size) => digest_size,
                    Err(_) => {
                        return Err(TpmErr::Rc(TpmRc::INSUFFICIENT));
                    },
                };
                let (unmarshalled_digest, buf) = match split_slice_at(buf, digest_size) {
                    Ok((unmarshalled_digest, buf)) => (unmarshalled_digest, buf),
                    Err(e) => {
                        return Err(e);
                    },
                };
                let unmarshalled_digest = TpmBuffer::from(unmarshalled_digest);

                (buf, Self::Sha3_384(unmarshalled_digest))
            },
            #[cfg(feature = "sha3_512")]
            value if value == TpmAlgId::Sha3_512 as u16 => {
                let digest_size: u32 = 64u32;
                let digest_size = match usize::try_from(digest_size) {
                    Ok(digest_size) => digest_size,
                    Err(_) => {
                        return Err(TpmErr::Rc(TpmRc::INSUFFICIENT));
                    },
                };
                let (unmarshalled_digest, buf) = match split_slice_at(buf, digest_size) {
                    Ok((unmarshalled_digest, buf)) => (unmarshalled_digest, buf),
                    Err(e) => {
                        return Err(e);
                    },
                };
                let unmarshalled_digest = TpmBuffer::from(unmarshalled_digest);

                (buf, Self::Sha3_512(unmarshalled_digest))
            },
            value if value == TpmAlgId::Null as u16 => {
                (buf, Self::Null)
            },
            _ => {
                return Err(TpmErr::Rc(TpmRc::HASH));
            },
        };

        Ok((buf, r))
    }

    pub fn unmarshal(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<TpmtHaWCV<'static>, TpmErr> {
        match self {
            #[cfg(feature = "sha1")]
            Self::Sha1(digest) => {
                let digest_orig = digest;
                let digest = copy_vec_from_slice(digest_orig)?;
                let digest = TpmBuffer::Owned(digest);

                Ok(TpmtHaWCV::Sha1(
                    digest,
                ))
            },
            #[cfg(feature = "sha256")]
            Self::Sha256(digest) => {
                let digest_orig = digest;
                let digest = copy_vec_from_slice(digest_orig)?;
                let digest = TpmBuffer::Owned(digest);

                Ok(TpmtHaWCV::Sha256(
                    digest,
                ))
            },
            #[cfg(feature = "sha384")]
            Self::Sha384(digest) => {
                let digest_orig = digest;
                let digest = copy_vec_from_slice(digest_orig)?;
                let digest = TpmBuffer::Owned(digest);

                Ok(TpmtHaWCV::Sha384(
                    digest,
                ))
            },
            #[cfg(feature = "sha512")]
            Self::Sha512(digest) => {
                let digest_orig = digest;
                let digest = copy_vec_from_slice(digest_orig)?;
                let digest = TpmBuffer::Owned(digest);

                Ok(TpmtHaWCV::Sha512(
                    digest,
                ))
            },
            #[cfg(feature = "sm3_256")]
            Self::Sm3_256(digest) => {
                let digest_orig = digest;
                let digest = copy_vec_from_slice(digest_orig)?;
                let digest = TpmBuffer::Owned(digest);

                Ok(TpmtHaWCV::Sm3_256(
                    digest,
                ))
            },
            #[cfg(feature = "sha3_256")]
            Self::Sha3_256(digest) => {
                let digest_orig = digest;
                let digest = copy_vec_from_slice(digest_orig)?;
                let digest = TpmBuffer::Owned(digest);

                Ok(TpmtHaWCV::Sha3_256(
                    digest,
                ))
            },
            #[cfg(feature = "sha3_384")]
            Self::Sha3_384(digest) => {
                let digest_orig = digest;
                let digest = copy_vec_from_slice(digest_orig)?;
                let digest = TpmBuffer::Owned(digest);

                Ok(TpmtHaWCV::Sha3_384(
                    digest,
                ))
            },
            #[cfg(feature = "sha3_512")]
            Self::Sha3_512(digest) => {
                let digest_orig = digest;
                let digest = copy_vec_from_slice(digest_orig)?;
                let digest = TpmBuffer::Owned(digest);

                Ok(TpmtHaWCV::Sha3_512(
                    digest,
                ))
            },
            Self::Null => Ok(TpmtHaWCV::Null),
        }
    }

    pub fn try_clone(&self) -> Result<Box<TpmtHaWCV<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<TpmtHaWCV<'static>, TpmErr> {
        match self {
            #[cfg(feature = "sha1")]
            Self::Sha1(digest) => {
                let digest = digest.into_owned()?;
                Ok(TpmtHaWCV::Sha1(digest))
            },
            #[cfg(feature = "sha256")]
            Self::Sha256(digest) => {
                let digest = digest.into_owned()?;
                Ok(TpmtHaWCV::Sha256(digest))
            },
            #[cfg(feature = "sha384")]
            Self::Sha384(digest) => {
                let digest = digest.into_owned()?;
                Ok(TpmtHaWCV::Sha384(digest))
            },
            #[cfg(feature = "sha512")]
            Self::Sha512(digest) => {
                let digest = digest.into_owned()?;
                Ok(TpmtHaWCV::Sha512(digest))
            },
            #[cfg(feature = "sm3_256")]
            Self::Sm3_256(digest) => {
                let digest = digest.into_owned()?;
                Ok(TpmtHaWCV::Sm3_256(digest))
            },
            #[cfg(feature = "sha3_256")]
            Self::Sha3_256(digest) => {
                let digest = digest.into_owned()?;
                Ok(TpmtHaWCV::Sha3_256(digest))
            },
            #[cfg(feature = "sha3_384")]
            Self::Sha3_384(digest) => {
                let digest = digest.into_owned()?;
                Ok(TpmtHaWCV::Sha3_384(digest))
            },
            #[cfg(feature = "sha3_512")]
            Self::Sha3_512(digest) => {
                let digest = digest.into_owned()?;
                Ok(TpmtHaWCV::Sha3_512(digest))
            },
            Self::Null => Ok(TpmtHaWCV::Null),
        }
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<TpmtHaWCV<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

const fn tpmt_ha_wcv_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiAlgHashWCV::marshalled_size();
    size += TpmuHa::marshalled_max_size();

    size
}

impl<'a> convert::From<&TpmtHaWCV<'a>> for TpmiAlgHashWCV {
    fn from(value: &TpmtHaWCV<'a>) -> Self {
        match value {
            #[cfg(feature = "sha1")]
            TpmtHaWCV::Sha1(_) => Self::Sha1,
            #[cfg(feature = "sha256")]
            TpmtHaWCV::Sha256(_) => Self::Sha256,
            #[cfg(feature = "sha384")]
            TpmtHaWCV::Sha384(_) => Self::Sha384,
            #[cfg(feature = "sha512")]
            TpmtHaWCV::Sha512(_) => Self::Sha512,
            #[cfg(feature = "sm3_256")]
            TpmtHaWCV::Sm3_256(_) => Self::Sm3_256,
            #[cfg(feature = "sha3_256")]
            TpmtHaWCV::Sha3_256(_) => Self::Sha3_256,
            #[cfg(feature = "sha3_384")]
            TpmtHaWCV::Sha3_384(_) => Self::Sha3_384,
            #[cfg(feature = "sha3_512")]
            TpmtHaWCV::Sha3_512(_) => Self::Sha3_512,
            TpmtHaWCV::Null => Self::Null,
        }
    }
}

impl<'a> convert::From<TpmtHa<'a>> for TpmtHaWCV<'a> {
    fn from(value: TpmtHa<'a>) -> Self {
        match value {
            #[cfg(feature = "sha1")]
            TpmtHa::Sha1(digest) => Self::Sha1(digest),
            #[cfg(feature = "sha256")]
            TpmtHa::Sha256(digest) => Self::Sha256(digest),
            #[cfg(feature = "sha384")]
            TpmtHa::Sha384(digest) => Self::Sha384(digest),
            #[cfg(feature = "sha512")]
            TpmtHa::Sha512(digest) => Self::Sha512(digest),
            #[cfg(feature = "sm3_256")]
            TpmtHa::Sm3_256(digest) => Self::Sm3_256(digest),
            #[cfg(feature = "sha3_256")]
            TpmtHa::Sha3_256(digest) => Self::Sha3_256(digest),
            #[cfg(feature = "sha3_384")]
            TpmtHa::Sha3_384(digest) => Self::Sha3_384(digest),
            #[cfg(feature = "sha3_512")]
            TpmtHa::Sha3_512(digest) => Self::Sha3_512(digest),
            #[cfg(not(any(feature = "sha1", feature = "sha256", feature = "sha384", feature = "sha3_256", feature = "sha3_384", feature = "sha3_512", feature = "sha512", feature = "sm3_256")))]
            _ => unreachable!(),
        }
    }
}

impl<'a> convert::TryFrom<TpmtHaWCV<'a>> for TpmtHa<'a> {
    type Error = TpmErr;

    fn try_from(value: TpmtHaWCV<'a>) -> Result<Self, TpmErr> {
        let result = match value {
            #[cfg(feature = "sha1")]
            TpmtHaWCV::Sha1(digest) => Self::Sha1(digest),
            #[cfg(feature = "sha256")]
            TpmtHaWCV::Sha256(digest) => Self::Sha256(digest),
            #[cfg(feature = "sha384")]
            TpmtHaWCV::Sha384(digest) => Self::Sha384(digest),
            #[cfg(feature = "sha512")]
            TpmtHaWCV::Sha512(digest) => Self::Sha512(digest),
            #[cfg(feature = "sm3_256")]
            TpmtHaWCV::Sm3_256(digest) => Self::Sm3_256(digest),
            #[cfg(feature = "sha3_256")]
            TpmtHaWCV::Sha3_256(digest) => Self::Sha3_256(digest),
            #[cfg(feature = "sha3_384")]
            TpmtHaWCV::Sha3_384(digest) => Self::Sha3_384(digest),
            #[cfg(feature = "sha3_512")]
            TpmtHaWCV::Sha3_512(digest) => Self::Sha3_512(digest),
            _ => {
                return Err(TpmErr::Rc(TpmRc::HASH));
            },
        };

        Ok(result)
    }
}

impl<'a> cmp::PartialEq<TpmtHa<'a>> for TpmtHaWCV<'a> {
    fn eq(&self, other: &TpmtHa<'a>) -> bool {
        match self {
            #[cfg(feature = "sha1")]
            Self::Sha1(self_digest) => {
                if let TpmtHa::Sha1(other_digest) = other {
                    self_digest == other_digest
                } else {
                    false
                }
            },
            #[cfg(feature = "sha256")]
            Self::Sha256(self_digest) => {
                if let TpmtHa::Sha256(other_digest) = other {
                    self_digest == other_digest
                } else {
                    false
                }
            },
            #[cfg(feature = "sha384")]
            Self::Sha384(self_digest) => {
                if let TpmtHa::Sha384(other_digest) = other {
                    self_digest == other_digest
                } else {
                    false
                }
            },
            #[cfg(feature = "sha512")]
            Self::Sha512(self_digest) => {
                if let TpmtHa::Sha512(other_digest) = other {
                    self_digest == other_digest
                } else {
                    false
                }
            },
            #[cfg(feature = "sm3_256")]
            Self::Sm3_256(self_digest) => {
                if let TpmtHa::Sm3_256(other_digest) = other {
                    self_digest == other_digest
                } else {
                    false
                }
            },
            #[cfg(feature = "sha3_256")]
            Self::Sha3_256(self_digest) => {
                if let TpmtHa::Sha3_256(other_digest) = other {
                    self_digest == other_digest
                } else {
                    false
                }
            },
            #[cfg(feature = "sha3_384")]
            Self::Sha3_384(self_digest) => {
                if let TpmtHa::Sha3_384(other_digest) = other {
                    self_digest == other_digest
                } else {
                    false
                }
            },
            #[cfg(feature = "sha3_512")]
            Self::Sha3_512(self_digest) => {
                if let TpmtHa::Sha3_512(other_digest) = other {
                    self_digest == other_digest
                } else {
                    false
                }
            },
            _ => false,
        }
    }
}

impl<'a> cmp::PartialEq<TpmtHaWCV<'a>> for TpmtHa<'a> {
    fn eq(&self, other: &TpmtHaWCV<'a>) -> bool {
        other.eq(self)
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 134, table 92, TPM2B_DIGEST structure
#[derive(Debug, PartialEq)]
pub struct Tpm2bDigest<'a> {
    pub buffer: TpmBuffer<'a>,
}

impl<'a> Tpm2bDigest<'a> {
    pub const fn marshalled_max_size() -> u16 {
        tpm2b_digest_marshalled_max_size()
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let size_size = mem::size_of::<u16>();
        size = match size.checked_add(size_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let buffer_size = self.buffer.len();
        size = match size.checked_add(buffer_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let marshalled_size = match u16::try_from(self.buffer.len()) {
            Ok(marshalled_size) => marshalled_size,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::SIZE));
            },
        };
        let buf = marshal_u16(buf, marshalled_size)?;

        let buf = marshal_bytes(buf, &self.buffer)?;

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_size) = match unmarshal_u16(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let buffer_size: u16 = unmarshalled_size;
        if buffer_size > TpmuHa::marshalled_max_size() {
            return Err(TpmErr::Rc(TpmRc::SIZE));
        }
        let buffer_size = match usize::try_from(buffer_size) {
            Ok(buffer_size) => buffer_size,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::INSUFFICIENT));
            },
        };
        let (unmarshalled_buffer, buf) = match split_slice_at(buf, buffer_size) {
            Ok((unmarshalled_buffer, buf)) => (unmarshalled_buffer, buf),
            Err(e) => {
                return Err(e);
            },
        };
        let unmarshalled_buffer = TpmBuffer::from(unmarshalled_buffer);

        Ok((buf, Self{buffer: unmarshalled_buffer}))
    }

    pub fn unmarshal(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2bDigest<'static>, TpmErr> {
        let buffer = copy_vec_from_slice(&self.buffer)?;
        let buffer = TpmBuffer::Owned(buffer);

        Ok(Tpm2bDigest {
            buffer,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2bDigest<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2bDigest<'static>, TpmErr> {
        let Self {
            buffer,
        } = self;

        let buffer = buffer.into_owned()?;

        Ok(Tpm2bDigest {
            buffer,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2bDigest<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

const fn tpm2b_digest_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += mem::size_of::<u16>() as u16;
    size += TpmuHa::marshalled_max_size();

    size
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 134, table 93, TPM2B_DATA structure
#[derive(Debug, PartialEq)]
pub struct Tpm2bData<'a> {
    pub buffer: TpmBuffer<'a>,
}

impl<'a> Tpm2bData<'a> {
    pub const fn marshalled_max_size() -> u16 {
        tpm2b_data_marshalled_max_size()
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let size_size = mem::size_of::<u16>();
        size = match size.checked_add(size_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let buffer_size = self.buffer.len();
        size = match size.checked_add(buffer_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let marshalled_size = match u16::try_from(self.buffer.len()) {
            Ok(marshalled_size) => marshalled_size,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::SIZE));
            },
        };
        let buf = marshal_u16(buf, marshalled_size)?;

        let buf = marshal_bytes(buf, &self.buffer)?;

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_size) = match unmarshal_u16(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let buffer_size: u16 = unmarshalled_size;
        if buffer_size > tpmt_ha_marshalled_max_size() {
            return Err(TpmErr::Rc(TpmRc::SIZE));
        }
        let buffer_size = match usize::try_from(buffer_size) {
            Ok(buffer_size) => buffer_size,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::INSUFFICIENT));
            },
        };
        let (unmarshalled_buffer, buf) = match split_slice_at(buf, buffer_size) {
            Ok((unmarshalled_buffer, buf)) => (unmarshalled_buffer, buf),
            Err(e) => {
                return Err(e);
            },
        };
        let unmarshalled_buffer = TpmBuffer::from(unmarshalled_buffer);

        Ok((buf, Self{buffer: unmarshalled_buffer}))
    }

    pub fn unmarshal(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2bData<'static>, TpmErr> {
        let buffer = copy_vec_from_slice(&self.buffer)?;
        let buffer = TpmBuffer::Owned(buffer);

        Ok(Tpm2bData {
            buffer,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2bData<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2bData<'static>, TpmErr> {
        let Self {
            buffer,
        } = self;

        let buffer = buffer.into_owned()?;

        Ok(Tpm2bData {
            buffer,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2bData<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

const fn tpm2b_data_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += mem::size_of::<u16>() as u16;
    size += tpmt_ha_marshalled_max_size();

    size
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 135, table 97, TPM2B_EVENT structure
#[derive(Debug, PartialEq)]
pub struct Tpm2bEvent<'a> {
    pub buffer: TpmBuffer<'a>,
}

impl<'a> Tpm2bEvent<'a> {
    pub const fn marshalled_max_size() -> u16 {
        tpm2b_event_marshalled_max_size()
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let size_size = mem::size_of::<u16>();
        size = match size.checked_add(size_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let buffer_size = self.buffer.len();
        size = match size.checked_add(buffer_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let marshalled_size = match u16::try_from(self.buffer.len()) {
            Ok(marshalled_size) => marshalled_size,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::SIZE));
            },
        };
        let buf = marshal_u16(buf, marshalled_size)?;

        let buf = marshal_bytes(buf, &self.buffer)?;

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_size) = match unmarshal_u16(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let buffer_size: u16 = unmarshalled_size;
        if buffer_size > 1024u16 {
            return Err(TpmErr::Rc(TpmRc::SIZE));
        }
        let buffer_size = match usize::try_from(buffer_size) {
            Ok(buffer_size) => buffer_size,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::INSUFFICIENT));
            },
        };
        let (unmarshalled_buffer, buf) = match split_slice_at(buf, buffer_size) {
            Ok((unmarshalled_buffer, buf)) => (unmarshalled_buffer, buf),
            Err(e) => {
                return Err(e);
            },
        };
        let unmarshalled_buffer = TpmBuffer::from(unmarshalled_buffer);

        Ok((buf, Self{buffer: unmarshalled_buffer}))
    }

    pub fn unmarshal(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2bEvent<'static>, TpmErr> {
        let buffer = copy_vec_from_slice(&self.buffer)?;
        let buffer = TpmBuffer::Owned(buffer);

        Ok(Tpm2bEvent {
            buffer,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2bEvent<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2bEvent<'static>, TpmErr> {
        let Self {
            buffer,
        } = self;

        let buffer = buffer.into_owned()?;

        Ok(Tpm2bEvent {
            buffer,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2bEvent<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

const fn tpm2b_event_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += mem::size_of::<u16>() as u16;
    size += 1024u16;

    size
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 135, table 98, TPM2B_MAX_BUFFER structure
#[derive(Debug, PartialEq)]
pub struct Tpm2bMaxBuffer<'a> {
    pub buffer: TpmBuffer<'a>,
}

impl<'a> Tpm2bMaxBuffer<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2b_max_buffer_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let size_size = mem::size_of::<u16>();
        size = match size.checked_add(size_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let buffer_size = self.buffer.len();
        size = match size.checked_add(buffer_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let marshalled_size = match u16::try_from(self.buffer.len()) {
            Ok(marshalled_size) => marshalled_size,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::SIZE));
            },
        };
        let buf = marshal_u16(buf, marshalled_size)?;

        let buf = marshal_bytes(buf, &self.buffer)?;

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_size) = match unmarshal_u16(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let buffer_size: u16 = unmarshalled_size;
        if buffer_size > limits.max_2b_buffer_size {
            return Err(TpmErr::Rc(TpmRc::SIZE));
        }
        let buffer_size = match usize::try_from(buffer_size) {
            Ok(buffer_size) => buffer_size,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::INSUFFICIENT));
            },
        };
        let (unmarshalled_buffer, buf) = match split_slice_at(buf, buffer_size) {
            Ok((unmarshalled_buffer, buf)) => (unmarshalled_buffer, buf),
            Err(e) => {
                return Err(e);
            },
        };
        let unmarshalled_buffer = TpmBuffer::from(unmarshalled_buffer);

        Ok((buf, Self{buffer: unmarshalled_buffer}))
    }

    pub fn unmarshal(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2bMaxBuffer<'static>, TpmErr> {
        let buffer = copy_vec_from_slice(&self.buffer)?;
        let buffer = TpmBuffer::Owned(buffer);

        Ok(Tpm2bMaxBuffer {
            buffer,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2bMaxBuffer<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2bMaxBuffer<'static>, TpmErr> {
        let Self {
            buffer,
        } = self;

        let buffer = buffer.into_owned()?;

        Ok(Tpm2bMaxBuffer {
            buffer,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2bMaxBuffer<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpm2b_max_buffer_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    size += mem::size_of::<u16>() as u32;

    let buffer_size = limits.max_2b_buffer_size as u32;
    size = size.checked_add(buffer_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 136, table 99, TPM2B_MAX_NV_BUFFER structure
#[derive(Debug, PartialEq)]
pub struct Tpm2bMaxNvBuffer<'a> {
    pub buffer: TpmBuffer<'a>,
}

impl<'a> Tpm2bMaxNvBuffer<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2b_max_nv_buffer_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let size_size = mem::size_of::<u16>();
        size = match size.checked_add(size_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let buffer_size = self.buffer.len();
        size = match size.checked_add(buffer_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let marshalled_size = match u16::try_from(self.buffer.len()) {
            Ok(marshalled_size) => marshalled_size,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::SIZE));
            },
        };
        let buf = marshal_u16(buf, marshalled_size)?;

        let buf = marshal_bytes(buf, &self.buffer)?;

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_size) = match unmarshal_u16(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let buffer_size: u16 = unmarshalled_size;
        if buffer_size > limits.max_nv_buffer_size {
            return Err(TpmErr::Rc(TpmRc::SIZE));
        }
        let buffer_size = match usize::try_from(buffer_size) {
            Ok(buffer_size) => buffer_size,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::INSUFFICIENT));
            },
        };
        let (unmarshalled_buffer, buf) = match split_slice_at(buf, buffer_size) {
            Ok((unmarshalled_buffer, buf)) => (unmarshalled_buffer, buf),
            Err(e) => {
                return Err(e);
            },
        };
        let unmarshalled_buffer = TpmBuffer::from(unmarshalled_buffer);

        Ok((buf, Self{buffer: unmarshalled_buffer}))
    }

    pub fn unmarshal(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2bMaxNvBuffer<'static>, TpmErr> {
        let buffer = copy_vec_from_slice(&self.buffer)?;
        let buffer = TpmBuffer::Owned(buffer);

        Ok(Tpm2bMaxNvBuffer {
            buffer,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2bMaxNvBuffer<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2bMaxNvBuffer<'static>, TpmErr> {
        let Self {
            buffer,
        } = self;

        let buffer = buffer.into_owned()?;

        Ok(Tpm2bMaxNvBuffer {
            buffer,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2bMaxNvBuffer<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpm2b_max_nv_buffer_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    size += mem::size_of::<u16>() as u32;

    let buffer_size = limits.max_nv_buffer_size as u32;
    size = size.checked_add(buffer_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 136, table 100, TPM2B_TIMEOUT structure
#[derive(Debug, PartialEq)]
pub struct Tpm2bTimeout<'a> {
    pub buffer: TpmBuffer<'a>,
}

impl<'a> Tpm2bTimeout<'a> {
    pub const fn marshalled_max_size() -> u16 {
        tpm2b_timeout_marshalled_max_size()
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let size_size = mem::size_of::<u16>();
        size = match size.checked_add(size_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let buffer_size = self.buffer.len();
        size = match size.checked_add(buffer_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let marshalled_size = match u16::try_from(self.buffer.len()) {
            Ok(marshalled_size) => marshalled_size,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::SIZE));
            },
        };
        let buf = marshal_u16(buf, marshalled_size)?;

        let buf = marshal_bytes(buf, &self.buffer)?;

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_size) = match unmarshal_u16(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let buffer_size: u16 = unmarshalled_size;
        if buffer_size > mem::size_of::<u64>() as u16 {
            return Err(TpmErr::Rc(TpmRc::SIZE));
        }
        let buffer_size = match usize::try_from(buffer_size) {
            Ok(buffer_size) => buffer_size,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::INSUFFICIENT));
            },
        };
        let (unmarshalled_buffer, buf) = match split_slice_at(buf, buffer_size) {
            Ok((unmarshalled_buffer, buf)) => (unmarshalled_buffer, buf),
            Err(e) => {
                return Err(e);
            },
        };
        let unmarshalled_buffer = TpmBuffer::from(unmarshalled_buffer);

        Ok((buf, Self{buffer: unmarshalled_buffer}))
    }

    pub fn unmarshal(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2bTimeout<'static>, TpmErr> {
        let buffer = copy_vec_from_slice(&self.buffer)?;
        let buffer = TpmBuffer::Owned(buffer);

        Ok(Tpm2bTimeout {
            buffer,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2bTimeout<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2bTimeout<'static>, TpmErr> {
        let Self {
            buffer,
        } = self;

        let buffer = buffer.into_owned()?;

        Ok(Tpm2bTimeout {
            buffer,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2bTimeout<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

const fn tpm2b_timeout_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += mem::size_of::<u16>() as u16;
    size += mem::size_of::<u64>() as u16;

    size
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 136, table 101, TPM2B_IV structure
#[derive(Debug, PartialEq)]
pub struct Tpm2bIv<'a> {
    pub buffer: TpmBuffer<'a>,
}

impl<'a> Tpm2bIv<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2b_iv_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let size_size = mem::size_of::<u16>();
        size = match size.checked_add(size_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let buffer_size = self.buffer.len();
        size = match size.checked_add(buffer_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let marshalled_size = match u16::try_from(self.buffer.len()) {
            Ok(marshalled_size) => marshalled_size,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::SIZE));
            },
        };
        let buf = marshal_u16(buf, marshalled_size)?;

        let buf = marshal_bytes(buf, &self.buffer)?;

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_size) = match unmarshal_u16(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let buffer_size: u16 = unmarshalled_size;
        let v0 = match limits.max_sym_block_size() {
            Ok(v) => v,
            Err(_) => {
                debug_assert!(false, "Unexpected runtime constant evaluation failure");
                return Err(TpmErr::InternalErr);
            },
        };
        if buffer_size > v0 {
            return Err(TpmErr::Rc(TpmRc::SIZE));
        }
        let buffer_size = match usize::try_from(buffer_size) {
            Ok(buffer_size) => buffer_size,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::INSUFFICIENT));
            },
        };
        let (unmarshalled_buffer, buf) = match split_slice_at(buf, buffer_size) {
            Ok((unmarshalled_buffer, buf)) => (unmarshalled_buffer, buf),
            Err(e) => {
                return Err(e);
            },
        };
        let unmarshalled_buffer = TpmBuffer::from(unmarshalled_buffer);

        Ok((buf, Self{buffer: unmarshalled_buffer}))
    }

    pub fn unmarshal(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2bIv<'static>, TpmErr> {
        let buffer = copy_vec_from_slice(&self.buffer)?;
        let buffer = TpmBuffer::Owned(buffer);

        Ok(Tpm2bIv {
            buffer,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2bIv<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2bIv<'static>, TpmErr> {
        let Self {
            buffer,
        } = self;

        let buffer = buffer.into_owned()?;

        Ok(Tpm2bIv {
            buffer,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2bIv<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpm2b_iv_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    size += mem::size_of::<u16>() as u32;

    let v0 = match limits.max_sym_block_size() {
        Ok(v) => v,
        Err(_) => {
            debug_assert!(false, "Unexpected runtime constant evaluation failure");
            return Err(());
        },
    };
    let buffer_size = v0 as u32;
    size = size.checked_add(buffer_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 137, table 102, TPM2B_VENDOR_PROPERTY structure
#[derive(Debug, PartialEq)]
pub struct Tpm2bVendorProperty<'a> {
    pub buffer: TpmBuffer<'a>,
}

impl<'a> Tpm2bVendorProperty<'a> {
    pub const fn marshalled_max_size() -> u16 {
        tpm2b_vendor_property_marshalled_max_size()
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let size_size = mem::size_of::<u16>();
        size = match size.checked_add(size_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let buffer_size = self.buffer.len();
        size = match size.checked_add(buffer_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let marshalled_size = match u16::try_from(self.buffer.len()) {
            Ok(marshalled_size) => marshalled_size,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::SIZE));
            },
        };
        let buf = marshal_u16(buf, marshalled_size)?;

        let buf = marshal_bytes(buf, &self.buffer)?;

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_size) = match unmarshal_u16(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let buffer_size: u16 = unmarshalled_size;
        if buffer_size > 512u16 {
            return Err(TpmErr::Rc(TpmRc::SIZE));
        }
        let buffer_size = match usize::try_from(buffer_size) {
            Ok(buffer_size) => buffer_size,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::INSUFFICIENT));
            },
        };
        let (unmarshalled_buffer, buf) = match split_slice_at(buf, buffer_size) {
            Ok((unmarshalled_buffer, buf)) => (unmarshalled_buffer, buf),
            Err(e) => {
                return Err(e);
            },
        };
        let unmarshalled_buffer = TpmBuffer::from(unmarshalled_buffer);

        Ok((buf, Self{buffer: unmarshalled_buffer}))
    }

    pub fn unmarshal(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2bVendorProperty<'static>, TpmErr> {
        let buffer = copy_vec_from_slice(&self.buffer)?;
        let buffer = TpmBuffer::Owned(buffer);

        Ok(Tpm2bVendorProperty {
            buffer,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2bVendorProperty<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2bVendorProperty<'static>, TpmErr> {
        let Self {
            buffer,
        } = self;

        let buffer = buffer.into_owned()?;

        Ok(Tpm2bVendorProperty {
            buffer,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2bVendorProperty<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

const fn tpm2b_vendor_property_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += mem::size_of::<u16>() as u16;
    size += 512u16;

    size
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 137, table 103, TPMU_NAME union
struct TpmuName {}

impl TpmuName {
    const fn marshalled_max_size() -> u16 {
        let mut size: u16 = 0;

        let digest_size = tpmt_ha_marshalled_max_size();
        if digest_size > size {
            size = digest_size;
        }

        let handle_size = mem::size_of::<u32>() as u16;
        if handle_size > size {
            size = handle_size;
        }

        size
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 137, table 104, TPM2B_NAME structure
#[derive(Debug, PartialEq)]
pub struct Tpm2bName<'a> {
    pub name: TpmBuffer<'a>,
}

impl<'a> Tpm2bName<'a> {
    pub const fn marshalled_max_size() -> u16 {
        tpm2b_name_marshalled_max_size()
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let size_size = mem::size_of::<u16>();
        size = match size.checked_add(size_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let name_size = self.name.len();
        size = match size.checked_add(name_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let marshalled_size = match u16::try_from(self.name.len()) {
            Ok(marshalled_size) => marshalled_size,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::SIZE));
            },
        };
        let buf = marshal_u16(buf, marshalled_size)?;

        let buf = marshal_bytes(buf, &self.name)?;

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_size) = match unmarshal_u16(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let name_size: u16 = unmarshalled_size;
        if name_size > TpmuName::marshalled_max_size() {
            return Err(TpmErr::Rc(TpmRc::SIZE));
        }
        let name_size = match usize::try_from(name_size) {
            Ok(name_size) => name_size,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::INSUFFICIENT));
            },
        };
        let (unmarshalled_name, buf) = match split_slice_at(buf, name_size) {
            Ok((unmarshalled_name, buf)) => (unmarshalled_name, buf),
            Err(e) => {
                return Err(e);
            },
        };
        let unmarshalled_name = TpmBuffer::from(unmarshalled_name);

        Ok((buf, Self{name: unmarshalled_name}))
    }

    pub fn unmarshal(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2bName<'static>, TpmErr> {
        let name = copy_vec_from_slice(&self.name)?;
        let name = TpmBuffer::Owned(name);

        Ok(Tpm2bName {
            name,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2bName<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2bName<'static>, TpmErr> {
        let Self {
            name,
        } = self;

        let name = name.into_owned()?;

        Ok(Tpm2bName {
            name,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2bName<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

const fn tpm2b_name_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += mem::size_of::<u16>() as u16;
    size += TpmuName::marshalled_max_size();

    size
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 139, table 105, TPMS_PCR_SELECT structure
#[derive(Debug, PartialEq)]
pub struct TpmsPcrSelect<'a> {
    pub pcr_select: TpmBuffer<'a>,
}

impl<'a> TpmsPcrSelect<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpms_pcr_select_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let sizeof_select_size = mem::size_of::<u8>();
        size = match size.checked_add(sizeof_select_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let pcr_select_size = self.pcr_select.len();
        size = match size.checked_add(pcr_select_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let marshalled_sizeof_select = match u8::try_from(self.pcr_select.len()) {
            Ok(marshalled_sizeof_select) => marshalled_sizeof_select,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::SIZE));
            },
        };
        let buf = marshal_u8(buf, marshalled_sizeof_select)?;

        let buf = marshal_bytes(buf, &self.pcr_select)?;

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_sizeof_select) = match unmarshal_u8(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let v0 = match limits.pcr_select_min() {
            Ok(v) => v,
            Err(_) => {
                debug_assert!(false, "Unexpected runtime constant evaluation failure");
                return Err(TpmErr::InternalErr);
            },
        };
        if unmarshalled_sizeof_select < v0 {
            return Err(TpmErr::Rc(TpmRc::VALUE));
        }

        let pcr_select_size: u8 = unmarshalled_sizeof_select;
        let v0 = match limits.pcr_select_max() {
            Ok(v) => v,
            Err(_) => {
                debug_assert!(false, "Unexpected runtime constant evaluation failure");
                return Err(TpmErr::InternalErr);
            },
        };
        if pcr_select_size > v0 {
            return Err(TpmErr::Rc(TpmRc::VALUE));
        }
        let pcr_select_size = match usize::try_from(pcr_select_size) {
            Ok(pcr_select_size) => pcr_select_size,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::INSUFFICIENT));
            },
        };
        let (unmarshalled_pcr_select, buf) = match split_slice_at(buf, pcr_select_size) {
            Ok((unmarshalled_pcr_select, buf)) => (unmarshalled_pcr_select, buf),
            Err(e) => {
                return Err(e);
            },
        };
        let unmarshalled_pcr_select = TpmBuffer::from(unmarshalled_pcr_select);

        Ok((buf, Self{pcr_select: unmarshalled_pcr_select}))
    }

    pub fn unmarshal(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<TpmsPcrSelect<'static>, TpmErr> {
        let pcr_select = copy_vec_from_slice(&self.pcr_select)?;
        let pcr_select = TpmBuffer::Owned(pcr_select);

        Ok(TpmsPcrSelect {
            pcr_select,
        })
    }

    pub fn try_clone(&self) -> Result<Box<TpmsPcrSelect<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<TpmsPcrSelect<'static>, TpmErr> {
        let Self {
            pcr_select,
        } = self;

        let pcr_select = pcr_select.into_owned()?;

        Ok(TpmsPcrSelect {
            pcr_select,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<TpmsPcrSelect<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpms_pcr_select_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    size += mem::size_of::<u8>() as u32;

    let v0 = match limits.pcr_select_max() {
        Ok(v) => v,
        Err(_) => {
            debug_assert!(false, "Unexpected runtime constant evaluation failure");
            return Err(());
        },
    };
    let pcr_select_size = v0 as u32;
    size = size.checked_add(pcr_select_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 139, table 106, TPMS_PCR_SELECTION structure
#[derive(Debug, PartialEq)]
pub struct TpmsPcrSelection<'a> {
    pub hash: TpmiAlgHash,
    pub pcr_select: TpmBuffer<'a>,
}

impl<'a> TpmsPcrSelection<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpms_pcr_selection_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let hash_size = match usize::try_from(TpmiAlgHash::marshalled_size()) {
            Ok(hash_size) => hash_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(hash_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let sizeof_select_size = mem::size_of::<u8>();
        size = match size.checked_add(sizeof_select_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let pcr_select_size = self.pcr_select.len();
        size = match size.checked_add(pcr_select_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.hash.marshal(buf)?;

        let marshalled_sizeof_select = match u8::try_from(self.pcr_select.len()) {
            Ok(marshalled_sizeof_select) => marshalled_sizeof_select,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::SIZE));
            },
        };
        let buf = marshal_u8(buf, marshalled_sizeof_select)?;

        let buf = marshal_bytes(buf, &self.pcr_select)?;

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_hash) = match TpmiAlgHash::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_sizeof_select) = match unmarshal_u8(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let v0 = match limits.pcr_select_min() {
            Ok(v) => v,
            Err(_) => {
                debug_assert!(false, "Unexpected runtime constant evaluation failure");
                return Err(TpmErr::InternalErr);
            },
        };
        if unmarshalled_sizeof_select < v0 {
            return Err(TpmErr::Rc(TpmRc::VALUE));
        }

        let pcr_select_size: u8 = unmarshalled_sizeof_select;
        let v0 = match limits.pcr_select_max() {
            Ok(v) => v,
            Err(_) => {
                debug_assert!(false, "Unexpected runtime constant evaluation failure");
                return Err(TpmErr::InternalErr);
            },
        };
        if pcr_select_size > v0 {
            return Err(TpmErr::Rc(TpmRc::VALUE));
        }
        let pcr_select_size = match usize::try_from(pcr_select_size) {
            Ok(pcr_select_size) => pcr_select_size,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::INSUFFICIENT));
            },
        };
        let (unmarshalled_pcr_select, buf) = match split_slice_at(buf, pcr_select_size) {
            Ok((unmarshalled_pcr_select, buf)) => (unmarshalled_pcr_select, buf),
            Err(e) => {
                return Err(e);
            },
        };
        let unmarshalled_pcr_select = TpmBuffer::from(unmarshalled_pcr_select);

        Ok((buf, Self{hash: unmarshalled_hash, pcr_select: unmarshalled_pcr_select}))
    }

    pub fn unmarshal(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<TpmsPcrSelection<'static>, TpmErr> {
        let pcr_select = copy_vec_from_slice(&self.pcr_select)?;
        let pcr_select = TpmBuffer::Owned(pcr_select);

        Ok(TpmsPcrSelection {
            hash: self.hash,
            pcr_select,
        })
    }

    pub fn try_clone(&self) -> Result<Box<TpmsPcrSelection<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<TpmsPcrSelection<'static>, TpmErr> {
        let Self {
            hash,
            pcr_select,
        } = self;

        let pcr_select = pcr_select.into_owned()?;

        Ok(TpmsPcrSelection {
            hash,
            pcr_select,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<TpmsPcrSelection<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpms_pcr_selection_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    size += TpmiAlgHash::marshalled_size() as u32;
    size += mem::size_of::<u8>() as u32;

    let v0 = match limits.pcr_select_max() {
        Ok(v) => v,
        Err(_) => {
            debug_assert!(false, "Unexpected runtime constant evaluation failure");
            return Err(());
        },
    };
    let pcr_select_size = v0 as u32;
    size = size.checked_add(pcr_select_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 141, table 109, TPMT_TK_CREATION structure
#[derive(Debug, PartialEq)]
pub struct TpmtTkCreation<'a> {
    pub tag: TpmSt,
    pub hierarchy: TpmiRhHierarchy,
    pub digest: Tpm2bDigest<'a>,
}

impl<'a> TpmtTkCreation<'a> {
    pub const fn marshalled_max_size() -> u16 {
        tpmt_tk_creation_marshalled_max_size()
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let tag_size = match usize::try_from(TpmSt::marshalled_size()) {
            Ok(tag_size) => tag_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(tag_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let hierarchy_size = match usize::try_from(TpmiRhHierarchy::marshalled_size()) {
            Ok(hierarchy_size) => hierarchy_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(hierarchy_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let digest_size = match self.digest.marshalled_size() {
            Ok(digest_size) => digest_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(digest_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.tag.marshal(buf)?;

        let buf = self.hierarchy.marshal(buf)?;

        let buf = self.digest.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_tag) = match TpmSt::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        if unmarshalled_tag as u16 != TpmSt::Creation as u16 {
            return Err(TpmErr::Rc(TpmRc::TAG));
        }

        let (buf, unmarshalled_hierarchy) = match TpmiRhHierarchy::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_digest) = match Tpm2bDigest::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{tag: unmarshalled_tag, hierarchy: unmarshalled_hierarchy, digest: unmarshalled_digest}))
    }

    pub fn unmarshal(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<TpmtTkCreation<'static>, TpmErr> {
        Ok(TpmtTkCreation {
            tag: self.tag,
            hierarchy: self.hierarchy,
            digest: self.digest.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<TpmtTkCreation<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<TpmtTkCreation<'static>, TpmErr> {
        let Self {
            tag,
            hierarchy,
            digest,
        } = self;

        let digest = digest.into_bufs_owner_intern()?;

        Ok(TpmtTkCreation {
            tag,
            hierarchy,
            digest,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<TpmtTkCreation<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

const fn tpmt_tk_creation_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmSt::marshalled_size();
    size += TpmiRhHierarchy::marshalled_size();
    size += tpm2b_digest_marshalled_max_size();

    size
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 141, table 110, TPMT_TK_VERIFIED structure
#[derive(Debug, PartialEq)]
pub struct TpmtTkVerified<'a> {
    pub tag: TpmSt,
    pub hierarchy: TpmiRhHierarchy,
    pub digest: Tpm2bDigest<'a>,
}

impl<'a> TpmtTkVerified<'a> {
    pub const fn marshalled_max_size() -> u16 {
        tpmt_tk_verified_marshalled_max_size()
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let tag_size = match usize::try_from(TpmSt::marshalled_size()) {
            Ok(tag_size) => tag_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(tag_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let hierarchy_size = match usize::try_from(TpmiRhHierarchy::marshalled_size()) {
            Ok(hierarchy_size) => hierarchy_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(hierarchy_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let digest_size = match self.digest.marshalled_size() {
            Ok(digest_size) => digest_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(digest_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.tag.marshal(buf)?;

        let buf = self.hierarchy.marshal(buf)?;

        let buf = self.digest.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_tag) = match TpmSt::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        if unmarshalled_tag as u16 != TpmSt::Verified as u16 {
            return Err(TpmErr::Rc(TpmRc::TAG));
        }

        let (buf, unmarshalled_hierarchy) = match TpmiRhHierarchy::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_digest) = match Tpm2bDigest::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{tag: unmarshalled_tag, hierarchy: unmarshalled_hierarchy, digest: unmarshalled_digest}))
    }

    pub fn unmarshal(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<TpmtTkVerified<'static>, TpmErr> {
        Ok(TpmtTkVerified {
            tag: self.tag,
            hierarchy: self.hierarchy,
            digest: self.digest.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<TpmtTkVerified<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<TpmtTkVerified<'static>, TpmErr> {
        let Self {
            tag,
            hierarchy,
            digest,
        } = self;

        let digest = digest.into_bufs_owner_intern()?;

        Ok(TpmtTkVerified {
            tag,
            hierarchy,
            digest,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<TpmtTkVerified<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

const fn tpmt_tk_verified_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmSt::marshalled_size();
    size += TpmiRhHierarchy::marshalled_size();
    size += tpm2b_digest_marshalled_max_size();

    size
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 143, table 111, TPMT_TK_AUTH structure
#[derive(Debug, PartialEq)]
pub struct TpmtTkAuth<'a> {
    pub tag: TpmSt,
    pub hierarchy: TpmiRhHierarchy,
    pub digest: Tpm2bDigest<'a>,
}

impl<'a> TpmtTkAuth<'a> {
    pub const fn marshalled_max_size() -> u16 {
        tpmt_tk_auth_marshalled_max_size()
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let tag_size = match usize::try_from(TpmSt::marshalled_size()) {
            Ok(tag_size) => tag_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(tag_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let hierarchy_size = match usize::try_from(TpmiRhHierarchy::marshalled_size()) {
            Ok(hierarchy_size) => hierarchy_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(hierarchy_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let digest_size = match self.digest.marshalled_size() {
            Ok(digest_size) => digest_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(digest_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.tag.marshal(buf)?;

        let buf = self.hierarchy.marshal(buf)?;

        let buf = self.digest.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_tag) = match TpmSt::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        if unmarshalled_tag as u16 != TpmSt::AuthSigned as u16 {
            if unmarshalled_tag as u16 != TpmSt::AuthSecret as u16 {
                return Err(TpmErr::Rc(TpmRc::TAG));
            }
        }

        let (buf, unmarshalled_hierarchy) = match TpmiRhHierarchy::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_digest) = match Tpm2bDigest::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{tag: unmarshalled_tag, hierarchy: unmarshalled_hierarchy, digest: unmarshalled_digest}))
    }

    pub fn unmarshal(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<TpmtTkAuth<'static>, TpmErr> {
        Ok(TpmtTkAuth {
            tag: self.tag,
            hierarchy: self.hierarchy,
            digest: self.digest.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<TpmtTkAuth<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<TpmtTkAuth<'static>, TpmErr> {
        let Self {
            tag,
            hierarchy,
            digest,
        } = self;

        let digest = digest.into_bufs_owner_intern()?;

        Ok(TpmtTkAuth {
            tag,
            hierarchy,
            digest,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<TpmtTkAuth<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

const fn tpmt_tk_auth_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmSt::marshalled_size();
    size += TpmiRhHierarchy::marshalled_size();
    size += tpm2b_digest_marshalled_max_size();

    size
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 143, table 112, TPMT_TK_HASHCHECK structure
#[derive(Debug, PartialEq)]
pub struct TpmtTkHashcheck<'a> {
    pub tag: TpmSt,
    pub hierarchy: TpmiRhHierarchy,
    pub digest: Tpm2bDigest<'a>,
}

impl<'a> TpmtTkHashcheck<'a> {
    pub const fn marshalled_max_size() -> u16 {
        tpmt_tk_hashcheck_marshalled_max_size()
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let tag_size = match usize::try_from(TpmSt::marshalled_size()) {
            Ok(tag_size) => tag_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(tag_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let hierarchy_size = match usize::try_from(TpmiRhHierarchy::marshalled_size()) {
            Ok(hierarchy_size) => hierarchy_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(hierarchy_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let digest_size = match self.digest.marshalled_size() {
            Ok(digest_size) => digest_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(digest_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.tag.marshal(buf)?;

        let buf = self.hierarchy.marshal(buf)?;

        let buf = self.digest.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_tag) = match TpmSt::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        if unmarshalled_tag as u16 != TpmSt::Hashcheck as u16 {
            return Err(TpmErr::Rc(TpmRc::TAG));
        }

        let (buf, unmarshalled_hierarchy) = match TpmiRhHierarchy::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_digest) = match Tpm2bDigest::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{tag: unmarshalled_tag, hierarchy: unmarshalled_hierarchy, digest: unmarshalled_digest}))
    }

    pub fn unmarshal(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<TpmtTkHashcheck<'static>, TpmErr> {
        Ok(TpmtTkHashcheck {
            tag: self.tag,
            hierarchy: self.hierarchy,
            digest: self.digest.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<TpmtTkHashcheck<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<TpmtTkHashcheck<'static>, TpmErr> {
        let Self {
            tag,
            hierarchy,
            digest,
        } = self;

        let digest = digest.into_bufs_owner_intern()?;

        Ok(TpmtTkHashcheck {
            tag,
            hierarchy,
            digest,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<TpmtTkHashcheck<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

const fn tpmt_tk_hashcheck_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmSt::marshalled_size();
    size += TpmiRhHierarchy::marshalled_size();
    size += tpm2b_digest_marshalled_max_size();

    size
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 144, table 113, TPMS_ALG_PROPERTY structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct TpmsAlgProperty {
    pub alg: TpmAlgId,
    pub alg_properties: TpmaAlgorithm,
}

impl TpmsAlgProperty {
    pub const fn marshalled_size() -> u16 {
        tpms_alg_property_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.alg.marshal(buf)?;

        let buf = self.alg_properties.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_alg) = match TpmAlgId::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_alg_properties) = match TpmaAlgorithm::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{alg: unmarshalled_alg, alg_properties: unmarshalled_alg_properties}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpms_alg_property_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmAlgId::marshalled_size();
    size += TpmaAlgorithm::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 144, table 114, TPMS_TAGGED_PROPERTY structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct TpmsTaggedProperty {
    pub property: TpmPt,
    pub value: u32,
}

impl TpmsTaggedProperty {
    pub const fn marshalled_size() -> u16 {
        tpms_tagged_property_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.property.marshal(buf)?;

        let buf = marshal_u32(buf, self.value)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_property) = match TpmPt::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_value) = match unmarshal_u32(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{property: unmarshalled_property, value: unmarshalled_value}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpms_tagged_property_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmPt::marshalled_size();
    size += mem::size_of::<u32>() as u16;

    size
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 144, table 115, TPMS_TAGGED_PCR_SELECT structure
#[derive(Debug, PartialEq)]
pub struct TpmsTaggedPcrSelect<'a> {
    pub tag: TpmPtPcr,
    pub pcr_select: TpmBuffer<'a>,
}

impl<'a> TpmsTaggedPcrSelect<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpms_tagged_pcr_select_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let tag_size = match usize::try_from(TpmPtPcr::marshalled_size()) {
            Ok(tag_size) => tag_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(tag_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let sizeof_select_size = mem::size_of::<u8>();
        size = match size.checked_add(sizeof_select_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let pcr_select_size = self.pcr_select.len();
        size = match size.checked_add(pcr_select_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.tag.marshal(buf)?;

        let marshalled_sizeof_select = match u8::try_from(self.pcr_select.len()) {
            Ok(marshalled_sizeof_select) => marshalled_sizeof_select,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::SIZE));
            },
        };
        let buf = marshal_u8(buf, marshalled_sizeof_select)?;

        let buf = marshal_bytes(buf, &self.pcr_select)?;

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_tag) = match TpmPtPcr::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_sizeof_select) = match unmarshal_u8(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let v0 = match limits.pcr_select_min() {
            Ok(v) => v,
            Err(_) => {
                debug_assert!(false, "Unexpected runtime constant evaluation failure");
                return Err(TpmErr::InternalErr);
            },
        };
        if unmarshalled_sizeof_select < v0 {
            return Err(TpmErr::Rc(TpmRc::VALUE));
        }

        let pcr_select_size: u8 = unmarshalled_sizeof_select;
        let v0 = match limits.pcr_select_max() {
            Ok(v) => v,
            Err(_) => {
                debug_assert!(false, "Unexpected runtime constant evaluation failure");
                return Err(TpmErr::InternalErr);
            },
        };
        if pcr_select_size > v0 {
            return Err(TpmErr::Rc(TpmRc::SIZE));
        }
        let pcr_select_size = match usize::try_from(pcr_select_size) {
            Ok(pcr_select_size) => pcr_select_size,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::INSUFFICIENT));
            },
        };
        let (unmarshalled_pcr_select, buf) = match split_slice_at(buf, pcr_select_size) {
            Ok((unmarshalled_pcr_select, buf)) => (unmarshalled_pcr_select, buf),
            Err(e) => {
                return Err(e);
            },
        };
        let unmarshalled_pcr_select = TpmBuffer::from(unmarshalled_pcr_select);

        Ok((buf, Self{tag: unmarshalled_tag, pcr_select: unmarshalled_pcr_select}))
    }

    pub fn unmarshal(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<TpmsTaggedPcrSelect<'static>, TpmErr> {
        let pcr_select = copy_vec_from_slice(&self.pcr_select)?;
        let pcr_select = TpmBuffer::Owned(pcr_select);

        Ok(TpmsTaggedPcrSelect {
            tag: self.tag,
            pcr_select,
        })
    }

    pub fn try_clone(&self) -> Result<Box<TpmsTaggedPcrSelect<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<TpmsTaggedPcrSelect<'static>, TpmErr> {
        let Self {
            tag,
            pcr_select,
        } = self;

        let pcr_select = pcr_select.into_owned()?;

        Ok(TpmsTaggedPcrSelect {
            tag,
            pcr_select,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<TpmsTaggedPcrSelect<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpms_tagged_pcr_select_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    size += TpmPtPcr::marshalled_size() as u32;
    size += mem::size_of::<u8>() as u32;

    let v0 = match limits.pcr_select_max() {
        Ok(v) => v,
        Err(_) => {
            debug_assert!(false, "Unexpected runtime constant evaluation failure");
            return Err(());
        },
    };
    let pcr_select_size = v0 as u32;
    size = size.checked_add(pcr_select_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 145, table 116, TPMS_TAGGED_POLICY structure
#[derive(Debug, PartialEq)]
pub struct TpmsTaggedPolicy<'a> {
    pub handle: u32,
    pub policy_hash: TpmtHa<'a>,
}

impl<'a> TpmsTaggedPolicy<'a> {
    pub const fn marshalled_max_size() -> u16 {
        tpms_tagged_policy_marshalled_max_size()
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let handle_size = mem::size_of::<u32>();
        size = match size.checked_add(handle_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let policy_hash_size = match self.policy_hash.marshalled_size() {
            Ok(policy_hash_size) => policy_hash_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(policy_hash_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = marshal_u32(buf, self.handle)?;

        let buf = self.policy_hash.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_handle) = match unmarshal_u32(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_policy_hash) = match TpmtHa::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{handle: unmarshalled_handle, policy_hash: unmarshalled_policy_hash}))
    }

    pub fn unmarshal(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<TpmsTaggedPolicy<'static>, TpmErr> {
        Ok(TpmsTaggedPolicy {
            handle: self.handle,
            policy_hash: self.policy_hash.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<TpmsTaggedPolicy<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<TpmsTaggedPolicy<'static>, TpmErr> {
        let Self {
            handle,
            policy_hash,
        } = self;

        let policy_hash = policy_hash.into_bufs_owner_intern()?;

        Ok(TpmsTaggedPolicy {
            handle,
            policy_hash,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<TpmsTaggedPolicy<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

const fn tpms_tagged_policy_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += mem::size_of::<u32>() as u16;
    size += tpmt_ha_marshalled_max_size();

    size
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 145, table 117, TPMS_ACT_DATA structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct TpmsActData {
    pub handle: u32,
    pub timeout: u32,
    pub attributes: TpmaAct,
}

impl TpmsActData {
    pub const fn marshalled_size() -> u16 {
        tpms_act_data_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = marshal_u32(buf, self.handle)?;

        let buf = marshal_u32(buf, self.timeout)?;

        let buf = self.attributes.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_handle) = match unmarshal_u32(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_timeout) = match unmarshal_u32(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_attributes) = match TpmaAct::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{handle: unmarshalled_handle, timeout: unmarshalled_timeout, attributes: unmarshalled_attributes}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpms_act_data_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += mem::size_of::<u32>() as u16;
    size += mem::size_of::<u32>() as u16;
    size += TpmaAct::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 145, table 118, TPMS_SPDM_SESSION_INFO structure
#[derive(Debug, PartialEq)]
pub struct TpmsSpdmSessionInfo<'a> {
    pub req_key_name: Tpm2bName<'a>,
    pub tpm_key_name: Tpm2bName<'a>,
}

impl<'a> TpmsSpdmSessionInfo<'a> {
    pub const fn marshalled_max_size() -> u16 {
        tpms_spdm_session_info_marshalled_max_size()
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let req_key_name_size = match self.req_key_name.marshalled_size() {
            Ok(req_key_name_size) => req_key_name_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(req_key_name_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let tpm_key_name_size = match self.tpm_key_name.marshalled_size() {
            Ok(tpm_key_name_size) => tpm_key_name_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(tpm_key_name_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.req_key_name.marshal(buf)?;

        let buf = self.tpm_key_name.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_req_key_name) = match Tpm2bName::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_tpm_key_name) = match Tpm2bName::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{req_key_name: unmarshalled_req_key_name, tpm_key_name: unmarshalled_tpm_key_name}))
    }

    pub fn unmarshal(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<TpmsSpdmSessionInfo<'static>, TpmErr> {
        Ok(TpmsSpdmSessionInfo {
            req_key_name: self.req_key_name.try_clone_intern()?,
            tpm_key_name: self.tpm_key_name.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<TpmsSpdmSessionInfo<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<TpmsSpdmSessionInfo<'static>, TpmErr> {
        let Self {
            req_key_name,
            tpm_key_name,
        } = self;

        let req_key_name = req_key_name.into_bufs_owner_intern()?;
        let tpm_key_name = tpm_key_name.into_bufs_owner_intern()?;

        Ok(TpmsSpdmSessionInfo {
            req_key_name,
            tpm_key_name,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<TpmsSpdmSessionInfo<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

const fn tpms_spdm_session_info_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += tpm2b_name_marshalled_max_size();
    size += tpm2b_name_marshalled_max_size();

    size
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 145, table 119, TPML_CC structure
#[derive(Debug, PartialEq, Eq)]
pub struct TpmlCc {
    pub command_codes: Vec<TpmCc>,
}

impl TpmlCc {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpml_cc_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let count_size = mem::size_of::<u32>();
        size = match size.checked_add(count_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let command_codes_len = self.command_codes.len();
        let command_codes_element_size = match usize::try_from(TpmCc::marshalled_size()) {
            Ok(command_codes_element_size) => command_codes_element_size,
            Err(_) => {
                return Err(());
            },
        };
        let command_codes_size = match command_codes_len.checked_mul(command_codes_element_size) {
            Some(command_codes_size) => command_codes_size,
            None => {
                return Err(());
            },
        };
        size = match size.checked_add(command_codes_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let marshalled_count = match u32::try_from(self.command_codes.len()) {
            Ok(marshalled_count) => marshalled_count,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::SIZE));
            },
        };
        let buf = marshal_u32(buf, marshalled_count)?;

        let mut buf = buf;
        for element in self.command_codes.iter() {
            let remaining = element.marshal(buf)?;
            buf = remaining;
        }

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_count) = match unmarshal_u32(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let command_codes_len: u32 = unmarshalled_count;
        let v0 = match limits.max_cap_cc() {
            Ok(v) => v,
            Err(_) => {
                debug_assert!(false, "Unexpected runtime constant evaluation failure");
                return Err(TpmErr::InternalErr);
            },
        };
        if command_codes_len > v0 {
            return Err(TpmErr::Rc(TpmRc::SIZE));
        }
        let command_codes_len = match usize::try_from(command_codes_len) {
            Ok(command_codes_len) => command_codes_len,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::INSUFFICIENT));
            },
        };
        let mut unmarshalled_command_codes: Vec<TpmCc> = Vec::new();
        if unmarshalled_command_codes.try_reserve_exact(command_codes_len).is_err() {
            return Err(TpmErr::Rc(TpmRc::MEMORY));
        }
        let mut buf = buf;
        for _i in 0..command_codes_len {
            let (remaining, unmarshalled_element) = match TpmCc::unmarshal(buf) {
                Ok(r) => r,
                Err(e) => {
                    return Err(e);
                },
            };
            unmarshalled_command_codes.push(unmarshalled_element);
            buf = remaining;
        }

        Ok((buf, Self{command_codes: unmarshalled_command_codes}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<TpmlCc, TpmErr> {
        let command_codes = copy_vec_from_slice(&self.command_codes)?;

        Ok(TpmlCc {
            command_codes,
        })
    }

    pub fn try_clone(&self) -> Result<Box<TpmlCc>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpml_cc_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    size += mem::size_of::<u32>() as u32;

    let v0 = match limits.max_cap_cc() {
        Ok(v) => v,
        Err(_) => {
            debug_assert!(false, "Unexpected runtime constant evaluation failure");
            return Err(());
        },
    };
    let command_codes_size = v0;
    let command_codes_size = command_codes_size.checked_mul(TpmCc::marshalled_size() as u32).ok_or(())?;
    size = size.checked_add(command_codes_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 146, table 120, TPML_CCA structure
#[derive(Debug, PartialEq, Eq)]
pub struct TpmlCca {
    pub command_attributes: Vec<TpmaCc>,
}

impl TpmlCca {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpml_cca_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let count_size = mem::size_of::<u32>();
        size = match size.checked_add(count_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let command_attributes_len = self.command_attributes.len();
        let command_attributes_element_size = match usize::try_from(TpmaCc::marshalled_size()) {
            Ok(command_attributes_element_size) => command_attributes_element_size,
            Err(_) => {
                return Err(());
            },
        };
        let command_attributes_size = match command_attributes_len.checked_mul(command_attributes_element_size) {
            Some(command_attributes_size) => command_attributes_size,
            None => {
                return Err(());
            },
        };
        size = match size.checked_add(command_attributes_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let marshalled_count = match u32::try_from(self.command_attributes.len()) {
            Ok(marshalled_count) => marshalled_count,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::SIZE));
            },
        };
        let buf = marshal_u32(buf, marshalled_count)?;

        let mut buf = buf;
        for element in self.command_attributes.iter() {
            let remaining = element.marshal(buf)?;
            buf = remaining;
        }

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_count) = match unmarshal_u32(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let command_attributes_len: u32 = unmarshalled_count;
        let v0 = match limits.max_cap_cc() {
            Ok(v) => v,
            Err(_) => {
                debug_assert!(false, "Unexpected runtime constant evaluation failure");
                return Err(TpmErr::InternalErr);
            },
        };
        if command_attributes_len > v0 {
            return Err(TpmErr::Rc(TpmRc::SIZE));
        }
        let command_attributes_len = match usize::try_from(command_attributes_len) {
            Ok(command_attributes_len) => command_attributes_len,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::INSUFFICIENT));
            },
        };
        let mut unmarshalled_command_attributes: Vec<TpmaCc> = Vec::new();
        if unmarshalled_command_attributes.try_reserve_exact(command_attributes_len).is_err() {
            return Err(TpmErr::Rc(TpmRc::MEMORY));
        }
        let mut buf = buf;
        for _i in 0..command_attributes_len {
            let (remaining, unmarshalled_element) = match TpmaCc::unmarshal(buf) {
                Ok(r) => r,
                Err(e) => {
                    return Err(e);
                },
            };
            unmarshalled_command_attributes.push(unmarshalled_element);
            buf = remaining;
        }

        Ok((buf, Self{command_attributes: unmarshalled_command_attributes}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<TpmlCca, TpmErr> {
        let command_attributes = copy_vec_from_slice(&self.command_attributes)?;

        Ok(TpmlCca {
            command_attributes,
        })
    }

    pub fn try_clone(&self) -> Result<Box<TpmlCca>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpml_cca_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    size += mem::size_of::<u32>() as u32;

    let v0 = match limits.max_cap_cc() {
        Ok(v) => v,
        Err(_) => {
            debug_assert!(false, "Unexpected runtime constant evaluation failure");
            return Err(());
        },
    };
    let command_attributes_size = v0;
    let command_attributes_size = command_attributes_size.checked_mul(TpmaCc::marshalled_size() as u32).ok_or(())?;
    size = size.checked_add(command_attributes_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 146, table 121, TPML_ALG structure
#[derive(Debug, PartialEq, Eq)]
pub struct TpmlAlg {
    pub algorithms: Vec<TpmAlgId>,
}

impl TpmlAlg {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpml_alg_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let count_size = mem::size_of::<u32>();
        size = match size.checked_add(count_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let algorithms_len = self.algorithms.len();
        let algorithms_element_size = match usize::try_from(TpmAlgId::marshalled_size()) {
            Ok(algorithms_element_size) => algorithms_element_size,
            Err(_) => {
                return Err(());
            },
        };
        let algorithms_size = match algorithms_len.checked_mul(algorithms_element_size) {
            Some(algorithms_size) => algorithms_size,
            None => {
                return Err(());
            },
        };
        size = match size.checked_add(algorithms_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let marshalled_count = match u32::try_from(self.algorithms.len()) {
            Ok(marshalled_count) => marshalled_count,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::SIZE));
            },
        };
        let buf = marshal_u32(buf, marshalled_count)?;

        let mut buf = buf;
        for element in self.algorithms.iter() {
            let remaining = element.marshal(buf)?;
            buf = remaining;
        }

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_count) = match unmarshal_u32(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let algorithms_len: u32 = unmarshalled_count;
        if algorithms_len > limits.max_alg_list_size {
            return Err(TpmErr::Rc(TpmRc::SIZE));
        }
        let algorithms_len = match usize::try_from(algorithms_len) {
            Ok(algorithms_len) => algorithms_len,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::INSUFFICIENT));
            },
        };
        let mut unmarshalled_algorithms: Vec<TpmAlgId> = Vec::new();
        if unmarshalled_algorithms.try_reserve_exact(algorithms_len).is_err() {
            return Err(TpmErr::Rc(TpmRc::MEMORY));
        }
        let mut buf = buf;
        for _i in 0..algorithms_len {
            let (remaining, unmarshalled_element) = match TpmAlgId::unmarshal(buf) {
                Ok(r) => r,
                Err(e) => {
                    return Err(e);
                },
            };
            unmarshalled_algorithms.push(unmarshalled_element);
            buf = remaining;
        }

        Ok((buf, Self{algorithms: unmarshalled_algorithms}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<TpmlAlg, TpmErr> {
        let algorithms = copy_vec_from_slice(&self.algorithms)?;

        Ok(TpmlAlg {
            algorithms,
        })
    }

    pub fn try_clone(&self) -> Result<Box<TpmlAlg>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpml_alg_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    size += mem::size_of::<u32>() as u32;

    let algorithms_size = limits.max_alg_list_size;
    let algorithms_size = algorithms_size.checked_mul(TpmAlgId::marshalled_size() as u32).ok_or(())?;
    size = size.checked_add(algorithms_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 147, table 122, TPML_HANDLE structure
#[derive(Debug, PartialEq, Eq)]
pub struct TpmlHandle {
    pub handle: Vec<u32>,
}

impl TpmlHandle {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpml_handle_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let count_size = mem::size_of::<u32>();
        size = match size.checked_add(count_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let handle_len = self.handle.len();
        let handle_element_size = mem::size_of::<u32>();
        let handle_size = match handle_len.checked_mul(handle_element_size) {
            Some(handle_size) => handle_size,
            None => {
                return Err(());
            },
        };
        size = match size.checked_add(handle_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let marshalled_count = match u32::try_from(self.handle.len()) {
            Ok(marshalled_count) => marshalled_count,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::SIZE));
            },
        };
        let buf = marshal_u32(buf, marshalled_count)?;

        let mut buf = buf;
        for element in self.handle.iter() {
            let remaining = marshal_u32(buf, *element)?;
            buf = remaining;
        }

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_count) = match unmarshal_u32(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let handle_len: u32 = unmarshalled_count;
        let v0 = match limits.max_cap_handles() {
            Ok(v) => v,
            Err(_) => {
                debug_assert!(false, "Unexpected runtime constant evaluation failure");
                return Err(TpmErr::InternalErr);
            },
        };
        if handle_len > v0 {
            return Err(TpmErr::Rc(TpmRc::SIZE));
        }
        let handle_len = match usize::try_from(handle_len) {
            Ok(handle_len) => handle_len,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::INSUFFICIENT));
            },
        };
        let mut unmarshalled_handle: Vec<u32> = Vec::new();
        if unmarshalled_handle.try_reserve_exact(handle_len).is_err() {
            return Err(TpmErr::Rc(TpmRc::MEMORY));
        }
        let mut buf = buf;
        for _i in 0..handle_len {
            let (remaining, unmarshalled_element) = match unmarshal_u32(buf) {
                Ok(r) => r,
                Err(e) => {
                    return Err(e);
                },
            };
            unmarshalled_handle.push(unmarshalled_element);
            buf = remaining;
        }

        Ok((buf, Self{handle: unmarshalled_handle}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<TpmlHandle, TpmErr> {
        let handle = copy_vec_from_slice(&self.handle)?;

        Ok(TpmlHandle {
            handle,
        })
    }

    pub fn try_clone(&self) -> Result<Box<TpmlHandle>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpml_handle_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    size += mem::size_of::<u32>() as u32;

    let v0 = match limits.max_cap_handles() {
        Ok(v) => v,
        Err(_) => {
            debug_assert!(false, "Unexpected runtime constant evaluation failure");
            return Err(());
        },
    };
    let handle_size = v0;
    let handle_size = handle_size.checked_mul(mem::size_of::<u32>() as u32).ok_or(())?;
    size = size.checked_add(handle_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 147, table 123, TPML_DIGEST structure
#[derive(Debug, PartialEq)]
pub struct TpmlDigest<'a> {
    pub digests: Vec<Tpm2bDigest<'a>>,
}

impl<'a> TpmlDigest<'a> {
    pub const fn marshalled_max_size() -> u16 {
        tpml_digest_marshalled_max_size()
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let count_size = mem::size_of::<u32>();
        size = match size.checked_add(count_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let mut digests_size: usize = 0;
        for element in self.digests.iter() {
            let digests_element_size = match element.marshalled_size() {
                Ok(digests_element_size) => digests_element_size,
                Err(_) => {
                    return Err(());
                },
            };
            digests_size = match digests_size.checked_add(digests_element_size) {
                Some(digests_size) => digests_size,
                None => {
                    return Err(());
                },
            };
        }
        size = match size.checked_add(digests_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let marshalled_count = match u32::try_from(self.digests.len()) {
            Ok(marshalled_count) => marshalled_count,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::SIZE));
            },
        };
        let buf = marshal_u32(buf, marshalled_count)?;

        let mut buf = buf;
        for element in self.digests.iter() {
            let remaining = element.marshal(buf)?;
            buf = remaining;
        }

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_count) = match unmarshal_u32(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        if unmarshalled_count < 2u32 {
            return Err(TpmErr::Rc(TpmRc::SIZE));
        }

        let digests_len: u32 = unmarshalled_count;
        if digests_len > 8u32 {
            return Err(TpmErr::Rc(TpmRc::SIZE));
        }
        let digests_len = match usize::try_from(digests_len) {
            Ok(digests_len) => digests_len,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::INSUFFICIENT));
            },
        };
        let mut unmarshalled_digests: Vec<Tpm2bDigest<'a>> = Vec::new();
        if unmarshalled_digests.try_reserve_exact(digests_len).is_err() {
            return Err(TpmErr::Rc(TpmRc::MEMORY));
        }
        let mut buf = buf;
        for _i in 0..digests_len {
            let (remaining, unmarshalled_element) = match Tpm2bDigest::unmarshal_intern(buf) {
                Ok(r) => r,
                Err(e) => {
                    return Err(e);
                },
            };
            unmarshalled_digests.push(unmarshalled_element);
            buf = remaining;
        }

        Ok((buf, Self{digests: unmarshalled_digests}))
    }

    pub fn unmarshal(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<TpmlDigest<'static>, TpmErr> {
        let mut digests = Vec::new();
        digests.try_reserve_exact(self.digests.len()).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))?;
        for element in self.digests.iter() {
            let _ = digests.push(element.try_clone_intern()?);
        }

        Ok(TpmlDigest {
            digests,
        })
    }

    pub fn try_clone(&self) -> Result<Box<TpmlDigest<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<TpmlDigest<'static>, TpmErr> {
        let Self {
            digests,
        } = self;

        let mut digests_orig = digests;
        let mut digests = Vec::new();
        digests.try_reserve_exact(digests_orig.len()).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))?;
        for element in digests_orig.drain(..) {
            let _ = digests.push(element.into_bufs_owner_intern()?);
        }

        Ok(TpmlDigest {
            digests,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<TpmlDigest<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

const fn tpml_digest_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += mem::size_of::<u32>() as u16;
    size += tpm2b_digest_marshalled_max_size() * 8u16;

    size
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 148, table 124, TPML_DIGEST_VALUES structure
#[derive(Debug, PartialEq)]
pub struct TpmlDigestValues<'a> {
    pub digests: Vec<TpmtHa<'a>>,
}

impl<'a> TpmlDigestValues<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpml_digest_values_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let count_size = mem::size_of::<u32>();
        size = match size.checked_add(count_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let mut digests_size: usize = 0;
        for element in self.digests.iter() {
            let digests_element_size = match element.marshalled_size() {
                Ok(digests_element_size) => digests_element_size,
                Err(_) => {
                    return Err(());
                },
            };
            digests_size = match digests_size.checked_add(digests_element_size) {
                Some(digests_size) => digests_size,
                None => {
                    return Err(());
                },
            };
        }
        size = match size.checked_add(digests_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let marshalled_count = match u32::try_from(self.digests.len()) {
            Ok(marshalled_count) => marshalled_count,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::SIZE));
            },
        };
        let buf = marshal_u32(buf, marshalled_count)?;

        let mut buf = buf;
        for element in self.digests.iter() {
            let remaining = element.marshal(buf)?;
            buf = remaining;
        }

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_count) = match unmarshal_u32(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let digests_len: u32 = unmarshalled_count;
        if digests_len > limits.hash_count {
            return Err(TpmErr::Rc(TpmRc::SIZE));
        }
        let digests_len = match usize::try_from(digests_len) {
            Ok(digests_len) => digests_len,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::INSUFFICIENT));
            },
        };
        let mut unmarshalled_digests: Vec<TpmtHa<'a>> = Vec::new();
        if unmarshalled_digests.try_reserve_exact(digests_len).is_err() {
            return Err(TpmErr::Rc(TpmRc::MEMORY));
        }
        let mut buf = buf;
        for _i in 0..digests_len {
            let (remaining, unmarshalled_element) = match TpmtHa::unmarshal_intern(buf) {
                Ok(r) => r,
                Err(e) => {
                    return Err(e);
                },
            };
            unmarshalled_digests.push(unmarshalled_element);
            buf = remaining;
        }

        Ok((buf, Self{digests: unmarshalled_digests}))
    }

    pub fn unmarshal(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<TpmlDigestValues<'static>, TpmErr> {
        let mut digests = Vec::new();
        digests.try_reserve_exact(self.digests.len()).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))?;
        for element in self.digests.iter() {
            let _ = digests.push(element.try_clone_intern()?);
        }

        Ok(TpmlDigestValues {
            digests,
        })
    }

    pub fn try_clone(&self) -> Result<Box<TpmlDigestValues<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<TpmlDigestValues<'static>, TpmErr> {
        let Self {
            digests,
        } = self;

        let mut digests_orig = digests;
        let mut digests = Vec::new();
        digests.try_reserve_exact(digests_orig.len()).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))?;
        for element in digests_orig.drain(..) {
            let _ = digests.push(element.into_bufs_owner_intern()?);
        }

        Ok(TpmlDigestValues {
            digests,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<TpmlDigestValues<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpml_digest_values_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    size += mem::size_of::<u32>() as u32;

    let digests_size = limits.hash_count;
    let digests_size = digests_size.checked_mul(tpmt_ha_marshalled_max_size() as u32).ok_or(())?;
    size = size.checked_add(digests_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 148, table 125, TPML_PCR_SELECTION structure
#[derive(Debug, PartialEq)]
pub struct TpmlPcrSelection<'a> {
    pub pcr_selections: Vec<TpmsPcrSelection<'a>>,
}

impl<'a> TpmlPcrSelection<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpml_pcr_selection_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let count_size = mem::size_of::<u32>();
        size = match size.checked_add(count_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let mut pcr_selections_size: usize = 0;
        for element in self.pcr_selections.iter() {
            let pcr_selections_element_size = match element.marshalled_size() {
                Ok(pcr_selections_element_size) => pcr_selections_element_size,
                Err(_) => {
                    return Err(());
                },
            };
            pcr_selections_size = match pcr_selections_size.checked_add(pcr_selections_element_size) {
                Some(pcr_selections_size) => pcr_selections_size,
                None => {
                    return Err(());
                },
            };
        }
        size = match size.checked_add(pcr_selections_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let marshalled_count = match u32::try_from(self.pcr_selections.len()) {
            Ok(marshalled_count) => marshalled_count,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::SIZE));
            },
        };
        let buf = marshal_u32(buf, marshalled_count)?;

        let mut buf = buf;
        for element in self.pcr_selections.iter() {
            let remaining = element.marshal(buf)?;
            buf = remaining;
        }

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_count) = match unmarshal_u32(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let pcr_selections_len: u32 = unmarshalled_count;
        if pcr_selections_len > limits.hash_count {
            return Err(TpmErr::Rc(TpmRc::SIZE));
        }
        let pcr_selections_len = match usize::try_from(pcr_selections_len) {
            Ok(pcr_selections_len) => pcr_selections_len,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::INSUFFICIENT));
            },
        };
        let mut unmarshalled_pcr_selections: Vec<TpmsPcrSelection<'a>> = Vec::new();
        if unmarshalled_pcr_selections.try_reserve_exact(pcr_selections_len).is_err() {
            return Err(TpmErr::Rc(TpmRc::MEMORY));
        }
        let mut buf = buf;
        for _i in 0..pcr_selections_len {
            let (remaining, unmarshalled_element) = match TpmsPcrSelection::unmarshal_intern(buf, limits) {
                Ok(r) => r,
                Err(e) => {
                    return Err(e);
                },
            };
            unmarshalled_pcr_selections.push(unmarshalled_element);
            buf = remaining;
        }

        Ok((buf, Self{pcr_selections: unmarshalled_pcr_selections}))
    }

    pub fn unmarshal(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<TpmlPcrSelection<'static>, TpmErr> {
        let mut pcr_selections = Vec::new();
        pcr_selections.try_reserve_exact(self.pcr_selections.len()).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))?;
        for element in self.pcr_selections.iter() {
            let _ = pcr_selections.push(element.try_clone_intern()?);
        }

        Ok(TpmlPcrSelection {
            pcr_selections,
        })
    }

    pub fn try_clone(&self) -> Result<Box<TpmlPcrSelection<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<TpmlPcrSelection<'static>, TpmErr> {
        let Self {
            pcr_selections,
        } = self;

        let mut pcr_selections_orig = pcr_selections;
        let mut pcr_selections = Vec::new();
        pcr_selections.try_reserve_exact(pcr_selections_orig.len()).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))?;
        for element in pcr_selections_orig.drain(..) {
            let _ = pcr_selections.push(element.into_bufs_owner_intern()?);
        }

        Ok(TpmlPcrSelection {
            pcr_selections,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<TpmlPcrSelection<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpml_pcr_selection_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    size += mem::size_of::<u32>() as u32;

    let pcr_selections_size = limits.hash_count;
    let pcr_selections_element_size = match tpms_pcr_selection_marshalled_max_size(limits) {
        Ok(pcr_selections_element_size) => pcr_selections_element_size,
        Err(_) => {
            return Err(());
        },
    };
    let pcr_selections_size = pcr_selections_size.checked_mul(pcr_selections_element_size).ok_or(())?;
    size = size.checked_add(pcr_selections_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 148, table 126, TPML_ALG_PROPERTY structure
#[derive(Debug, PartialEq, Eq)]
pub struct TpmlAlgProperty {
    pub alg_properties: Vec<TpmsAlgProperty>,
}

impl TpmlAlgProperty {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpml_alg_property_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let count_size = mem::size_of::<u32>();
        size = match size.checked_add(count_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let alg_properties_len = self.alg_properties.len();
        let alg_properties_element_size = match usize::try_from(tpms_alg_property_marshalled_size()) {
            Ok(alg_properties_element_size) => alg_properties_element_size,
            Err(_) => {
                return Err(());
            },
        };
        let alg_properties_size = match alg_properties_len.checked_mul(alg_properties_element_size) {
            Some(alg_properties_size) => alg_properties_size,
            None => {
                return Err(());
            },
        };
        size = match size.checked_add(alg_properties_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let marshalled_count = match u32::try_from(self.alg_properties.len()) {
            Ok(marshalled_count) => marshalled_count,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::SIZE));
            },
        };
        let buf = marshal_u32(buf, marshalled_count)?;

        let mut buf = buf;
        for element in self.alg_properties.iter() {
            let remaining = element.marshal(buf)?;
            buf = remaining;
        }

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_count) = match unmarshal_u32(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let alg_properties_len: u32 = unmarshalled_count;
        let v0 = match limits.max_cap_algs() {
            Ok(v) => v,
            Err(_) => {
                debug_assert!(false, "Unexpected runtime constant evaluation failure");
                return Err(TpmErr::InternalErr);
            },
        };
        if alg_properties_len > v0 {
            return Err(TpmErr::Rc(TpmRc::SIZE));
        }
        let alg_properties_len = match usize::try_from(alg_properties_len) {
            Ok(alg_properties_len) => alg_properties_len,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::INSUFFICIENT));
            },
        };
        let mut unmarshalled_alg_properties: Vec<TpmsAlgProperty> = Vec::new();
        if unmarshalled_alg_properties.try_reserve_exact(alg_properties_len).is_err() {
            return Err(TpmErr::Rc(TpmRc::MEMORY));
        }
        let mut buf = buf;
        for _i in 0..alg_properties_len {
            let (remaining, unmarshalled_element) = match TpmsAlgProperty::unmarshal_intern(buf) {
                Ok(r) => r,
                Err(e) => {
                    return Err(e);
                },
            };
            unmarshalled_alg_properties.push(unmarshalled_element);
            buf = remaining;
        }

        Ok((buf, Self{alg_properties: unmarshalled_alg_properties}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<TpmlAlgProperty, TpmErr> {
        let alg_properties = copy_vec_from_slice(&self.alg_properties)?;

        Ok(TpmlAlgProperty {
            alg_properties,
        })
    }

    pub fn try_clone(&self) -> Result<Box<TpmlAlgProperty>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpml_alg_property_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    size += mem::size_of::<u32>() as u32;

    let v0 = match limits.max_cap_algs() {
        Ok(v) => v,
        Err(_) => {
            debug_assert!(false, "Unexpected runtime constant evaluation failure");
            return Err(());
        },
    };
    let alg_properties_size = v0;
    let alg_properties_size = alg_properties_size.checked_mul(tpms_alg_property_marshalled_size() as u32).ok_or(())?;
    size = size.checked_add(alg_properties_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 149, table 127, TPML_TAGGED_TPM_PROPERTY structure
#[derive(Debug, PartialEq, Eq)]
pub struct TpmlTaggedTpmProperty {
    pub tpm_property: Vec<TpmsTaggedProperty>,
}

impl TpmlTaggedTpmProperty {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpml_tagged_tpm_property_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let count_size = mem::size_of::<u32>();
        size = match size.checked_add(count_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let tpm_property_len = self.tpm_property.len();
        let tpm_property_element_size = match usize::try_from(tpms_tagged_property_marshalled_size()) {
            Ok(tpm_property_element_size) => tpm_property_element_size,
            Err(_) => {
                return Err(());
            },
        };
        let tpm_property_size = match tpm_property_len.checked_mul(tpm_property_element_size) {
            Some(tpm_property_size) => tpm_property_size,
            None => {
                return Err(());
            },
        };
        size = match size.checked_add(tpm_property_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let marshalled_count = match u32::try_from(self.tpm_property.len()) {
            Ok(marshalled_count) => marshalled_count,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::SIZE));
            },
        };
        let buf = marshal_u32(buf, marshalled_count)?;

        let mut buf = buf;
        for element in self.tpm_property.iter() {
            let remaining = element.marshal(buf)?;
            buf = remaining;
        }

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_count) = match unmarshal_u32(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let tpm_property_len: u32 = unmarshalled_count;
        let v0 = match limits.max_tpm_properties() {
            Ok(v) => v,
            Err(_) => {
                debug_assert!(false, "Unexpected runtime constant evaluation failure");
                return Err(TpmErr::InternalErr);
            },
        };
        if tpm_property_len > v0 {
            return Err(TpmErr::Rc(TpmRc::SIZE));
        }
        let tpm_property_len = match usize::try_from(tpm_property_len) {
            Ok(tpm_property_len) => tpm_property_len,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::INSUFFICIENT));
            },
        };
        let mut unmarshalled_tpm_property: Vec<TpmsTaggedProperty> = Vec::new();
        if unmarshalled_tpm_property.try_reserve_exact(tpm_property_len).is_err() {
            return Err(TpmErr::Rc(TpmRc::MEMORY));
        }
        let mut buf = buf;
        for _i in 0..tpm_property_len {
            let (remaining, unmarshalled_element) = match TpmsTaggedProperty::unmarshal_intern(buf) {
                Ok(r) => r,
                Err(e) => {
                    return Err(e);
                },
            };
            unmarshalled_tpm_property.push(unmarshalled_element);
            buf = remaining;
        }

        Ok((buf, Self{tpm_property: unmarshalled_tpm_property}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<TpmlTaggedTpmProperty, TpmErr> {
        let tpm_property = copy_vec_from_slice(&self.tpm_property)?;

        Ok(TpmlTaggedTpmProperty {
            tpm_property,
        })
    }

    pub fn try_clone(&self) -> Result<Box<TpmlTaggedTpmProperty>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpml_tagged_tpm_property_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    size += mem::size_of::<u32>() as u32;

    let v0 = match limits.max_tpm_properties() {
        Ok(v) => v,
        Err(_) => {
            debug_assert!(false, "Unexpected runtime constant evaluation failure");
            return Err(());
        },
    };
    let tpm_property_size = v0;
    let tpm_property_size = tpm_property_size.checked_mul(tpms_tagged_property_marshalled_size() as u32).ok_or(())?;
    size = size.checked_add(tpm_property_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 149, table 128, TPML_TAGGED_PCR_PROPERTY structure
#[derive(Debug, PartialEq)]
pub struct TpmlTaggedPcrProperty<'a> {
    pub pcr_property: Vec<TpmsTaggedPcrSelect<'a>>,
}

impl<'a> TpmlTaggedPcrProperty<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpml_tagged_pcr_property_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let count_size = mem::size_of::<u32>();
        size = match size.checked_add(count_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let mut pcr_property_size: usize = 0;
        for element in self.pcr_property.iter() {
            let pcr_property_element_size = match element.marshalled_size() {
                Ok(pcr_property_element_size) => pcr_property_element_size,
                Err(_) => {
                    return Err(());
                },
            };
            pcr_property_size = match pcr_property_size.checked_add(pcr_property_element_size) {
                Some(pcr_property_size) => pcr_property_size,
                None => {
                    return Err(());
                },
            };
        }
        size = match size.checked_add(pcr_property_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let marshalled_count = match u32::try_from(self.pcr_property.len()) {
            Ok(marshalled_count) => marshalled_count,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::SIZE));
            },
        };
        let buf = marshal_u32(buf, marshalled_count)?;

        let mut buf = buf;
        for element in self.pcr_property.iter() {
            let remaining = element.marshal(buf)?;
            buf = remaining;
        }

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_count) = match unmarshal_u32(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let pcr_property_len: u32 = unmarshalled_count;
        let v0 = match limits.max_pcr_properties() {
            Ok(v) => v,
            Err(_) => {
                debug_assert!(false, "Unexpected runtime constant evaluation failure");
                return Err(TpmErr::InternalErr);
            },
        };
        if pcr_property_len > v0 {
            return Err(TpmErr::Rc(TpmRc::SIZE));
        }
        let pcr_property_len = match usize::try_from(pcr_property_len) {
            Ok(pcr_property_len) => pcr_property_len,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::INSUFFICIENT));
            },
        };
        let mut unmarshalled_pcr_property: Vec<TpmsTaggedPcrSelect<'a>> = Vec::new();
        if unmarshalled_pcr_property.try_reserve_exact(pcr_property_len).is_err() {
            return Err(TpmErr::Rc(TpmRc::MEMORY));
        }
        let mut buf = buf;
        for _i in 0..pcr_property_len {
            let (remaining, unmarshalled_element) = match TpmsTaggedPcrSelect::unmarshal_intern(buf, limits) {
                Ok(r) => r,
                Err(e) => {
                    return Err(e);
                },
            };
            unmarshalled_pcr_property.push(unmarshalled_element);
            buf = remaining;
        }

        Ok((buf, Self{pcr_property: unmarshalled_pcr_property}))
    }

    pub fn unmarshal(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<TpmlTaggedPcrProperty<'static>, TpmErr> {
        let mut pcr_property = Vec::new();
        pcr_property.try_reserve_exact(self.pcr_property.len()).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))?;
        for element in self.pcr_property.iter() {
            let _ = pcr_property.push(element.try_clone_intern()?);
        }

        Ok(TpmlTaggedPcrProperty {
            pcr_property,
        })
    }

    pub fn try_clone(&self) -> Result<Box<TpmlTaggedPcrProperty<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<TpmlTaggedPcrProperty<'static>, TpmErr> {
        let Self {
            pcr_property,
        } = self;

        let mut pcr_property_orig = pcr_property;
        let mut pcr_property = Vec::new();
        pcr_property.try_reserve_exact(pcr_property_orig.len()).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))?;
        for element in pcr_property_orig.drain(..) {
            let _ = pcr_property.push(element.into_bufs_owner_intern()?);
        }

        Ok(TpmlTaggedPcrProperty {
            pcr_property,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<TpmlTaggedPcrProperty<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpml_tagged_pcr_property_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    size += mem::size_of::<u32>() as u32;

    let v0 = match limits.max_pcr_properties() {
        Ok(v) => v,
        Err(_) => {
            debug_assert!(false, "Unexpected runtime constant evaluation failure");
            return Err(());
        },
    };
    let pcr_property_size = v0;
    let pcr_property_element_size = match tpms_tagged_pcr_select_marshalled_max_size(limits) {
        Ok(pcr_property_element_size) => pcr_property_element_size,
        Err(_) => {
            return Err(());
        },
    };
    let pcr_property_size = pcr_property_size.checked_mul(pcr_property_element_size).ok_or(())?;
    size = size.checked_add(pcr_property_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 150, table 129, TPML_ECC_CURVE structure
#[cfg(feature = "ecc")]
#[derive(Debug, PartialEq, Eq)]
pub struct TpmlEccCurve {
    pub ecc_curves: Vec<TpmEccCurve>,
}

#[cfg(feature = "ecc")]
impl TpmlEccCurve {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpml_ecc_curve_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let count_size = mem::size_of::<u32>();
        size = match size.checked_add(count_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let ecc_curves_len = self.ecc_curves.len();
        let ecc_curves_element_size = match usize::try_from(TpmEccCurve::marshalled_size()) {
            Ok(ecc_curves_element_size) => ecc_curves_element_size,
            Err(_) => {
                return Err(());
            },
        };
        let ecc_curves_size = match ecc_curves_len.checked_mul(ecc_curves_element_size) {
            Some(ecc_curves_size) => ecc_curves_size,
            None => {
                return Err(());
            },
        };
        size = match size.checked_add(ecc_curves_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let marshalled_count = match u32::try_from(self.ecc_curves.len()) {
            Ok(marshalled_count) => marshalled_count,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::SIZE));
            },
        };
        let buf = marshal_u32(buf, marshalled_count)?;

        let mut buf = buf;
        for element in self.ecc_curves.iter() {
            let remaining = element.marshal(buf)?;
            buf = remaining;
        }

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_count) = match unmarshal_u32(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let ecc_curves_len: u32 = unmarshalled_count;
        let v0 = match limits.max_ecc_curves() {
            Ok(v) => v,
            Err(_) => {
                debug_assert!(false, "Unexpected runtime constant evaluation failure");
                return Err(TpmErr::InternalErr);
            },
        };
        if ecc_curves_len > v0 {
            return Err(TpmErr::Rc(TpmRc::SIZE));
        }
        let ecc_curves_len = match usize::try_from(ecc_curves_len) {
            Ok(ecc_curves_len) => ecc_curves_len,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::INSUFFICIENT));
            },
        };
        let mut unmarshalled_ecc_curves: Vec<TpmEccCurve> = Vec::new();
        if unmarshalled_ecc_curves.try_reserve_exact(ecc_curves_len).is_err() {
            return Err(TpmErr::Rc(TpmRc::MEMORY));
        }
        let mut buf = buf;
        for _i in 0..ecc_curves_len {
            let (remaining, unmarshalled_element) = match TpmEccCurve::unmarshal(buf) {
                Ok(r) => r,
                Err(e) => {
                    return Err(e);
                },
            };
            unmarshalled_ecc_curves.push(unmarshalled_element);
            buf = remaining;
        }

        Ok((buf, Self{ecc_curves: unmarshalled_ecc_curves}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<TpmlEccCurve, TpmErr> {
        let ecc_curves = copy_vec_from_slice(&self.ecc_curves)?;

        Ok(TpmlEccCurve {
            ecc_curves,
        })
    }

    pub fn try_clone(&self) -> Result<Box<TpmlEccCurve>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

#[cfg(feature = "ecc")]
fn tpml_ecc_curve_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    size += mem::size_of::<u32>() as u32;

    let v0 = match limits.max_ecc_curves() {
        Ok(v) => v,
        Err(_) => {
            debug_assert!(false, "Unexpected runtime constant evaluation failure");
            return Err(());
        },
    };
    let ecc_curves_size = v0;
    let ecc_curves_size = ecc_curves_size.checked_mul(TpmEccCurve::marshalled_size() as u32).ok_or(())?;
    size = size.checked_add(ecc_curves_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 150, table 130, TPML_TAGGED_POLICY structure
#[derive(Debug, PartialEq)]
pub struct TpmlTaggedPolicy<'a> {
    pub policies: Vec<TpmsTaggedPolicy<'a>>,
}

impl<'a> TpmlTaggedPolicy<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpml_tagged_policy_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let count_size = mem::size_of::<u32>();
        size = match size.checked_add(count_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let mut policies_size: usize = 0;
        for element in self.policies.iter() {
            let policies_element_size = match element.marshalled_size() {
                Ok(policies_element_size) => policies_element_size,
                Err(_) => {
                    return Err(());
                },
            };
            policies_size = match policies_size.checked_add(policies_element_size) {
                Some(policies_size) => policies_size,
                None => {
                    return Err(());
                },
            };
        }
        size = match size.checked_add(policies_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let marshalled_count = match u32::try_from(self.policies.len()) {
            Ok(marshalled_count) => marshalled_count,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::SIZE));
            },
        };
        let buf = marshal_u32(buf, marshalled_count)?;

        let mut buf = buf;
        for element in self.policies.iter() {
            let remaining = element.marshal(buf)?;
            buf = remaining;
        }

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_count) = match unmarshal_u32(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let policies_len: u32 = unmarshalled_count;
        let v0 = match limits.max_tagged_policies() {
            Ok(v) => v,
            Err(_) => {
                debug_assert!(false, "Unexpected runtime constant evaluation failure");
                return Err(TpmErr::InternalErr);
            },
        };
        if policies_len > v0 {
            return Err(TpmErr::Rc(TpmRc::SIZE));
        }
        let policies_len = match usize::try_from(policies_len) {
            Ok(policies_len) => policies_len,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::INSUFFICIENT));
            },
        };
        let mut unmarshalled_policies: Vec<TpmsTaggedPolicy<'a>> = Vec::new();
        if unmarshalled_policies.try_reserve_exact(policies_len).is_err() {
            return Err(TpmErr::Rc(TpmRc::MEMORY));
        }
        let mut buf = buf;
        for _i in 0..policies_len {
            let (remaining, unmarshalled_element) = match TpmsTaggedPolicy::unmarshal_intern(buf) {
                Ok(r) => r,
                Err(e) => {
                    return Err(e);
                },
            };
            unmarshalled_policies.push(unmarshalled_element);
            buf = remaining;
        }

        Ok((buf, Self{policies: unmarshalled_policies}))
    }

    pub fn unmarshal(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<TpmlTaggedPolicy<'static>, TpmErr> {
        let mut policies = Vec::new();
        policies.try_reserve_exact(self.policies.len()).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))?;
        for element in self.policies.iter() {
            let _ = policies.push(element.try_clone_intern()?);
        }

        Ok(TpmlTaggedPolicy {
            policies,
        })
    }

    pub fn try_clone(&self) -> Result<Box<TpmlTaggedPolicy<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<TpmlTaggedPolicy<'static>, TpmErr> {
        let Self {
            policies,
        } = self;

        let mut policies_orig = policies;
        let mut policies = Vec::new();
        policies.try_reserve_exact(policies_orig.len()).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))?;
        for element in policies_orig.drain(..) {
            let _ = policies.push(element.into_bufs_owner_intern()?);
        }

        Ok(TpmlTaggedPolicy {
            policies,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<TpmlTaggedPolicy<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpml_tagged_policy_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    size += mem::size_of::<u32>() as u32;

    let v0 = match limits.max_tagged_policies() {
        Ok(v) => v,
        Err(_) => {
            debug_assert!(false, "Unexpected runtime constant evaluation failure");
            return Err(());
        },
    };
    let policies_size = v0;
    let policies_size = policies_size.checked_mul(tpms_tagged_policy_marshalled_max_size() as u32).ok_or(())?;
    size = size.checked_add(policies_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 150, table 131, TPML_ACT_DATA structure
#[derive(Debug, PartialEq, Eq)]
pub struct TpmlActData {
    pub act_data: Vec<TpmsActData>,
}

impl TpmlActData {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpml_act_data_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let count_size = mem::size_of::<u32>();
        size = match size.checked_add(count_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let act_data_len = self.act_data.len();
        let act_data_element_size = match usize::try_from(tpms_act_data_marshalled_size()) {
            Ok(act_data_element_size) => act_data_element_size,
            Err(_) => {
                return Err(());
            },
        };
        let act_data_size = match act_data_len.checked_mul(act_data_element_size) {
            Some(act_data_size) => act_data_size,
            None => {
                return Err(());
            },
        };
        size = match size.checked_add(act_data_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let marshalled_count = match u32::try_from(self.act_data.len()) {
            Ok(marshalled_count) => marshalled_count,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::SIZE));
            },
        };
        let buf = marshal_u32(buf, marshalled_count)?;

        let mut buf = buf;
        for element in self.act_data.iter() {
            let remaining = element.marshal(buf)?;
            buf = remaining;
        }

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_count) = match unmarshal_u32(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let act_data_len: u32 = unmarshalled_count;
        let v0 = match limits.max_act_data() {
            Ok(v) => v,
            Err(_) => {
                debug_assert!(false, "Unexpected runtime constant evaluation failure");
                return Err(TpmErr::InternalErr);
            },
        };
        if act_data_len > v0 {
            return Err(TpmErr::Rc(TpmRc::SIZE));
        }
        let act_data_len = match usize::try_from(act_data_len) {
            Ok(act_data_len) => act_data_len,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::INSUFFICIENT));
            },
        };
        let mut unmarshalled_act_data: Vec<TpmsActData> = Vec::new();
        if unmarshalled_act_data.try_reserve_exact(act_data_len).is_err() {
            return Err(TpmErr::Rc(TpmRc::MEMORY));
        }
        let mut buf = buf;
        for _i in 0..act_data_len {
            let (remaining, unmarshalled_element) = match TpmsActData::unmarshal_intern(buf) {
                Ok(r) => r,
                Err(e) => {
                    return Err(e);
                },
            };
            unmarshalled_act_data.push(unmarshalled_element);
            buf = remaining;
        }

        Ok((buf, Self{act_data: unmarshalled_act_data}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<TpmlActData, TpmErr> {
        let act_data = copy_vec_from_slice(&self.act_data)?;

        Ok(TpmlActData {
            act_data,
        })
    }

    pub fn try_clone(&self) -> Result<Box<TpmlActData>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpml_act_data_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    size += mem::size_of::<u32>() as u32;

    let v0 = match limits.max_act_data() {
        Ok(v) => v,
        Err(_) => {
            debug_assert!(false, "Unexpected runtime constant evaluation failure");
            return Err(());
        },
    };
    let act_data_size = v0;
    let act_data_size = act_data_size.checked_mul(tpms_act_data_marshalled_size() as u32).ok_or(())?;
    size = size.checked_add(act_data_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 151, table 132, TPML_PUB_KEY structure
#[derive(Debug, PartialEq)]
pub struct TpmlPubKey<'a> {
    pub pub_keys: Vec<Tpm2bPublic<'a>>,
}

impl<'a> TpmlPubKey<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpml_pub_key_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let count_size = mem::size_of::<u32>();
        size = match size.checked_add(count_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let mut pub_keys_size: usize = 0;
        for element in self.pub_keys.iter() {
            let pub_keys_element_size = match element.marshalled_size() {
                Ok(pub_keys_element_size) => pub_keys_element_size,
                Err(_) => {
                    return Err(());
                },
            };
            pub_keys_size = match pub_keys_size.checked_add(pub_keys_element_size) {
                Some(pub_keys_size) => pub_keys_size,
                None => {
                    return Err(());
                },
            };
        }
        size = match size.checked_add(pub_keys_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let marshalled_count = match u32::try_from(self.pub_keys.len()) {
            Ok(marshalled_count) => marshalled_count,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::SIZE));
            },
        };
        let buf = marshal_u32(buf, marshalled_count)?;

        let mut buf = buf;
        for element in self.pub_keys.iter() {
            let remaining = element.marshal(buf)?;
            buf = remaining;
        }

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_count) = match unmarshal_u32(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let pub_keys_len: u32 = unmarshalled_count;
        let v0 = match limits.max_pub_keys() {
            Ok(v) => v,
            Err(_) => {
                debug_assert!(false, "Unexpected runtime constant evaluation failure");
                return Err(TpmErr::InternalErr);
            },
        };
        if pub_keys_len > v0 {
            return Err(TpmErr::Rc(TpmRc::SIZE));
        }
        let pub_keys_len = match usize::try_from(pub_keys_len) {
            Ok(pub_keys_len) => pub_keys_len,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::INSUFFICIENT));
            },
        };
        let mut unmarshalled_pub_keys: Vec<Tpm2bPublic<'a>> = Vec::new();
        if unmarshalled_pub_keys.try_reserve_exact(pub_keys_len).is_err() {
            return Err(TpmErr::Rc(TpmRc::MEMORY));
        }
        let mut buf = buf;
        for _i in 0..pub_keys_len {
            let (remaining, unmarshalled_element) = match Tpm2bPublic::unmarshal_intern(buf, limits) {
                Ok(r) => r,
                Err(e) => {
                    return Err(e);
                },
            };
            unmarshalled_pub_keys.push(unmarshalled_element);
            buf = remaining;
        }

        Ok((buf, Self{pub_keys: unmarshalled_pub_keys}))
    }

    pub fn unmarshal(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<TpmlPubKey<'static>, TpmErr> {
        let mut pub_keys = Vec::new();
        pub_keys.try_reserve_exact(self.pub_keys.len()).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))?;
        for element in self.pub_keys.iter() {
            let _ = pub_keys.push(element.try_clone_intern()?);
        }

        Ok(TpmlPubKey {
            pub_keys,
        })
    }

    pub fn try_clone(&self) -> Result<Box<TpmlPubKey<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<TpmlPubKey<'static>, TpmErr> {
        let Self {
            pub_keys,
        } = self;

        let mut pub_keys_orig = pub_keys;
        let mut pub_keys = Vec::new();
        pub_keys.try_reserve_exact(pub_keys_orig.len()).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))?;
        for element in pub_keys_orig.drain(..) {
            let _ = pub_keys.push(element.into_bufs_owner_intern()?);
        }

        Ok(TpmlPubKey {
            pub_keys,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<TpmlPubKey<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpml_pub_key_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    size += mem::size_of::<u32>() as u32;

    let v0 = match limits.max_pub_keys() {
        Ok(v) => v,
        Err(_) => {
            debug_assert!(false, "Unexpected runtime constant evaluation failure");
            return Err(());
        },
    };
    let pub_keys_size = v0;
    let pub_keys_element_size = match tpm2b_public_marshalled_max_size(limits) {
        Ok(pub_keys_element_size) => pub_keys_element_size,
        Err(_) => {
            return Err(());
        },
    };
    let pub_keys_size = pub_keys_size.checked_mul(pub_keys_element_size).ok_or(())?;
    size = size.checked_add(pub_keys_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 151, table 133, TPML_SPDM_SESSION_INFO structure
#[derive(Debug, PartialEq)]
pub struct TpmlSpdmSessionInfo<'a> {
    pub spdm_session_info: Vec<TpmsSpdmSessionInfo<'a>>,
}

impl<'a> TpmlSpdmSessionInfo<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpml_spdm_session_info_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let count_size = mem::size_of::<u32>();
        size = match size.checked_add(count_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let mut spdm_session_info_size: usize = 0;
        for element in self.spdm_session_info.iter() {
            let spdm_session_info_element_size = match element.marshalled_size() {
                Ok(spdm_session_info_element_size) => spdm_session_info_element_size,
                Err(_) => {
                    return Err(());
                },
            };
            spdm_session_info_size = match spdm_session_info_size.checked_add(spdm_session_info_element_size) {
                Some(spdm_session_info_size) => spdm_session_info_size,
                None => {
                    return Err(());
                },
            };
        }
        size = match size.checked_add(spdm_session_info_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let marshalled_count = match u32::try_from(self.spdm_session_info.len()) {
            Ok(marshalled_count) => marshalled_count,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::SIZE));
            },
        };
        let buf = marshal_u32(buf, marshalled_count)?;

        let mut buf = buf;
        for element in self.spdm_session_info.iter() {
            let remaining = element.marshal(buf)?;
            buf = remaining;
        }

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_count) = match unmarshal_u32(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let spdm_session_info_len: u32 = unmarshalled_count;
        let v0 = match limits.max_spdm_session_info() {
            Ok(v) => v,
            Err(_) => {
                debug_assert!(false, "Unexpected runtime constant evaluation failure");
                return Err(TpmErr::InternalErr);
            },
        };
        if spdm_session_info_len > v0 {
            return Err(TpmErr::Rc(TpmRc::SIZE));
        }
        let spdm_session_info_len = match usize::try_from(spdm_session_info_len) {
            Ok(spdm_session_info_len) => spdm_session_info_len,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::INSUFFICIENT));
            },
        };
        let mut unmarshalled_spdm_session_info: Vec<TpmsSpdmSessionInfo<'a>> = Vec::new();
        if unmarshalled_spdm_session_info.try_reserve_exact(spdm_session_info_len).is_err() {
            return Err(TpmErr::Rc(TpmRc::MEMORY));
        }
        let mut buf = buf;
        for _i in 0..spdm_session_info_len {
            let (remaining, unmarshalled_element) = match TpmsSpdmSessionInfo::unmarshal_intern(buf) {
                Ok(r) => r,
                Err(e) => {
                    return Err(e);
                },
            };
            unmarshalled_spdm_session_info.push(unmarshalled_element);
            buf = remaining;
        }

        Ok((buf, Self{spdm_session_info: unmarshalled_spdm_session_info}))
    }

    pub fn unmarshal(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<TpmlSpdmSessionInfo<'static>, TpmErr> {
        let mut spdm_session_info = Vec::new();
        spdm_session_info.try_reserve_exact(self.spdm_session_info.len()).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))?;
        for element in self.spdm_session_info.iter() {
            let _ = spdm_session_info.push(element.try_clone_intern()?);
        }

        Ok(TpmlSpdmSessionInfo {
            spdm_session_info,
        })
    }

    pub fn try_clone(&self) -> Result<Box<TpmlSpdmSessionInfo<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<TpmlSpdmSessionInfo<'static>, TpmErr> {
        let Self {
            spdm_session_info,
        } = self;

        let mut spdm_session_info_orig = spdm_session_info;
        let mut spdm_session_info = Vec::new();
        spdm_session_info.try_reserve_exact(spdm_session_info_orig.len()).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))?;
        for element in spdm_session_info_orig.drain(..) {
            let _ = spdm_session_info.push(element.into_bufs_owner_intern()?);
        }

        Ok(TpmlSpdmSessionInfo {
            spdm_session_info,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<TpmlSpdmSessionInfo<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpml_spdm_session_info_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    size += mem::size_of::<u32>() as u32;

    let v0 = match limits.max_spdm_session_info() {
        Ok(v) => v,
        Err(_) => {
            debug_assert!(false, "Unexpected runtime constant evaluation failure");
            return Err(());
        },
    };
    let spdm_session_info_size = v0;
    let spdm_session_info_size = spdm_session_info_size.checked_mul(tpms_spdm_session_info_marshalled_max_size() as u32).ok_or(())?;
    size = size.checked_add(spdm_session_info_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 151, table 134, TPML_VENDOR_PROPERTY structure
#[derive(Debug, PartialEq)]
pub struct TpmlVendorProperty<'a> {
    pub vendor_data: Vec<Tpm2bVendorProperty<'a>>,
}

impl<'a> TpmlVendorProperty<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpml_vendor_property_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let count_size = mem::size_of::<u32>();
        size = match size.checked_add(count_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let mut vendor_data_size: usize = 0;
        for element in self.vendor_data.iter() {
            let vendor_data_element_size = match element.marshalled_size() {
                Ok(vendor_data_element_size) => vendor_data_element_size,
                Err(_) => {
                    return Err(());
                },
            };
            vendor_data_size = match vendor_data_size.checked_add(vendor_data_element_size) {
                Some(vendor_data_size) => vendor_data_size,
                None => {
                    return Err(());
                },
            };
        }
        size = match size.checked_add(vendor_data_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let marshalled_count = match u32::try_from(self.vendor_data.len()) {
            Ok(marshalled_count) => marshalled_count,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::SIZE));
            },
        };
        let buf = marshal_u32(buf, marshalled_count)?;

        let mut buf = buf;
        for element in self.vendor_data.iter() {
            let remaining = element.marshal(buf)?;
            buf = remaining;
        }

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_count) = match unmarshal_u32(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let vendor_data_len: u32 = unmarshalled_count;
        let v0 = match limits.max_vendor_property() {
            Ok(v) => v,
            Err(_) => {
                debug_assert!(false, "Unexpected runtime constant evaluation failure");
                return Err(TpmErr::InternalErr);
            },
        };
        if vendor_data_len > v0 {
            return Err(TpmErr::Rc(TpmRc::SIZE));
        }
        let vendor_data_len = match usize::try_from(vendor_data_len) {
            Ok(vendor_data_len) => vendor_data_len,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::INSUFFICIENT));
            },
        };
        let mut unmarshalled_vendor_data: Vec<Tpm2bVendorProperty<'a>> = Vec::new();
        if unmarshalled_vendor_data.try_reserve_exact(vendor_data_len).is_err() {
            return Err(TpmErr::Rc(TpmRc::MEMORY));
        }
        let mut buf = buf;
        for _i in 0..vendor_data_len {
            let (remaining, unmarshalled_element) = match Tpm2bVendorProperty::unmarshal_intern(buf) {
                Ok(r) => r,
                Err(e) => {
                    return Err(e);
                },
            };
            unmarshalled_vendor_data.push(unmarshalled_element);
            buf = remaining;
        }

        Ok((buf, Self{vendor_data: unmarshalled_vendor_data}))
    }

    pub fn unmarshal(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<TpmlVendorProperty<'static>, TpmErr> {
        let mut vendor_data = Vec::new();
        vendor_data.try_reserve_exact(self.vendor_data.len()).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))?;
        for element in self.vendor_data.iter() {
            let _ = vendor_data.push(element.try_clone_intern()?);
        }

        Ok(TpmlVendorProperty {
            vendor_data,
        })
    }

    pub fn try_clone(&self) -> Result<Box<TpmlVendorProperty<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<TpmlVendorProperty<'static>, TpmErr> {
        let Self {
            vendor_data,
        } = self;

        let mut vendor_data_orig = vendor_data;
        let mut vendor_data = Vec::new();
        vendor_data.try_reserve_exact(vendor_data_orig.len()).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))?;
        for element in vendor_data_orig.drain(..) {
            let _ = vendor_data.push(element.into_bufs_owner_intern()?);
        }

        Ok(TpmlVendorProperty {
            vendor_data,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<TpmlVendorProperty<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpml_vendor_property_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    size += mem::size_of::<u32>() as u32;

    let v0 = match limits.max_vendor_property() {
        Ok(v) => v,
        Err(_) => {
            debug_assert!(false, "Unexpected runtime constant evaluation failure");
            return Err(());
        },
    };
    let vendor_data_size = v0;
    let vendor_data_size = vendor_data_size.checked_mul(tpm2b_vendor_property_marshalled_max_size() as u32).ok_or(())?;
    size = size.checked_add(vendor_data_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 152, table 135, TPMU_CAPABILITIES union
struct TpmuCapabilities {}

impl TpmuCapabilities {
    fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        let mut size: u32 = 0;

        let algorithms_size = match tpml_alg_property_marshalled_max_size(limits) {
            Ok(algorithms_size) => algorithms_size,
            Err(_) => {
                return Err(());
            },
        };
        if algorithms_size > size {
            size = algorithms_size;
        }

        let handles_size = match tpml_handle_marshalled_max_size(limits) {
            Ok(handles_size) => handles_size,
            Err(_) => {
                return Err(());
            },
        };
        if handles_size > size {
            size = handles_size;
        }

        let command_size = match tpml_cca_marshalled_max_size(limits) {
            Ok(command_size) => command_size,
            Err(_) => {
                return Err(());
            },
        };
        if command_size > size {
            size = command_size;
        }

        let pp_commands_size = match tpml_cc_marshalled_max_size(limits) {
            Ok(pp_commands_size) => pp_commands_size,
            Err(_) => {
                return Err(());
            },
        };
        if pp_commands_size > size {
            size = pp_commands_size;
        }

        let audit_commands_size = match tpml_cc_marshalled_max_size(limits) {
            Ok(audit_commands_size) => audit_commands_size,
            Err(_) => {
                return Err(());
            },
        };
        if audit_commands_size > size {
            size = audit_commands_size;
        }

        let assigned_pcr_size = match tpml_pcr_selection_marshalled_max_size(limits) {
            Ok(assigned_pcr_size) => assigned_pcr_size,
            Err(_) => {
                return Err(());
            },
        };
        if assigned_pcr_size > size {
            size = assigned_pcr_size;
        }

        let tpm_properties_size = match tpml_tagged_tpm_property_marshalled_max_size(limits) {
            Ok(tpm_properties_size) => tpm_properties_size,
            Err(_) => {
                return Err(());
            },
        };
        if tpm_properties_size > size {
            size = tpm_properties_size;
        }

        let pcr_properties_size = match tpml_tagged_pcr_property_marshalled_max_size(limits) {
            Ok(pcr_properties_size) => pcr_properties_size,
            Err(_) => {
                return Err(());
            },
        };
        if pcr_properties_size > size {
            size = pcr_properties_size;
        }

        #[cfg(feature = "ecc")]
        {
            let ecc_curves_size = match tpml_ecc_curve_marshalled_max_size(limits) {
                Ok(ecc_curves_size) => ecc_curves_size,
                Err(_) => {
                    return Err(());
                },
            };
            if ecc_curves_size > size {
                size = ecc_curves_size;
            }
        }

        let auth_policies_size = match tpml_tagged_policy_marshalled_max_size(limits) {
            Ok(auth_policies_size) => auth_policies_size,
            Err(_) => {
                return Err(());
            },
        };
        if auth_policies_size > size {
            size = auth_policies_size;
        }

        let act_data_size = match tpml_act_data_marshalled_max_size(limits) {
            Ok(act_data_size) => act_data_size,
            Err(_) => {
                return Err(());
            },
        };
        if act_data_size > size {
            size = act_data_size;
        }

        let pub_keys_size = match tpml_pub_key_marshalled_max_size(limits) {
            Ok(pub_keys_size) => pub_keys_size,
            Err(_) => {
                return Err(());
            },
        };
        if pub_keys_size > size {
            size = pub_keys_size;
        }

        let spdm_session_info_size = match tpml_spdm_session_info_marshalled_max_size(limits) {
            Ok(spdm_session_info_size) => spdm_session_info_size,
            Err(_) => {
                return Err(());
            },
        };
        if spdm_session_info_size > size {
            size = spdm_session_info_size;
        }

        let vendor_property_size = match tpml_vendor_property_marshalled_max_size(limits) {
            Ok(vendor_property_size) => vendor_property_size,
            Err(_) => {
                return Err(());
            },
        };
        if vendor_property_size > size {
            size = vendor_property_size;
        }

        Ok(size)
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 153, table 136, TPMS_CAPABILITY_DATA structure
#[derive(Debug, PartialEq)]
#[repr(u32)]
pub enum TpmsCapabilityData<'a> {
    Algs(TpmlAlgProperty) = TpmCap::Algs as u32,
    Handles(TpmlHandle) = TpmCap::Handles as u32,
    Commands(TpmlCca) = TpmCap::Commands as u32,
    PpCommands(TpmlCc) = TpmCap::PpCommands as u32,
    AuditCommands(TpmlCc) = TpmCap::AuditCommands as u32,
    Pcrs(TpmlPcrSelection<'a>) = TpmCap::Pcrs as u32,
    TpmProperties(TpmlTaggedTpmProperty) = TpmCap::TpmProperties as u32,
    PcrProperties(TpmlTaggedPcrProperty<'a>) = TpmCap::PcrProperties as u32,
    #[cfg(feature = "ecc")]
    EccCurves(TpmlEccCurve) = TpmCap::EccCurves as u32,
    AuthPolicies(TpmlTaggedPolicy<'a>) = TpmCap::AuthPolicies as u32,
    Act(TpmlActData) = TpmCap::Act as u32,
    PubKeys(TpmlPubKey<'a>) = TpmCap::PubKeys as u32,
    SpdmSessionInfo(TpmlSpdmSessionInfo<'a>) = TpmCap::SpdmSessionInfo as u32,
    VendorProperty(TpmlVendorProperty<'a>) = TpmCap::VendorProperty as u32,
}

impl<'a> TpmsCapabilityData<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpms_capability_data_marshalled_max_size(limits)
    }

    const fn marshalled_selector_size() -> u16 {
        TpmCap::marshalled_size()
    }

    fn marshalled_data_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;
        match self {
            Self::Algs(data) => {
                let data_size = match data.marshalled_size() {
                    Ok(data_size) => data_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(data_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            Self::Handles(data) => {
                let data_size = match data.marshalled_size() {
                    Ok(data_size) => data_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(data_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            Self::Commands(data) => {
                let data_size = match data.marshalled_size() {
                    Ok(data_size) => data_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(data_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            Self::PpCommands(data) => {
                let data_size = match data.marshalled_size() {
                    Ok(data_size) => data_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(data_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            Self::AuditCommands(data) => {
                let data_size = match data.marshalled_size() {
                    Ok(data_size) => data_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(data_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            Self::Pcrs(data) => {
                let data_size = match data.marshalled_size() {
                    Ok(data_size) => data_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(data_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            Self::TpmProperties(data) => {
                let data_size = match data.marshalled_size() {
                    Ok(data_size) => data_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(data_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            Self::PcrProperties(data) => {
                let data_size = match data.marshalled_size() {
                    Ok(data_size) => data_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(data_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(feature = "ecc")]
            Self::EccCurves(data) => {
                let data_size = match data.marshalled_size() {
                    Ok(data_size) => data_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(data_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            Self::AuthPolicies(data) => {
                let data_size = match data.marshalled_size() {
                    Ok(data_size) => data_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(data_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            Self::Act(data) => {
                let data_size = match data.marshalled_size() {
                    Ok(data_size) => data_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(data_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            Self::PubKeys(data) => {
                let data_size = match data.marshalled_size() {
                    Ok(data_size) => data_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(data_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            Self::SpdmSessionInfo(data) => {
                let data_size = match data.marshalled_size() {
                    Ok(data_size) => data_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(data_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            Self::VendorProperty(data) => {
                let data_size = match data.marshalled_size() {
                    Ok(data_size) => data_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(data_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
        };

        Ok(size)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let selector_size = match usize::try_from(Self::marshalled_selector_size()) {
            Ok(selector_size) => selector_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(selector_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let data_size = match self.marshalled_data_size() {
            Ok(data_size) => data_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(data_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = match self {
            Self::Algs(data) => {
                let selector = TpmCap::Algs as u32;
                let buf = marshal_u32(buf, selector)?;

                let buf = data.marshal(buf)?;

                buf
            },
            Self::Handles(data) => {
                let selector = TpmCap::Handles as u32;
                let buf = marshal_u32(buf, selector)?;

                let buf = data.marshal(buf)?;

                buf
            },
            Self::Commands(data) => {
                let selector = TpmCap::Commands as u32;
                let buf = marshal_u32(buf, selector)?;

                let buf = data.marshal(buf)?;

                buf
            },
            Self::PpCommands(data) => {
                let selector = TpmCap::PpCommands as u32;
                let buf = marshal_u32(buf, selector)?;

                let buf = data.marshal(buf)?;

                buf
            },
            Self::AuditCommands(data) => {
                let selector = TpmCap::AuditCommands as u32;
                let buf = marshal_u32(buf, selector)?;

                let buf = data.marshal(buf)?;

                buf
            },
            Self::Pcrs(data) => {
                let selector = TpmCap::Pcrs as u32;
                let buf = marshal_u32(buf, selector)?;

                let buf = data.marshal(buf)?;

                buf
            },
            Self::TpmProperties(data) => {
                let selector = TpmCap::TpmProperties as u32;
                let buf = marshal_u32(buf, selector)?;

                let buf = data.marshal(buf)?;

                buf
            },
            Self::PcrProperties(data) => {
                let selector = TpmCap::PcrProperties as u32;
                let buf = marshal_u32(buf, selector)?;

                let buf = data.marshal(buf)?;

                buf
            },
            #[cfg(feature = "ecc")]
            Self::EccCurves(data) => {
                let selector = TpmCap::EccCurves as u32;
                let buf = marshal_u32(buf, selector)?;

                let buf = data.marshal(buf)?;

                buf
            },
            Self::AuthPolicies(data) => {
                let selector = TpmCap::AuthPolicies as u32;
                let buf = marshal_u32(buf, selector)?;

                let buf = data.marshal(buf)?;

                buf
            },
            Self::Act(data) => {
                let selector = TpmCap::Act as u32;
                let buf = marshal_u32(buf, selector)?;

                let buf = data.marshal(buf)?;

                buf
            },
            Self::PubKeys(data) => {
                let selector = TpmCap::PubKeys as u32;
                let buf = marshal_u32(buf, selector)?;

                let buf = data.marshal(buf)?;

                buf
            },
            Self::SpdmSessionInfo(data) => {
                let selector = TpmCap::SpdmSessionInfo as u32;
                let buf = marshal_u32(buf, selector)?;

                let buf = data.marshal(buf)?;

                buf
            },
            Self::VendorProperty(data) => {
                let selector = TpmCap::VendorProperty as u32;
                let buf = marshal_u32(buf, selector)?;

                let buf = data.marshal(buf)?;

                buf
            },
        };
        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_capability) = match unmarshal_u32(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, r) = match unmarshalled_capability {
            value if value == TpmCap::Algs as u32 => {
                let (buf, unmarshalled_data) = match TpmlAlgProperty::unmarshal_intern(buf, limits) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Algs(unmarshalled_data))
            },
            value if value == TpmCap::Handles as u32 => {
                let (buf, unmarshalled_data) = match TpmlHandle::unmarshal_intern(buf, limits) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Handles(unmarshalled_data))
            },
            value if value == TpmCap::Commands as u32 => {
                let (buf, unmarshalled_data) = match TpmlCca::unmarshal_intern(buf, limits) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Commands(unmarshalled_data))
            },
            value if value == TpmCap::PpCommands as u32 => {
                let (buf, unmarshalled_data) = match TpmlCc::unmarshal_intern(buf, limits) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::PpCommands(unmarshalled_data))
            },
            value if value == TpmCap::AuditCommands as u32 => {
                let (buf, unmarshalled_data) = match TpmlCc::unmarshal_intern(buf, limits) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::AuditCommands(unmarshalled_data))
            },
            value if value == TpmCap::Pcrs as u32 => {
                let (buf, unmarshalled_data) = match TpmlPcrSelection::unmarshal_intern(buf, limits) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Pcrs(unmarshalled_data))
            },
            value if value == TpmCap::TpmProperties as u32 => {
                let (buf, unmarshalled_data) = match TpmlTaggedTpmProperty::unmarshal_intern(buf, limits) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::TpmProperties(unmarshalled_data))
            },
            value if value == TpmCap::PcrProperties as u32 => {
                let (buf, unmarshalled_data) = match TpmlTaggedPcrProperty::unmarshal_intern(buf, limits) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::PcrProperties(unmarshalled_data))
            },
            #[cfg(feature = "ecc")]
            value if value == TpmCap::EccCurves as u32 => {
                let (buf, unmarshalled_data) = match TpmlEccCurve::unmarshal_intern(buf, limits) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::EccCurves(unmarshalled_data))
            },
            value if value == TpmCap::AuthPolicies as u32 => {
                let (buf, unmarshalled_data) = match TpmlTaggedPolicy::unmarshal_intern(buf, limits) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::AuthPolicies(unmarshalled_data))
            },
            value if value == TpmCap::Act as u32 => {
                let (buf, unmarshalled_data) = match TpmlActData::unmarshal_intern(buf, limits) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Act(unmarshalled_data))
            },
            value if value == TpmCap::PubKeys as u32 => {
                let (buf, unmarshalled_data) = match TpmlPubKey::unmarshal_intern(buf, limits) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::PubKeys(unmarshalled_data))
            },
            value if value == TpmCap::SpdmSessionInfo as u32 => {
                let (buf, unmarshalled_data) = match TpmlSpdmSessionInfo::unmarshal_intern(buf, limits) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::SpdmSessionInfo(unmarshalled_data))
            },
            value if value == TpmCap::VendorProperty as u32 => {
                let (buf, unmarshalled_data) = match TpmlVendorProperty::unmarshal_intern(buf, limits) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::VendorProperty(unmarshalled_data))
            },
            _ => {
                return Err(TpmErr::Rc(TpmRc::VALUE));
            },
        };

        Ok((buf, r))
    }

    pub fn unmarshal(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<TpmsCapabilityData<'static>, TpmErr> {
        match self {
            Self::Algs(data) => {
                Ok(TpmsCapabilityData::Algs(
                    data.try_clone_intern()?,
                ))
            },
            Self::Handles(data) => {
                Ok(TpmsCapabilityData::Handles(
                    data.try_clone_intern()?,
                ))
            },
            Self::Commands(data) => {
                Ok(TpmsCapabilityData::Commands(
                    data.try_clone_intern()?,
                ))
            },
            Self::PpCommands(data) => {
                Ok(TpmsCapabilityData::PpCommands(
                    data.try_clone_intern()?,
                ))
            },
            Self::AuditCommands(data) => {
                Ok(TpmsCapabilityData::AuditCommands(
                    data.try_clone_intern()?,
                ))
            },
            Self::Pcrs(data) => {
                Ok(TpmsCapabilityData::Pcrs(
                    data.try_clone_intern()?,
                ))
            },
            Self::TpmProperties(data) => {
                Ok(TpmsCapabilityData::TpmProperties(
                    data.try_clone_intern()?,
                ))
            },
            Self::PcrProperties(data) => {
                Ok(TpmsCapabilityData::PcrProperties(
                    data.try_clone_intern()?,
                ))
            },
            #[cfg(feature = "ecc")]
            Self::EccCurves(data) => {
                Ok(TpmsCapabilityData::EccCurves(
                    data.try_clone_intern()?,
                ))
            },
            Self::AuthPolicies(data) => {
                Ok(TpmsCapabilityData::AuthPolicies(
                    data.try_clone_intern()?,
                ))
            },
            Self::Act(data) => {
                Ok(TpmsCapabilityData::Act(
                    data.try_clone_intern()?,
                ))
            },
            Self::PubKeys(data) => {
                Ok(TpmsCapabilityData::PubKeys(
                    data.try_clone_intern()?,
                ))
            },
            Self::SpdmSessionInfo(data) => {
                Ok(TpmsCapabilityData::SpdmSessionInfo(
                    data.try_clone_intern()?,
                ))
            },
            Self::VendorProperty(data) => {
                Ok(TpmsCapabilityData::VendorProperty(
                    data.try_clone_intern()?,
                ))
            },
        }
    }

    pub fn try_clone(&self) -> Result<Box<TpmsCapabilityData<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<TpmsCapabilityData<'static>, TpmErr> {
        match self {
            Self::Algs(data) => {
                Ok(TpmsCapabilityData::Algs(data))
            },
            Self::Handles(data) => {
                Ok(TpmsCapabilityData::Handles(data))
            },
            Self::Commands(data) => {
                Ok(TpmsCapabilityData::Commands(data))
            },
            Self::PpCommands(data) => {
                Ok(TpmsCapabilityData::PpCommands(data))
            },
            Self::AuditCommands(data) => {
                Ok(TpmsCapabilityData::AuditCommands(data))
            },
            Self::Pcrs(data) => {
                let data = data.into_bufs_owner_intern()?;
                Ok(TpmsCapabilityData::Pcrs(data))
            },
            Self::TpmProperties(data) => {
                Ok(TpmsCapabilityData::TpmProperties(data))
            },
            Self::PcrProperties(data) => {
                let data = data.into_bufs_owner_intern()?;
                Ok(TpmsCapabilityData::PcrProperties(data))
            },
            #[cfg(feature = "ecc")]
            Self::EccCurves(data) => {
                Ok(TpmsCapabilityData::EccCurves(data))
            },
            Self::AuthPolicies(data) => {
                let data = data.into_bufs_owner_intern()?;
                Ok(TpmsCapabilityData::AuthPolicies(data))
            },
            Self::Act(data) => {
                Ok(TpmsCapabilityData::Act(data))
            },
            Self::PubKeys(data) => {
                let data = data.into_bufs_owner_intern()?;
                Ok(TpmsCapabilityData::PubKeys(data))
            },
            Self::SpdmSessionInfo(data) => {
                let data = data.into_bufs_owner_intern()?;
                Ok(TpmsCapabilityData::SpdmSessionInfo(data))
            },
            Self::VendorProperty(data) => {
                let data = data.into_bufs_owner_intern()?;
                Ok(TpmsCapabilityData::VendorProperty(data))
            },
        }
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<TpmsCapabilityData<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpms_capability_data_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    size += TpmCap::marshalled_size() as u32;

    let data_size = match TpmuCapabilities::marshalled_max_size(limits) {
        Ok(data_size) => data_size,
        Err(_) => return Err(()),
    };
    size = size.checked_add(data_size).ok_or(())?;

    Ok(size)
}

impl<'a> convert::From<&TpmsCapabilityData<'a>> for TpmCap {
    fn from(value: &TpmsCapabilityData<'a>) -> Self {
        match value {
            TpmsCapabilityData::Algs(_) => Self::Algs,
            TpmsCapabilityData::Handles(_) => Self::Handles,
            TpmsCapabilityData::Commands(_) => Self::Commands,
            TpmsCapabilityData::PpCommands(_) => Self::PpCommands,
            TpmsCapabilityData::AuditCommands(_) => Self::AuditCommands,
            TpmsCapabilityData::Pcrs(_) => Self::Pcrs,
            TpmsCapabilityData::TpmProperties(_) => Self::TpmProperties,
            TpmsCapabilityData::PcrProperties(_) => Self::PcrProperties,
            #[cfg(feature = "ecc")]
            TpmsCapabilityData::EccCurves(_) => Self::EccCurves,
            TpmsCapabilityData::AuthPolicies(_) => Self::AuthPolicies,
            TpmsCapabilityData::Act(_) => Self::Act,
            TpmsCapabilityData::PubKeys(_) => Self::PubKeys,
            TpmsCapabilityData::SpdmSessionInfo(_) => Self::SpdmSessionInfo,
            TpmsCapabilityData::VendorProperty(_) => Self::VendorProperty,
        }
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 153, table 137, TPMS_SET_CAPABILITY_DATA structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u32)]
pub enum TpmsSetCapabilityData {
    Algs = TpmCap::Algs as u32,
    Handles = TpmCap::Handles as u32,
    Commands = TpmCap::Commands as u32,
    PpCommands = TpmCap::PpCommands as u32,
    AuditCommands = TpmCap::AuditCommands as u32,
    Pcrs = TpmCap::Pcrs as u32,
    TpmProperties = TpmCap::TpmProperties as u32,
    PcrProperties = TpmCap::PcrProperties as u32,
    #[cfg(feature = "ecc")]
    EccCurves = TpmCap::EccCurves as u32,
    AuthPolicies = TpmCap::AuthPolicies as u32,
    Act = TpmCap::Act as u32,
    PubKeys = TpmCap::PubKeys as u32,
    SpdmSessionInfo = TpmCap::SpdmSessionInfo as u32,
    VendorProperty = TpmCap::VendorProperty as u32,
}

impl TpmsSetCapabilityData {
    pub const fn marshalled_max_size() -> u16 {
        tpms_set_capability_data_marshalled_max_size()
    }

    const fn marshalled_selector_size() -> u16 {
        TpmCap::marshalled_size()
    }

    fn marshalled_data_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;
        match self {
            Self::Algs => (),
            Self::Handles => (),
            Self::Commands => (),
            Self::PpCommands => (),
            Self::AuditCommands => (),
            Self::Pcrs => (),
            Self::TpmProperties => (),
            Self::PcrProperties => (),
            #[cfg(feature = "ecc")]
            Self::EccCurves => (),
            Self::AuthPolicies => (),
            Self::Act => (),
            Self::PubKeys => (),
            Self::SpdmSessionInfo => (),
            Self::VendorProperty => (),
        };

        Ok(size)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let selector_size = match usize::try_from(Self::marshalled_selector_size()) {
            Ok(selector_size) => selector_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(selector_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let data_size = match self.marshalled_data_size() {
            Ok(data_size) => data_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(data_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = match self {
            Self::Algs => {
                let selector = TpmCap::Algs as u32;
                let buf = marshal_u32(buf, selector)?;

                buf
            },
            Self::Handles => {
                let selector = TpmCap::Handles as u32;
                let buf = marshal_u32(buf, selector)?;

                buf
            },
            Self::Commands => {
                let selector = TpmCap::Commands as u32;
                let buf = marshal_u32(buf, selector)?;

                buf
            },
            Self::PpCommands => {
                let selector = TpmCap::PpCommands as u32;
                let buf = marshal_u32(buf, selector)?;

                buf
            },
            Self::AuditCommands => {
                let selector = TpmCap::AuditCommands as u32;
                let buf = marshal_u32(buf, selector)?;

                buf
            },
            Self::Pcrs => {
                let selector = TpmCap::Pcrs as u32;
                let buf = marshal_u32(buf, selector)?;

                buf
            },
            Self::TpmProperties => {
                let selector = TpmCap::TpmProperties as u32;
                let buf = marshal_u32(buf, selector)?;

                buf
            },
            Self::PcrProperties => {
                let selector = TpmCap::PcrProperties as u32;
                let buf = marshal_u32(buf, selector)?;

                buf
            },
            #[cfg(feature = "ecc")]
            Self::EccCurves => {
                let selector = TpmCap::EccCurves as u32;
                let buf = marshal_u32(buf, selector)?;

                buf
            },
            Self::AuthPolicies => {
                let selector = TpmCap::AuthPolicies as u32;
                let buf = marshal_u32(buf, selector)?;

                buf
            },
            Self::Act => {
                let selector = TpmCap::Act as u32;
                let buf = marshal_u32(buf, selector)?;

                buf
            },
            Self::PubKeys => {
                let selector = TpmCap::PubKeys as u32;
                let buf = marshal_u32(buf, selector)?;

                buf
            },
            Self::SpdmSessionInfo => {
                let selector = TpmCap::SpdmSessionInfo as u32;
                let buf = marshal_u32(buf, selector)?;

                buf
            },
            Self::VendorProperty => {
                let selector = TpmCap::VendorProperty as u32;
                let buf = marshal_u32(buf, selector)?;

                buf
            },
        };
        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_set_capability) = match unmarshal_u32(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, r) = match unmarshalled_set_capability {
            value if value == TpmCap::Algs as u32 => {
                (buf, Self::Algs)
            },
            value if value == TpmCap::Handles as u32 => {
                (buf, Self::Handles)
            },
            value if value == TpmCap::Commands as u32 => {
                (buf, Self::Commands)
            },
            value if value == TpmCap::PpCommands as u32 => {
                (buf, Self::PpCommands)
            },
            value if value == TpmCap::AuditCommands as u32 => {
                (buf, Self::AuditCommands)
            },
            value if value == TpmCap::Pcrs as u32 => {
                (buf, Self::Pcrs)
            },
            value if value == TpmCap::TpmProperties as u32 => {
                (buf, Self::TpmProperties)
            },
            value if value == TpmCap::PcrProperties as u32 => {
                (buf, Self::PcrProperties)
            },
            #[cfg(feature = "ecc")]
            value if value == TpmCap::EccCurves as u32 => {
                (buf, Self::EccCurves)
            },
            value if value == TpmCap::AuthPolicies as u32 => {
                (buf, Self::AuthPolicies)
            },
            value if value == TpmCap::Act as u32 => {
                (buf, Self::Act)
            },
            value if value == TpmCap::PubKeys as u32 => {
                (buf, Self::PubKeys)
            },
            value if value == TpmCap::SpdmSessionInfo as u32 => {
                (buf, Self::SpdmSessionInfo)
            },
            value if value == TpmCap::VendorProperty as u32 => {
                (buf, Self::VendorProperty)
            },
            _ => {
                return Err(TpmErr::Rc(TpmRc::VALUE));
            },
        };

        Ok((buf, r))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpms_set_capability_data_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmCap::marshalled_size();
    size += TpmuSetCapabilities::marshalled_max_size();

    size
}

impl convert::From<&TpmsSetCapabilityData> for TpmCap {
    fn from(value: &TpmsSetCapabilityData) -> Self {
        match value {
            TpmsSetCapabilityData::Algs => Self::Algs,
            TpmsSetCapabilityData::Handles => Self::Handles,
            TpmsSetCapabilityData::Commands => Self::Commands,
            TpmsSetCapabilityData::PpCommands => Self::PpCommands,
            TpmsSetCapabilityData::AuditCommands => Self::AuditCommands,
            TpmsSetCapabilityData::Pcrs => Self::Pcrs,
            TpmsSetCapabilityData::TpmProperties => Self::TpmProperties,
            TpmsSetCapabilityData::PcrProperties => Self::PcrProperties,
            #[cfg(feature = "ecc")]
            TpmsSetCapabilityData::EccCurves => Self::EccCurves,
            TpmsSetCapabilityData::AuthPolicies => Self::AuthPolicies,
            TpmsSetCapabilityData::Act => Self::Act,
            TpmsSetCapabilityData::PubKeys => Self::PubKeys,
            TpmsSetCapabilityData::SpdmSessionInfo => Self::SpdmSessionInfo,
            TpmsSetCapabilityData::VendorProperty => Self::VendorProperty,
        }
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 153, table 138, TPM2B_SET_CAPABILITY_DATA structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2bSetCapabilityData {
    pub set_capability_data: TpmsSetCapabilityData,
}

impl Tpm2bSetCapabilityData {
    pub const fn marshalled_max_size() -> u16 {
        tpm2b_set_capability_data_marshalled_max_size()
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let size_size = mem::size_of::<u16>();
        size = match size.checked_add(size_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let set_capability_data_size = match self.set_capability_data.marshalled_size() {
            Ok(set_capability_data_size) => set_capability_data_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(set_capability_data_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let mut marshalled_size: usize = 0;

        let set_capability_data_size = match self.set_capability_data.marshalled_size() {
            Ok(set_capability_data_size) => set_capability_data_size,
            Err(_) => {
                return Err(TpmErr::InternalErr);
            },
        };
        marshalled_size = match marshalled_size.checked_add(set_capability_data_size) {
            Some(marshalled_size) => marshalled_size,
            None => {
                return Err(TpmErr::InternalErr);
            },
        };

        let marshalled_size = match u16::try_from(marshalled_size) {
            Ok(marshalled_size) => marshalled_size,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::SIZE));
            },
        };
        let buf = marshal_u16(buf, marshalled_size)?;

        let buf = self.set_capability_data.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_size) = match unmarshal_u16(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let unmarshalled_size = match usize::try_from(unmarshalled_size) {
            Ok(unmarshalled_size) => unmarshalled_size,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::SIZE));
            },
        };
        if unmarshalled_size == 0usize {
            return Err(TpmErr::Rc(TpmRc::SIZE));
        }
        let buf_len_at_size = buf.len();

        let (buf, unmarshalled_set_capability_data) = match TpmsSetCapabilityData::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        if unmarshalled_size != buf_len_at_size - buf.len() {
            return Err(TpmErr::Rc(TpmRc::SIZE));
        }

        Ok((buf, Self{set_capability_data: unmarshalled_set_capability_data}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2b_set_capability_data_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += mem::size_of::<u16>() as u16;
    size += tpms_set_capability_data_marshalled_max_size();

    size
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 153, table 139, TPMS_CLOCK_INFO structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct TpmsClockInfo {
    pub clock: u64,
    pub reset_count: u32,
    pub restart_count: u32,
    pub safe: TpmiYesNo,
}

impl TpmsClockInfo {
    pub const fn marshalled_size() -> u16 {
        tpms_clock_info_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = marshal_u64(buf, self.clock)?;

        let buf = marshal_u32(buf, self.reset_count)?;

        let buf = marshal_u32(buf, self.restart_count)?;

        let buf = self.safe.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_clock) = match unmarshal_u64(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_reset_count) = match unmarshal_u32(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_restart_count) = match unmarshal_u32(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_safe) = match TpmiYesNo::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{clock: unmarshalled_clock, reset_count: unmarshalled_reset_count, restart_count: unmarshalled_restart_count, safe: unmarshalled_safe}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpms_clock_info_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += mem::size_of::<u64>() as u16;
    size += mem::size_of::<u32>() as u16;
    size += mem::size_of::<u32>() as u16;
    size += TpmiYesNo::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 155, table 140, TPMS_TIME_INFO structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct TpmsTimeInfo {
    pub time: u64,
    pub clock_info: TpmsClockInfo,
}

impl TpmsTimeInfo {
    pub const fn marshalled_size() -> u16 {
        tpms_time_info_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = marshal_u64(buf, self.time)?;

        let buf = self.clock_info.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_time) = match unmarshal_u64(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_clock_info) = match TpmsClockInfo::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{time: unmarshalled_time, clock_info: unmarshalled_clock_info}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpms_time_info_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += mem::size_of::<u64>() as u16;
    size += tpms_clock_info_marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 155, table 141, TPMS_TIME_ATTEST_INFO structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct TpmsTimeAttestInfo {
    pub time: TpmsTimeInfo,
    pub firmware_version: u64,
}

impl TpmsTimeAttestInfo {
    pub const fn marshalled_size() -> u16 {
        tpms_time_attest_info_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.time.marshal(buf)?;

        let buf = marshal_u64(buf, self.firmware_version)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_time) = match TpmsTimeInfo::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_firmware_version) = match unmarshal_u64(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{time: unmarshalled_time, firmware_version: unmarshalled_firmware_version}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpms_time_attest_info_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += tpms_time_info_marshalled_size();
    size += mem::size_of::<u64>() as u16;

    size
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 156, table 142, TPMS_CERTIFY_INFO structure
#[derive(Debug, PartialEq)]
pub struct TpmsCertifyInfo<'a> {
    pub name: Tpm2bName<'a>,
    pub qualified_name: Tpm2bName<'a>,
}

impl<'a> TpmsCertifyInfo<'a> {
    pub const fn marshalled_max_size() -> u16 {
        tpms_certify_info_marshalled_max_size()
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let name_size = match self.name.marshalled_size() {
            Ok(name_size) => name_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(name_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let qualified_name_size = match self.qualified_name.marshalled_size() {
            Ok(qualified_name_size) => qualified_name_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(qualified_name_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.name.marshal(buf)?;

        let buf = self.qualified_name.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_name) = match Tpm2bName::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_qualified_name) = match Tpm2bName::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{name: unmarshalled_name, qualified_name: unmarshalled_qualified_name}))
    }

    pub fn unmarshal(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<TpmsCertifyInfo<'static>, TpmErr> {
        Ok(TpmsCertifyInfo {
            name: self.name.try_clone_intern()?,
            qualified_name: self.qualified_name.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<TpmsCertifyInfo<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<TpmsCertifyInfo<'static>, TpmErr> {
        let Self {
            name,
            qualified_name,
        } = self;

        let name = name.into_bufs_owner_intern()?;
        let qualified_name = qualified_name.into_bufs_owner_intern()?;

        Ok(TpmsCertifyInfo {
            name,
            qualified_name,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<TpmsCertifyInfo<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

const fn tpms_certify_info_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += tpm2b_name_marshalled_max_size();
    size += tpm2b_name_marshalled_max_size();

    size
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 156, table 143, TPMS_QUOTE_INFO structure
#[derive(Debug, PartialEq)]
pub struct TpmsQuoteInfo<'a> {
    pub pcr_select: TpmlPcrSelection<'a>,
    pub pcr_digest: Tpm2bDigest<'a>,
}

impl<'a> TpmsQuoteInfo<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpms_quote_info_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let pcr_select_size = match self.pcr_select.marshalled_size() {
            Ok(pcr_select_size) => pcr_select_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(pcr_select_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let pcr_digest_size = match self.pcr_digest.marshalled_size() {
            Ok(pcr_digest_size) => pcr_digest_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(pcr_digest_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.pcr_select.marshal(buf)?;

        let buf = self.pcr_digest.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_pcr_select) = match TpmlPcrSelection::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_pcr_digest) = match Tpm2bDigest::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{pcr_select: unmarshalled_pcr_select, pcr_digest: unmarshalled_pcr_digest}))
    }

    pub fn unmarshal(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<TpmsQuoteInfo<'static>, TpmErr> {
        Ok(TpmsQuoteInfo {
            pcr_select: self.pcr_select.try_clone_intern()?,
            pcr_digest: self.pcr_digest.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<TpmsQuoteInfo<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<TpmsQuoteInfo<'static>, TpmErr> {
        let Self {
            pcr_select,
            pcr_digest,
        } = self;

        let pcr_select = pcr_select.into_bufs_owner_intern()?;
        let pcr_digest = pcr_digest.into_bufs_owner_intern()?;

        Ok(TpmsQuoteInfo {
            pcr_select,
            pcr_digest,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<TpmsQuoteInfo<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpms_quote_info_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    size += tpm2b_digest_marshalled_max_size() as u32;

    let pcr_select_size = match tpml_pcr_selection_marshalled_max_size(limits) {
        Ok(pcr_select_size) => pcr_select_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(pcr_select_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 156, table 144, TPMS_COMMAND_AUDIT_INFO structure
#[derive(Debug, PartialEq)]
pub struct TpmsCommandAuditInfo<'a> {
    pub audit_counter: u64,
    pub digest_alg: TpmAlgId,
    pub audit_digest: Tpm2bDigest<'a>,
    pub command_digest: Tpm2bDigest<'a>,
}

impl<'a> TpmsCommandAuditInfo<'a> {
    pub const fn marshalled_max_size() -> u16 {
        tpms_command_audit_info_marshalled_max_size()
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let audit_counter_size = mem::size_of::<u64>();
        size = match size.checked_add(audit_counter_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let digest_alg_size = match usize::try_from(TpmAlgId::marshalled_size()) {
            Ok(digest_alg_size) => digest_alg_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(digest_alg_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let audit_digest_size = match self.audit_digest.marshalled_size() {
            Ok(audit_digest_size) => audit_digest_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(audit_digest_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let command_digest_size = match self.command_digest.marshalled_size() {
            Ok(command_digest_size) => command_digest_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(command_digest_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = marshal_u64(buf, self.audit_counter)?;

        let buf = self.digest_alg.marshal(buf)?;

        let buf = self.audit_digest.marshal(buf)?;

        let buf = self.command_digest.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_audit_counter) = match unmarshal_u64(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_digest_alg) = match TpmAlgId::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_audit_digest) = match Tpm2bDigest::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_command_digest) = match Tpm2bDigest::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{audit_counter: unmarshalled_audit_counter, digest_alg: unmarshalled_digest_alg, audit_digest: unmarshalled_audit_digest, command_digest: unmarshalled_command_digest}))
    }

    pub fn unmarshal(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<TpmsCommandAuditInfo<'static>, TpmErr> {
        Ok(TpmsCommandAuditInfo {
            audit_counter: self.audit_counter,
            digest_alg: self.digest_alg,
            audit_digest: self.audit_digest.try_clone_intern()?,
            command_digest: self.command_digest.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<TpmsCommandAuditInfo<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<TpmsCommandAuditInfo<'static>, TpmErr> {
        let Self {
            audit_counter,
            digest_alg,
            audit_digest,
            command_digest,
        } = self;

        let audit_digest = audit_digest.into_bufs_owner_intern()?;
        let command_digest = command_digest.into_bufs_owner_intern()?;

        Ok(TpmsCommandAuditInfo {
            audit_counter,
            digest_alg,
            audit_digest,
            command_digest,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<TpmsCommandAuditInfo<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

const fn tpms_command_audit_info_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += mem::size_of::<u64>() as u16;
    size += TpmAlgId::marshalled_size();
    size += tpm2b_digest_marshalled_max_size();
    size += tpm2b_digest_marshalled_max_size();

    size
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 156, table 145, TPMS_SESSION_AUDIT_INFO structure
#[derive(Debug, PartialEq)]
pub struct TpmsSessionAuditInfo<'a> {
    pub exclusive_session: TpmiYesNo,
    pub session_digest: Tpm2bDigest<'a>,
}

impl<'a> TpmsSessionAuditInfo<'a> {
    pub const fn marshalled_max_size() -> u16 {
        tpms_session_audit_info_marshalled_max_size()
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let exclusive_session_size = match usize::try_from(TpmiYesNo::marshalled_size()) {
            Ok(exclusive_session_size) => exclusive_session_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(exclusive_session_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let session_digest_size = match self.session_digest.marshalled_size() {
            Ok(session_digest_size) => session_digest_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(session_digest_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.exclusive_session.marshal(buf)?;

        let buf = self.session_digest.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_exclusive_session) = match TpmiYesNo::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_session_digest) = match Tpm2bDigest::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{exclusive_session: unmarshalled_exclusive_session, session_digest: unmarshalled_session_digest}))
    }

    pub fn unmarshal(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<TpmsSessionAuditInfo<'static>, TpmErr> {
        Ok(TpmsSessionAuditInfo {
            exclusive_session: self.exclusive_session,
            session_digest: self.session_digest.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<TpmsSessionAuditInfo<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<TpmsSessionAuditInfo<'static>, TpmErr> {
        let Self {
            exclusive_session,
            session_digest,
        } = self;

        let session_digest = session_digest.into_bufs_owner_intern()?;

        Ok(TpmsSessionAuditInfo {
            exclusive_session,
            session_digest,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<TpmsSessionAuditInfo<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

const fn tpms_session_audit_info_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiYesNo::marshalled_size();
    size += tpm2b_digest_marshalled_max_size();

    size
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 157, table 146, TPMS_CREATION_INFO structure
#[derive(Debug, PartialEq)]
pub struct TpmsCreationInfo<'a> {
    pub object_name: Tpm2bName<'a>,
    pub creation_hash: Tpm2bDigest<'a>,
}

impl<'a> TpmsCreationInfo<'a> {
    pub const fn marshalled_max_size() -> u16 {
        tpms_creation_info_marshalled_max_size()
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let object_name_size = match self.object_name.marshalled_size() {
            Ok(object_name_size) => object_name_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(object_name_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let creation_hash_size = match self.creation_hash.marshalled_size() {
            Ok(creation_hash_size) => creation_hash_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(creation_hash_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.object_name.marshal(buf)?;

        let buf = self.creation_hash.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_object_name) = match Tpm2bName::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_creation_hash) = match Tpm2bDigest::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{object_name: unmarshalled_object_name, creation_hash: unmarshalled_creation_hash}))
    }

    pub fn unmarshal(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<TpmsCreationInfo<'static>, TpmErr> {
        Ok(TpmsCreationInfo {
            object_name: self.object_name.try_clone_intern()?,
            creation_hash: self.creation_hash.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<TpmsCreationInfo<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<TpmsCreationInfo<'static>, TpmErr> {
        let Self {
            object_name,
            creation_hash,
        } = self;

        let object_name = object_name.into_bufs_owner_intern()?;
        let creation_hash = creation_hash.into_bufs_owner_intern()?;

        Ok(TpmsCreationInfo {
            object_name,
            creation_hash,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<TpmsCreationInfo<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

const fn tpms_creation_info_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += tpm2b_name_marshalled_max_size();
    size += tpm2b_digest_marshalled_max_size();

    size
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 157, table 147, TPMS_NV_CERTIFY_INFO structure
#[derive(Debug, PartialEq)]
pub struct TpmsNvCertifyInfo<'a> {
    pub index_name: Tpm2bName<'a>,
    pub offset: u16,
    pub nv_contents: Tpm2bMaxNvBuffer<'a>,
}

impl<'a> TpmsNvCertifyInfo<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpms_nv_certify_info_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let offset_size = mem::size_of::<u16>();
        size = match size.checked_add(offset_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let index_name_size = match self.index_name.marshalled_size() {
            Ok(index_name_size) => index_name_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(index_name_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let nv_contents_size = match self.nv_contents.marshalled_size() {
            Ok(nv_contents_size) => nv_contents_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(nv_contents_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.index_name.marshal(buf)?;

        let buf = marshal_u16(buf, self.offset)?;

        let buf = self.nv_contents.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_index_name) = match Tpm2bName::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_offset) = match unmarshal_u16(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_nv_contents) = match Tpm2bMaxNvBuffer::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{index_name: unmarshalled_index_name, offset: unmarshalled_offset, nv_contents: unmarshalled_nv_contents}))
    }

    pub fn unmarshal(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<TpmsNvCertifyInfo<'static>, TpmErr> {
        Ok(TpmsNvCertifyInfo {
            index_name: self.index_name.try_clone_intern()?,
            offset: self.offset,
            nv_contents: self.nv_contents.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<TpmsNvCertifyInfo<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<TpmsNvCertifyInfo<'static>, TpmErr> {
        let Self {
            index_name,
            offset,
            nv_contents,
        } = self;

        let index_name = index_name.into_bufs_owner_intern()?;
        let nv_contents = nv_contents.into_bufs_owner_intern()?;

        Ok(TpmsNvCertifyInfo {
            index_name,
            offset,
            nv_contents,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<TpmsNvCertifyInfo<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpms_nv_certify_info_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    size += tpm2b_name_marshalled_max_size() as u32;
    size += mem::size_of::<u16>() as u32;

    let nv_contents_size = match tpm2b_max_nv_buffer_marshalled_max_size(limits) {
        Ok(nv_contents_size) => nv_contents_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(nv_contents_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 157, table 148, TPMS_NV_DIGEST_CERTIFY_INFO structure
#[derive(Debug, PartialEq)]
pub struct TpmsNvDigestCertifyInfo<'a> {
    pub index_name: Tpm2bName<'a>,
    pub nv_digest: Tpm2bDigest<'a>,
}

impl<'a> TpmsNvDigestCertifyInfo<'a> {
    pub const fn marshalled_max_size() -> u16 {
        tpms_nv_digest_certify_info_marshalled_max_size()
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let index_name_size = match self.index_name.marshalled_size() {
            Ok(index_name_size) => index_name_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(index_name_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let nv_digest_size = match self.nv_digest.marshalled_size() {
            Ok(nv_digest_size) => nv_digest_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(nv_digest_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.index_name.marshal(buf)?;

        let buf = self.nv_digest.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_index_name) = match Tpm2bName::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_nv_digest) = match Tpm2bDigest::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{index_name: unmarshalled_index_name, nv_digest: unmarshalled_nv_digest}))
    }

    pub fn unmarshal(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<TpmsNvDigestCertifyInfo<'static>, TpmErr> {
        Ok(TpmsNvDigestCertifyInfo {
            index_name: self.index_name.try_clone_intern()?,
            nv_digest: self.nv_digest.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<TpmsNvDigestCertifyInfo<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<TpmsNvDigestCertifyInfo<'static>, TpmErr> {
        let Self {
            index_name,
            nv_digest,
        } = self;

        let index_name = index_name.into_bufs_owner_intern()?;
        let nv_digest = nv_digest.into_bufs_owner_intern()?;

        Ok(TpmsNvDigestCertifyInfo {
            index_name,
            nv_digest,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<TpmsNvDigestCertifyInfo<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

const fn tpms_nv_digest_certify_info_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += tpm2b_name_marshalled_max_size();
    size += tpm2b_digest_marshalled_max_size();

    size
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 157, table 149, TPMI_ST_ATTEST type
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u16)]
pub enum TpmiStAttest {
    AttestCertify = TpmSt::AttestCertify as u16,
    AttestQuote = TpmSt::AttestQuote as u16,
    AttestSessionAudit = TpmSt::AttestSessionAudit as u16,
    AttestCommandAudit = TpmSt::AttestCommandAudit as u16,
    AttestTime = TpmSt::AttestTime as u16,
    AttestCreation = TpmSt::AttestCreation as u16,
    AttestNv = TpmSt::AttestNv as u16,
    AttestNvDigest = TpmSt::AttestNvDigest as u16,
}

impl TpmiStAttest {
    pub const fn marshalled_size() -> u16 {
        mem::size_of::<u16>() as u16
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u16(buf, *self as u16)
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u16(buf)?;
        let result = Self::try_from(value)?;
        Ok((buf, result))
    }
}

impl convert::TryFrom<u16> for TpmiStAttest {
    type Error = TpmErr;

    fn try_from(value: u16) -> Result<Self, TpmErr> {
        let result = match value {
            value if value == Self::AttestCertify as u16 => Self::AttestCertify,
            value if value == Self::AttestQuote as u16 => Self::AttestQuote,
            value if value == Self::AttestSessionAudit as u16 => Self::AttestSessionAudit,
            value if value == Self::AttestCommandAudit as u16 => Self::AttestCommandAudit,
            value if value == Self::AttestTime as u16 => Self::AttestTime,
            value if value == Self::AttestCreation as u16 => Self::AttestCreation,
            value if value == Self::AttestNv as u16 => Self::AttestNv,
            value if value == Self::AttestNvDigest as u16 => Self::AttestNvDigest,
            _ => {
                return Err(TpmErr::Rc(TpmRc::VALUE));
            },
        };

        Ok(result)
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 158, table 150, TPMU_ATTEST union
struct TpmuAttest {}

impl TpmuAttest {
    fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        let mut size: u32 = 0;

        let certify_size = tpms_certify_info_marshalled_max_size() as u32;
        if certify_size > size {
            size = certify_size;
        }

        let creation_size = tpms_creation_info_marshalled_max_size() as u32;
        if creation_size > size {
            size = creation_size;
        }

        let command_audit_size = tpms_command_audit_info_marshalled_max_size() as u32;
        if command_audit_size > size {
            size = command_audit_size;
        }

        let session_audit_size = tpms_session_audit_info_marshalled_max_size() as u32;
        if session_audit_size > size {
            size = session_audit_size;
        }

        let time_size = tpms_time_attest_info_marshalled_size() as u32;
        if time_size > size {
            size = time_size;
        }

        let nv_digest_size = tpms_nv_digest_certify_info_marshalled_max_size() as u32;
        if nv_digest_size > size {
            size = nv_digest_size;
        }

        let quote_size = match tpms_quote_info_marshalled_max_size(limits) {
            Ok(quote_size) => quote_size,
            Err(_) => {
                return Err(());
            },
        };
        if quote_size > size {
            size = quote_size;
        }

        let nv_size = match tpms_nv_certify_info_marshalled_max_size(limits) {
            Ok(nv_size) => nv_size,
            Err(_) => {
                return Err(());
            },
        };
        if nv_size > size {
            size = nv_size;
        }

        Ok(size)
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 158, table 151, TPMS_ATTEST structure
#[derive(Debug, PartialEq)]
pub struct TpmsAttest<'a> {
    pub magic: TpmConstants32,
    pub qualified_signer: Tpm2bName<'a>,
    pub extra_data: Tpm2bData<'a>,
    pub clock_info: TpmsClockInfo,
    pub firmware_version: u64,
    pub typ: TpmsAttestMemberTyp<'a>,
}

impl<'a> TpmsAttest<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpms_attest_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let magic_size = match usize::try_from(TpmConstants32::marshalled_size()) {
            Ok(magic_size) => magic_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(magic_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let typ_selector_size = match usize::try_from(TpmsAttestMemberTyp::marshalled_selector_size()) {
            Ok(typ_selector_size) => typ_selector_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(typ_selector_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let clock_info_size = match usize::try_from(tpms_clock_info_marshalled_size()) {
            Ok(clock_info_size) => clock_info_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(clock_info_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let firmware_version_size = mem::size_of::<u64>();
        size = match size.checked_add(firmware_version_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let qualified_signer_size = match self.qualified_signer.marshalled_size() {
            Ok(qualified_signer_size) => qualified_signer_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(qualified_signer_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let extra_data_size = match self.extra_data.marshalled_size() {
            Ok(extra_data_size) => extra_data_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(extra_data_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let typ_data_size = match self.typ.marshalled_data_size() {
            Ok(typ_data_size) => typ_data_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(typ_data_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.magic.marshal(buf)?;

        let buf = self.typ.marshal_intern_selector(buf)?;

        let buf = self.qualified_signer.marshal(buf)?;

        let buf = self.extra_data.marshal(buf)?;

        let buf = self.clock_info.marshal(buf)?;

        let buf = marshal_u64(buf, self.firmware_version)?;

        let buf = self.typ.marshal_intern_data(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_magic) = match TpmConstants32::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_typ_selector) = match TpmsAttestMemberTyp::unmarshal_intern_selector(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_qualified_signer) = match Tpm2bName::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_extra_data) = match Tpm2bData::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_clock_info) = match TpmsClockInfo::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_firmware_version) = match unmarshal_u64(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_typ) = match TpmsAttestMemberTyp::<'_>::unmarshal_intern(unmarshalled_typ_selector, buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{magic: unmarshalled_magic, qualified_signer: unmarshalled_qualified_signer, extra_data: unmarshalled_extra_data, clock_info: unmarshalled_clock_info, firmware_version: unmarshalled_firmware_version, typ: unmarshalled_typ}))
    }

    pub fn unmarshal(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<TpmsAttest<'static>, TpmErr> {
        Ok(TpmsAttest {
            magic: self.magic,
            qualified_signer: self.qualified_signer.try_clone_intern()?,
            extra_data: self.extra_data.try_clone_intern()?,
            clock_info: self.clock_info,
            firmware_version: self.firmware_version,
            typ: self.typ.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<TpmsAttest<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<TpmsAttest<'static>, TpmErr> {
        let Self {
            magic,
            qualified_signer,
            extra_data,
            clock_info,
            firmware_version,
            typ,
        } = self;

        let qualified_signer = qualified_signer.into_bufs_owner_intern()?;
        let extra_data = extra_data.into_bufs_owner_intern()?;
        let typ = typ.into_bufs_owner_intern()?;

        Ok(TpmsAttest {
            magic,
            qualified_signer,
            extra_data,
            clock_info,
            firmware_version,
            typ,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<TpmsAttest<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpms_attest_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    size += TpmConstants32::marshalled_size() as u32;
    size += TpmiStAttest::marshalled_size() as u32;
    size += tpm2b_name_marshalled_max_size() as u32;
    size += tpm2b_data_marshalled_max_size() as u32;
    size += tpms_clock_info_marshalled_size() as u32;
    size += mem::size_of::<u64>() as u32;

    let attested_size = match TpmuAttest::marshalled_max_size(limits) {
        Ok(attested_size) => attested_size,
        Err(_) => return Err(()),
    };
    size = size.checked_add(attested_size).ok_or(())?;

    Ok(size)
}

#[derive(Debug, PartialEq)]
#[repr(u16)]
pub enum TpmsAttestMemberTyp<'a> {
    AttestCertify(TpmsCertifyInfo<'a>) = TpmSt::AttestCertify as u16,
    AttestQuote(TpmsQuoteInfo<'a>) = TpmSt::AttestQuote as u16,
    AttestSessionAudit(TpmsSessionAuditInfo<'a>) = TpmSt::AttestSessionAudit as u16,
    AttestCommandAudit(TpmsCommandAuditInfo<'a>) = TpmSt::AttestCommandAudit as u16,
    AttestTime(TpmsTimeAttestInfo) = TpmSt::AttestTime as u16,
    AttestCreation(TpmsCreationInfo<'a>) = TpmSt::AttestCreation as u16,
    AttestNv(TpmsNvCertifyInfo<'a>) = TpmSt::AttestNv as u16,
    AttestNvDigest(TpmsNvDigestCertifyInfo<'a>) = TpmSt::AttestNvDigest as u16,
}

impl<'a> TpmsAttestMemberTyp<'a> {
    const fn marshalled_selector_size() -> u16 {
        TpmiStAttest::marshalled_size()
    }

    fn marshalled_data_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;
        match self {
            Self::AttestCertify(attested) => {
                let attested_size = match attested.marshalled_size() {
                    Ok(attested_size) => attested_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(attested_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            Self::AttestQuote(attested) => {
                let attested_size = match attested.marshalled_size() {
                    Ok(attested_size) => attested_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(attested_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            Self::AttestSessionAudit(attested) => {
                let attested_size = match attested.marshalled_size() {
                    Ok(attested_size) => attested_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(attested_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            Self::AttestCommandAudit(attested) => {
                let attested_size = match attested.marshalled_size() {
                    Ok(attested_size) => attested_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(attested_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            Self::AttestTime(_) => {
                let attested_size = match usize::try_from(tpms_time_attest_info_marshalled_size()) {
                    Ok(attested_size) => attested_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(attested_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            Self::AttestCreation(attested) => {
                let attested_size = match attested.marshalled_size() {
                    Ok(attested_size) => attested_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(attested_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            Self::AttestNv(attested) => {
                let attested_size = match attested.marshalled_size() {
                    Ok(attested_size) => attested_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(attested_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            Self::AttestNvDigest(attested) => {
                let attested_size = match attested.marshalled_size() {
                    Ok(attested_size) => attested_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(attested_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
        };

        Ok(size)
    }


    fn marshal_intern_selector<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let selector = match self {
            Self::AttestCertify(_) => TpmSt::AttestCertify as u16,
            Self::AttestQuote(_) => TpmSt::AttestQuote as u16,
            Self::AttestSessionAudit(_) => TpmSt::AttestSessionAudit as u16,
            Self::AttestCommandAudit(_) => TpmSt::AttestCommandAudit as u16,
            Self::AttestTime(_) => TpmSt::AttestTime as u16,
            Self::AttestCreation(_) => TpmSt::AttestCreation as u16,
            Self::AttestNv(_) => TpmSt::AttestNv as u16,
            Self::AttestNvDigest(_) => TpmSt::AttestNvDigest as u16,
        };

        marshal_u16(buf, selector)
    }

    fn marshal_intern_data<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = match self {
            Self::AttestCertify(attested) => {
                let buf = attested.marshal(buf)?;

                buf
            },
            Self::AttestQuote(attested) => {
                let buf = attested.marshal(buf)?;

                buf
            },
            Self::AttestSessionAudit(attested) => {
                let buf = attested.marshal(buf)?;

                buf
            },
            Self::AttestCommandAudit(attested) => {
                let buf = attested.marshal(buf)?;

                buf
            },
            Self::AttestTime(attested) => {
                let buf = attested.marshal(buf)?;

                buf
            },
            Self::AttestCreation(attested) => {
                let buf = attested.marshal(buf)?;

                buf
            },
            Self::AttestNv(attested) => {
                let buf = attested.marshal(buf)?;

                buf
            },
            Self::AttestNvDigest(attested) => {
                let buf = attested.marshal(buf)?;

                buf
            },
        };
        Ok(buf)
    }

    fn unmarshal_intern_selector(buf: &'a [u8]) -> Result<(&'a [u8], u16), TpmErr> {
        let (buf, unmarshalled_typ_selector) = match unmarshal_u16(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        Ok((buf, unmarshalled_typ_selector))
    }

    fn unmarshal_intern(selector: u16, buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, r) = match selector {
            value if value == TpmSt::AttestCertify as u16 => {
                let (buf, unmarshalled_attested) = match TpmsCertifyInfo::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::AttestCertify(unmarshalled_attested))
            },
            value if value == TpmSt::AttestQuote as u16 => {
                let (buf, unmarshalled_attested) = match TpmsQuoteInfo::unmarshal_intern(buf, limits) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::AttestQuote(unmarshalled_attested))
            },
            value if value == TpmSt::AttestSessionAudit as u16 => {
                let (buf, unmarshalled_attested) = match TpmsSessionAuditInfo::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::AttestSessionAudit(unmarshalled_attested))
            },
            value if value == TpmSt::AttestCommandAudit as u16 => {
                let (buf, unmarshalled_attested) = match TpmsCommandAuditInfo::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::AttestCommandAudit(unmarshalled_attested))
            },
            value if value == TpmSt::AttestTime as u16 => {
                let (buf, unmarshalled_attested) = match TpmsTimeAttestInfo::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::AttestTime(unmarshalled_attested))
            },
            value if value == TpmSt::AttestCreation as u16 => {
                let (buf, unmarshalled_attested) = match TpmsCreationInfo::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::AttestCreation(unmarshalled_attested))
            },
            value if value == TpmSt::AttestNv as u16 => {
                let (buf, unmarshalled_attested) = match TpmsNvCertifyInfo::unmarshal_intern(buf, limits) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::AttestNv(unmarshalled_attested))
            },
            value if value == TpmSt::AttestNvDigest as u16 => {
                let (buf, unmarshalled_attested) = match TpmsNvDigestCertifyInfo::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::AttestNvDigest(unmarshalled_attested))
            },
            _ => {
                return Err(TpmErr::Rc(TpmRc::VALUE));
            },
        };

        Ok((buf, r))
    }

    fn try_clone_intern(&self) -> Result<TpmsAttestMemberTyp<'static>, TpmErr> {
        match self {
            Self::AttestCertify(attested) => {
                Ok(TpmsAttestMemberTyp::AttestCertify(
                    attested.try_clone_intern()?,
                ))
            },
            Self::AttestQuote(attested) => {
                Ok(TpmsAttestMemberTyp::AttestQuote(
                    attested.try_clone_intern()?,
                ))
            },
            Self::AttestSessionAudit(attested) => {
                Ok(TpmsAttestMemberTyp::AttestSessionAudit(
                    attested.try_clone_intern()?,
                ))
            },
            Self::AttestCommandAudit(attested) => {
                Ok(TpmsAttestMemberTyp::AttestCommandAudit(
                    attested.try_clone_intern()?,
                ))
            },
            Self::AttestTime(attested) => {
                Ok(TpmsAttestMemberTyp::AttestTime(
                    *attested,
                ))
            },
            Self::AttestCreation(attested) => {
                Ok(TpmsAttestMemberTyp::AttestCreation(
                    attested.try_clone_intern()?,
                ))
            },
            Self::AttestNv(attested) => {
                Ok(TpmsAttestMemberTyp::AttestNv(
                    attested.try_clone_intern()?,
                ))
            },
            Self::AttestNvDigest(attested) => {
                Ok(TpmsAttestMemberTyp::AttestNvDigest(
                    attested.try_clone_intern()?,
                ))
            },
        }
    }

    pub fn try_clone(&self) -> Result<Box<TpmsAttestMemberTyp<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<TpmsAttestMemberTyp<'static>, TpmErr> {
        match self {
            Self::AttestCertify(attested) => {
                let attested = attested.into_bufs_owner_intern()?;
                Ok(TpmsAttestMemberTyp::AttestCertify(attested))
            },
            Self::AttestQuote(attested) => {
                let attested = attested.into_bufs_owner_intern()?;
                Ok(TpmsAttestMemberTyp::AttestQuote(attested))
            },
            Self::AttestSessionAudit(attested) => {
                let attested = attested.into_bufs_owner_intern()?;
                Ok(TpmsAttestMemberTyp::AttestSessionAudit(attested))
            },
            Self::AttestCommandAudit(attested) => {
                let attested = attested.into_bufs_owner_intern()?;
                Ok(TpmsAttestMemberTyp::AttestCommandAudit(attested))
            },
            Self::AttestTime(attested) => {
                Ok(TpmsAttestMemberTyp::AttestTime(attested))
            },
            Self::AttestCreation(attested) => {
                let attested = attested.into_bufs_owner_intern()?;
                Ok(TpmsAttestMemberTyp::AttestCreation(attested))
            },
            Self::AttestNv(attested) => {
                let attested = attested.into_bufs_owner_intern()?;
                Ok(TpmsAttestMemberTyp::AttestNv(attested))
            },
            Self::AttestNvDigest(attested) => {
                let attested = attested.into_bufs_owner_intern()?;
                Ok(TpmsAttestMemberTyp::AttestNvDigest(attested))
            },
        }
    }
}

impl<'a> convert::From<&TpmsAttestMemberTyp<'a>> for TpmiStAttest {
    fn from(value: &TpmsAttestMemberTyp<'a>) -> Self {
        match value {
            TpmsAttestMemberTyp::AttestCertify(_) => Self::AttestCertify,
            TpmsAttestMemberTyp::AttestQuote(_) => Self::AttestQuote,
            TpmsAttestMemberTyp::AttestSessionAudit(_) => Self::AttestSessionAudit,
            TpmsAttestMemberTyp::AttestCommandAudit(_) => Self::AttestCommandAudit,
            TpmsAttestMemberTyp::AttestTime(_) => Self::AttestTime,
            TpmsAttestMemberTyp::AttestCreation(_) => Self::AttestCreation,
            TpmsAttestMemberTyp::AttestNv(_) => Self::AttestNv,
            TpmsAttestMemberTyp::AttestNvDigest(_) => Self::AttestNvDigest,
        }
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 159, table 152, TPM2B_ATTEST structure
#[derive(Debug, PartialEq)]
pub struct Tpm2bAttest<'a> {
    pub attestation_data: TpmBuffer<'a>,
}

impl<'a> Tpm2bAttest<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2b_attest_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let size_size = mem::size_of::<u16>();
        size = match size.checked_add(size_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let attestation_data_size = self.attestation_data.len();
        size = match size.checked_add(attestation_data_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let marshalled_size = match u16::try_from(self.attestation_data.len()) {
            Ok(marshalled_size) => marshalled_size,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::SIZE));
            },
        };
        let buf = marshal_u16(buf, marshalled_size)?;

        let buf = marshal_bytes(buf, &self.attestation_data)?;

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_size) = match unmarshal_u16(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let attestation_data_size: u16 = unmarshalled_size;
        let v0 = match tpms_attest_marshalled_max_size(limits) {
            Ok(v) => v,
            Err(_) => {
                debug_assert!(false, "Unexpected sizeof() evaluation failure");
                return Err(TpmErr::InternalErr);
            },
        };
        if attestation_data_size as u32 > v0 {
            return Err(TpmErr::Rc(TpmRc::SIZE));
        }
        let attestation_data_size = match usize::try_from(attestation_data_size) {
            Ok(attestation_data_size) => attestation_data_size,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::INSUFFICIENT));
            },
        };
        let (unmarshalled_attestation_data, buf) = match split_slice_at(buf, attestation_data_size) {
            Ok((unmarshalled_attestation_data, buf)) => (unmarshalled_attestation_data, buf),
            Err(e) => {
                return Err(e);
            },
        };
        let unmarshalled_attestation_data = TpmBuffer::from(unmarshalled_attestation_data);

        Ok((buf, Self{attestation_data: unmarshalled_attestation_data}))
    }

    pub fn unmarshal(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2bAttest<'static>, TpmErr> {
        let attestation_data = copy_vec_from_slice(&self.attestation_data)?;
        let attestation_data = TpmBuffer::Owned(attestation_data);

        Ok(Tpm2bAttest {
            attestation_data,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2bAttest<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2bAttest<'static>, TpmErr> {
        let Self {
            attestation_data,
        } = self;

        let attestation_data = attestation_data.into_owned()?;

        Ok(Tpm2bAttest {
            attestation_data,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2bAttest<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpm2b_attest_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    size += mem::size_of::<u16>() as u32;

    let v0 = match tpms_attest_marshalled_max_size(limits) {
        Ok(v) => v,
        Err(_) => {
            debug_assert!(false, "Unexpected sizeof() evaluation failure");
            return Err(());
        },
    };
    let attestation_data_size = v0;
    size = size.checked_add(attestation_data_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 159, table 153, TPMS_AUTH_COMMAND structure
#[derive(Debug, PartialEq)]
pub struct TpmsAuthCommand<'a> {
    pub session_handle: TpmiShAuthSessionWCV,
    pub nonce: Tpm2bDigest<'a>,
    pub session_attributes: TpmaSession,
    pub hmac: Tpm2bDigest<'a>,
}

impl<'a> TpmsAuthCommand<'a> {
    pub const fn marshalled_max_size() -> u16 {
        tpms_auth_command_marshalled_max_size()
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let session_handle_size = match usize::try_from(TpmiShAuthSessionWCV::marshalled_size()) {
            Ok(session_handle_size) => session_handle_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(session_handle_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let session_attributes_size = match usize::try_from(TpmaSession::marshalled_size()) {
            Ok(session_attributes_size) => session_attributes_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(session_attributes_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let nonce_size = match self.nonce.marshalled_size() {
            Ok(nonce_size) => nonce_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(nonce_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let hmac_size = match self.hmac.marshalled_size() {
            Ok(hmac_size) => hmac_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(hmac_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.session_handle.marshal(buf)?;

        let buf = self.nonce.marshal(buf)?;

        let buf = self.session_attributes.marshal(buf)?;

        let buf = self.hmac.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_session_handle) = match TpmiShAuthSessionWCV::unmarshal(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_nonce) = match Tpm2bDigest::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_session_attributes) = match TpmaSession::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_hmac) = match Tpm2bDigest::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{session_handle: unmarshalled_session_handle, nonce: unmarshalled_nonce, session_attributes: unmarshalled_session_attributes, hmac: unmarshalled_hmac}))
    }

    pub fn unmarshal(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<TpmsAuthCommand<'static>, TpmErr> {
        Ok(TpmsAuthCommand {
            session_handle: self.session_handle,
            nonce: self.nonce.try_clone_intern()?,
            session_attributes: self.session_attributes,
            hmac: self.hmac.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<TpmsAuthCommand<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<TpmsAuthCommand<'static>, TpmErr> {
        let Self {
            session_handle,
            nonce,
            session_attributes,
            hmac,
        } = self;

        let nonce = nonce.into_bufs_owner_intern()?;
        let hmac = hmac.into_bufs_owner_intern()?;

        Ok(TpmsAuthCommand {
            session_handle,
            nonce,
            session_attributes,
            hmac,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<TpmsAuthCommand<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

const fn tpms_auth_command_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiShAuthSessionWCV::marshalled_size();
    size += tpm2b_digest_marshalled_max_size();
    size += TpmaSession::marshalled_size();
    size += tpm2b_digest_marshalled_max_size();

    size
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 159, table 154, TPMS_AUTH_RESPONSE structure
#[derive(Debug, PartialEq)]
pub struct TpmsAuthResponse<'a> {
    pub nonce: Tpm2bDigest<'a>,
    pub session_attributes: TpmaSession,
    pub hmac: Tpm2bDigest<'a>,
}

impl<'a> TpmsAuthResponse<'a> {
    pub const fn marshalled_max_size() -> u16 {
        tpms_auth_response_marshalled_max_size()
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let session_attributes_size = match usize::try_from(TpmaSession::marshalled_size()) {
            Ok(session_attributes_size) => session_attributes_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(session_attributes_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let nonce_size = match self.nonce.marshalled_size() {
            Ok(nonce_size) => nonce_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(nonce_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let hmac_size = match self.hmac.marshalled_size() {
            Ok(hmac_size) => hmac_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(hmac_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.nonce.marshal(buf)?;

        let buf = self.session_attributes.marshal(buf)?;

        let buf = self.hmac.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_nonce) = match Tpm2bDigest::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_session_attributes) = match TpmaSession::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_hmac) = match Tpm2bDigest::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{nonce: unmarshalled_nonce, session_attributes: unmarshalled_session_attributes, hmac: unmarshalled_hmac}))
    }

    pub fn unmarshal(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<TpmsAuthResponse<'static>, TpmErr> {
        Ok(TpmsAuthResponse {
            nonce: self.nonce.try_clone_intern()?,
            session_attributes: self.session_attributes,
            hmac: self.hmac.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<TpmsAuthResponse<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<TpmsAuthResponse<'static>, TpmErr> {
        let Self {
            nonce,
            session_attributes,
            hmac,
        } = self;

        let nonce = nonce.into_bufs_owner_intern()?;
        let hmac = hmac.into_bufs_owner_intern()?;

        Ok(TpmsAuthResponse {
            nonce,
            session_attributes,
            hmac,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<TpmsAuthResponse<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

const fn tpms_auth_response_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += tpm2b_digest_marshalled_max_size();
    size += TpmaSession::marshalled_size();
    size += tpm2b_digest_marshalled_max_size();

    size
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 161, table 155, expanded for tdes, TPMI_TDES_KEY_BITS type
#[cfg(feature = "tdes")]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct TpmiTdesKeyBits {
    pub value: u16,
}

#[cfg(feature = "tdes")]
impl TpmiTdesKeyBits {
    pub const fn marshalled_size() -> u16 {
        mem::size_of::<u16>() as u16
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u16(buf, self.value)
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u16(buf)?;

        if value == 128u16 {
            return Ok((buf, Self{value}))
        }

        if value == 192u16 {
            return Ok((buf, Self{value}))
        }

        return Err(TpmErr::Rc(TpmRc::VALUE));
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 161, table 155, expanded for aes, TPMI_AES_KEY_BITS type
#[cfg(feature = "aes")]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct TpmiAesKeyBits {
    pub value: u16,
}

#[cfg(feature = "aes")]
impl TpmiAesKeyBits {
    pub const fn marshalled_size() -> u16 {
        mem::size_of::<u16>() as u16
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u16(buf, self.value)
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u16(buf)?;

        if value == 128u16 {
            return Ok((buf, Self{value}))
        }

        if value == 192u16 {
            return Ok((buf, Self{value}))
        }

        if value == 256u16 {
            return Ok((buf, Self{value}))
        }

        return Err(TpmErr::Rc(TpmRc::VALUE));
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 161, table 155, expanded for sm4, TPMI_SM4_KEY_BITS type
#[cfg(feature = "sm4")]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct TpmiSm4KeyBits {
    pub value: u16,
}

#[cfg(feature = "sm4")]
impl TpmiSm4KeyBits {
    pub const fn marshalled_size() -> u16 {
        mem::size_of::<u16>() as u16
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u16(buf, self.value)
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u16(buf)?;

        if value == 128u16 {
            return Ok((buf, Self{value}))
        }

        return Err(TpmErr::Rc(TpmRc::VALUE));
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 161, table 155, expanded for camellia, TPMI_CAMELLIA_KEY_BITS type
#[cfg(feature = "camellia")]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct TpmiCamelliaKeyBits {
    pub value: u16,
}

#[cfg(feature = "camellia")]
impl TpmiCamelliaKeyBits {
    pub const fn marshalled_size() -> u16 {
        mem::size_of::<u16>() as u16
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u16(buf, self.value)
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u16(buf)?;

        if value == 128u16 {
            return Ok((buf, Self{value}))
        }

        if value == 192u16 {
            return Ok((buf, Self{value}))
        }

        if value == 256u16 {
            return Ok((buf, Self{value}))
        }

        return Err(TpmErr::Rc(TpmRc::VALUE));
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 161, table 156, TPMU_SYM_KEY_BITS union
struct TpmuSymKeyBits {}

impl TpmuSymKeyBits {
    const fn marshalled_max_size() -> u16 {
        let mut size: u16 = 0;

        #[cfg(feature = "tdes")]
        {
            let tdes_size = TpmiTdesKeyBits::marshalled_size();
            if tdes_size > size {
                size = tdes_size;
            }
        }

        #[cfg(feature = "aes")]
        {
            let aes_size = TpmiAesKeyBits::marshalled_size();
            if aes_size > size {
                size = aes_size;
            }
        }

        #[cfg(feature = "sm4")]
        {
            let sm4_size = TpmiSm4KeyBits::marshalled_size();
            if sm4_size > size {
                size = sm4_size;
            }
        }

        #[cfg(feature = "camellia")]
        {
            let camellia_size = TpmiCamelliaKeyBits::marshalled_size();
            if camellia_size > size {
                size = camellia_size;
            }
        }

        let sym_size = mem::size_of::<u16>() as u16;
        if sym_size > size {
            size = sym_size;
        }

        let xor_size = TpmiAlgHash::marshalled_size();
        if xor_size > size {
            size = xor_size;
        }

        size
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 162, table 157, TPMU_SYM_MODE union
struct TpmuSymMode {}

impl TpmuSymMode {
    const fn marshalled_max_size() -> u16 {
        let mut size: u16 = 0;

        #[cfg(feature = "tdes")]
        {
            let tdes_size = TpmiAlgSymModeWCV::marshalled_size();
            if tdes_size > size {
                size = tdes_size;
            }
        }

        #[cfg(feature = "aes")]
        {
            let aes_size = TpmiAlgSymModeWCV::marshalled_size();
            if aes_size > size {
                size = aes_size;
            }
        }

        #[cfg(feature = "sm4")]
        {
            let sm4_size = TpmiAlgSymModeWCV::marshalled_size();
            if sm4_size > size {
                size = sm4_size;
            }
        }

        #[cfg(feature = "camellia")]
        {
            let camellia_size = TpmiAlgSymModeWCV::marshalled_size();
            if camellia_size > size {
                size = camellia_size;
            }
        }

        let sym_size = TpmiAlgSymModeWCV::marshalled_size();
        if sym_size > size {
            size = sym_size;
        }

        size
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 162, table 158, TPMU_SYM_DETAILS union
struct TpmuSymDetails {}

impl TpmuSymDetails {
    const fn marshalled_max_size() -> u16 {
        let mut size: u16 = 0;

        size
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 163, table 159, TPMT_SYM_DEF structure (without conditional values)
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u16)]
pub enum TpmtSymDef {
    #[cfg(feature = "tdes")]
    Tdes{
        key_bits: TpmiTdesKeyBits,
        mode: TpmiAlgSymModeWCV,
    } = TpmAlgId::Tdes as u16,
    #[cfg(feature = "aes")]
    Aes{
        key_bits: TpmiAesKeyBits,
        mode: TpmiAlgSymModeWCV,
    } = TpmAlgId::Aes as u16,
    #[cfg(feature = "sm4")]
    Sm4{
        key_bits: TpmiSm4KeyBits,
        mode: TpmiAlgSymModeWCV,
    } = TpmAlgId::Sm4 as u16,
    #[cfg(feature = "camellia")]
    Camellia{
        key_bits: TpmiCamelliaKeyBits,
        mode: TpmiAlgSymModeWCV,
    } = TpmAlgId::Camellia as u16,
    Xor{
        key_bits: TpmiAlgHash,
    } = TpmAlgId::Xor as u16,
}

impl TpmtSymDef {
    pub const fn marshalled_max_size() -> u16 {
        tpmt_sym_def_marshalled_max_size()
    }

    const fn marshalled_selector_size() -> u16 {
        TpmiAlgSym::marshalled_size()
    }

    fn marshalled_data_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;
        match self {
            #[cfg(feature = "tdes")]
            Self::Tdes{key_bits: _, mode: _} => {
                let key_bits_size = match usize::try_from(TpmiTdesKeyBits::marshalled_size()) {
                    Ok(key_bits_size) => key_bits_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(key_bits_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };

                let mode_size = match usize::try_from(TpmiAlgSymModeWCV::marshalled_size()) {
                    Ok(mode_size) => mode_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(mode_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(feature = "aes")]
            Self::Aes{key_bits: _, mode: _} => {
                let key_bits_size = match usize::try_from(TpmiAesKeyBits::marshalled_size()) {
                    Ok(key_bits_size) => key_bits_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(key_bits_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };

                let mode_size = match usize::try_from(TpmiAlgSymModeWCV::marshalled_size()) {
                    Ok(mode_size) => mode_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(mode_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(feature = "sm4")]
            Self::Sm4{key_bits: _, mode: _} => {
                let key_bits_size = match usize::try_from(TpmiSm4KeyBits::marshalled_size()) {
                    Ok(key_bits_size) => key_bits_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(key_bits_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };

                let mode_size = match usize::try_from(TpmiAlgSymModeWCV::marshalled_size()) {
                    Ok(mode_size) => mode_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(mode_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(feature = "camellia")]
            Self::Camellia{key_bits: _, mode: _} => {
                let key_bits_size = match usize::try_from(TpmiCamelliaKeyBits::marshalled_size()) {
                    Ok(key_bits_size) => key_bits_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(key_bits_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };

                let mode_size = match usize::try_from(TpmiAlgSymModeWCV::marshalled_size()) {
                    Ok(mode_size) => mode_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(mode_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            Self::Xor{key_bits: _} => {
                let key_bits_size = match usize::try_from(TpmiAlgHash::marshalled_size()) {
                    Ok(key_bits_size) => key_bits_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(key_bits_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
        };

        Ok(size)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let selector_size = match usize::try_from(Self::marshalled_selector_size()) {
            Ok(selector_size) => selector_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(selector_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let data_size = match self.marshalled_data_size() {
            Ok(data_size) => data_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(data_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = match self {
            #[cfg(feature = "tdes")]
            Self::Tdes{key_bits, mode} => {
                let selector = TpmAlgId::Tdes as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = key_bits.marshal(buf)?;

                let buf = mode.marshal(buf)?;

                buf
            },
            #[cfg(feature = "aes")]
            Self::Aes{key_bits, mode} => {
                let selector = TpmAlgId::Aes as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = key_bits.marshal(buf)?;

                let buf = mode.marshal(buf)?;

                buf
            },
            #[cfg(feature = "sm4")]
            Self::Sm4{key_bits, mode} => {
                let selector = TpmAlgId::Sm4 as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = key_bits.marshal(buf)?;

                let buf = mode.marshal(buf)?;

                buf
            },
            #[cfg(feature = "camellia")]
            Self::Camellia{key_bits, mode} => {
                let selector = TpmAlgId::Camellia as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = key_bits.marshal(buf)?;

                let buf = mode.marshal(buf)?;

                buf
            },
            Self::Xor{key_bits} => {
                let selector = TpmAlgId::Xor as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = key_bits.marshal(buf)?;

                buf
            },
        };
        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_algorithm) = match unmarshal_u16(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, r) = match unmarshalled_algorithm {
            #[cfg(feature = "tdes")]
            value if value == TpmAlgId::Tdes as u16 => {
                let (buf, unmarshalled_key_bits) = match TpmiTdesKeyBits::unmarshal(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                let (buf, unmarshalled_mode) = match TpmiAlgSymModeWCV::unmarshal(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };


                (buf, Self::Tdes{key_bits: unmarshalled_key_bits, mode: unmarshalled_mode})
            },
            #[cfg(feature = "aes")]
            value if value == TpmAlgId::Aes as u16 => {
                let (buf, unmarshalled_key_bits) = match TpmiAesKeyBits::unmarshal(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                let (buf, unmarshalled_mode) = match TpmiAlgSymModeWCV::unmarshal(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };


                (buf, Self::Aes{key_bits: unmarshalled_key_bits, mode: unmarshalled_mode})
            },
            #[cfg(feature = "sm4")]
            value if value == TpmAlgId::Sm4 as u16 => {
                let (buf, unmarshalled_key_bits) = match TpmiSm4KeyBits::unmarshal(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                let (buf, unmarshalled_mode) = match TpmiAlgSymModeWCV::unmarshal(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };


                (buf, Self::Sm4{key_bits: unmarshalled_key_bits, mode: unmarshalled_mode})
            },
            #[cfg(feature = "camellia")]
            value if value == TpmAlgId::Camellia as u16 => {
                let (buf, unmarshalled_key_bits) = match TpmiCamelliaKeyBits::unmarshal(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                let (buf, unmarshalled_mode) = match TpmiAlgSymModeWCV::unmarshal(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };


                (buf, Self::Camellia{key_bits: unmarshalled_key_bits, mode: unmarshalled_mode})
            },
            value if value == TpmAlgId::Xor as u16 => {
                let (buf, unmarshalled_key_bits) = match TpmiAlgHash::unmarshal(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };



                (buf, Self::Xor{key_bits: unmarshalled_key_bits})
            },
            _ => {
                return Err(TpmErr::Rc(TpmRc::SYMMETRIC));
            },
        };

        Ok((buf, r))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpmt_sym_def_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiAlgSym::marshalled_size();
    size += TpmuSymKeyBits::marshalled_max_size();
    size += TpmuSymMode::marshalled_max_size();
    size += TpmuSymDetails::marshalled_max_size();

    size
}

impl convert::From<&TpmtSymDef> for TpmiAlgSym {
    fn from(value: &TpmtSymDef) -> Self {
        match value {
            #[cfg(feature = "tdes")]
            TpmtSymDef::Tdes{key_bits: _, mode: _} => Self::Tdes,
            #[cfg(feature = "aes")]
            TpmtSymDef::Aes{key_bits: _, mode: _} => Self::Aes,
            #[cfg(feature = "sm4")]
            TpmtSymDef::Sm4{key_bits: _, mode: _} => Self::Sm4,
            #[cfg(feature = "camellia")]
            TpmtSymDef::Camellia{key_bits: _, mode: _} => Self::Camellia,
            TpmtSymDef::Xor{key_bits: _} => Self::Xor,
        }
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 163, table 159, TPMT_SYM_DEF structure (with conditional values)
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u16)]
pub enum TpmtSymDefWCV {
    #[cfg(feature = "tdes")]
    Tdes{
        key_bits: TpmiTdesKeyBits,
        mode: TpmiAlgSymModeWCV,
    } = TpmAlgId::Tdes as u16,
    #[cfg(feature = "aes")]
    Aes{
        key_bits: TpmiAesKeyBits,
        mode: TpmiAlgSymModeWCV,
    } = TpmAlgId::Aes as u16,
    #[cfg(feature = "sm4")]
    Sm4{
        key_bits: TpmiSm4KeyBits,
        mode: TpmiAlgSymModeWCV,
    } = TpmAlgId::Sm4 as u16,
    #[cfg(feature = "camellia")]
    Camellia{
        key_bits: TpmiCamelliaKeyBits,
        mode: TpmiAlgSymModeWCV,
    } = TpmAlgId::Camellia as u16,
    Xor{
        key_bits: TpmiAlgHash,
    } = TpmAlgId::Xor as u16,
    Null = TpmAlgId::Null as u16,
}

impl TpmtSymDefWCV {
    pub const fn marshalled_max_size() -> u16 {
        tpmt_sym_def_wcv_marshalled_max_size()
    }

    const fn marshalled_selector_size() -> u16 {
        TpmiAlgSymWCV::marshalled_size()
    }

    fn marshalled_data_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;
        match self {
            #[cfg(feature = "tdes")]
            Self::Tdes{key_bits: _, mode: _} => {
                let key_bits_size = match usize::try_from(TpmiTdesKeyBits::marshalled_size()) {
                    Ok(key_bits_size) => key_bits_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(key_bits_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };

                let mode_size = match usize::try_from(TpmiAlgSymModeWCV::marshalled_size()) {
                    Ok(mode_size) => mode_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(mode_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(feature = "aes")]
            Self::Aes{key_bits: _, mode: _} => {
                let key_bits_size = match usize::try_from(TpmiAesKeyBits::marshalled_size()) {
                    Ok(key_bits_size) => key_bits_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(key_bits_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };

                let mode_size = match usize::try_from(TpmiAlgSymModeWCV::marshalled_size()) {
                    Ok(mode_size) => mode_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(mode_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(feature = "sm4")]
            Self::Sm4{key_bits: _, mode: _} => {
                let key_bits_size = match usize::try_from(TpmiSm4KeyBits::marshalled_size()) {
                    Ok(key_bits_size) => key_bits_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(key_bits_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };

                let mode_size = match usize::try_from(TpmiAlgSymModeWCV::marshalled_size()) {
                    Ok(mode_size) => mode_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(mode_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(feature = "camellia")]
            Self::Camellia{key_bits: _, mode: _} => {
                let key_bits_size = match usize::try_from(TpmiCamelliaKeyBits::marshalled_size()) {
                    Ok(key_bits_size) => key_bits_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(key_bits_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };

                let mode_size = match usize::try_from(TpmiAlgSymModeWCV::marshalled_size()) {
                    Ok(mode_size) => mode_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(mode_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            Self::Xor{key_bits: _} => {
                let key_bits_size = match usize::try_from(TpmiAlgHash::marshalled_size()) {
                    Ok(key_bits_size) => key_bits_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(key_bits_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            Self::Null => (),
        };

        Ok(size)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let selector_size = match usize::try_from(Self::marshalled_selector_size()) {
            Ok(selector_size) => selector_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(selector_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let data_size = match self.marshalled_data_size() {
            Ok(data_size) => data_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(data_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = match self {
            #[cfg(feature = "tdes")]
            Self::Tdes{key_bits, mode} => {
                let selector = TpmAlgId::Tdes as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = key_bits.marshal(buf)?;

                let buf = mode.marshal(buf)?;

                buf
            },
            #[cfg(feature = "aes")]
            Self::Aes{key_bits, mode} => {
                let selector = TpmAlgId::Aes as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = key_bits.marshal(buf)?;

                let buf = mode.marshal(buf)?;

                buf
            },
            #[cfg(feature = "sm4")]
            Self::Sm4{key_bits, mode} => {
                let selector = TpmAlgId::Sm4 as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = key_bits.marshal(buf)?;

                let buf = mode.marshal(buf)?;

                buf
            },
            #[cfg(feature = "camellia")]
            Self::Camellia{key_bits, mode} => {
                let selector = TpmAlgId::Camellia as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = key_bits.marshal(buf)?;

                let buf = mode.marshal(buf)?;

                buf
            },
            Self::Xor{key_bits} => {
                let selector = TpmAlgId::Xor as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = key_bits.marshal(buf)?;

                buf
            },
            Self::Null => {
                let selector = TpmAlgId::Null as u16;
                let buf = marshal_u16(buf, selector)?;

                buf
            },
        };
        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_algorithm) = match unmarshal_u16(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, r) = match unmarshalled_algorithm {
            #[cfg(feature = "tdes")]
            value if value == TpmAlgId::Tdes as u16 => {
                let (buf, unmarshalled_key_bits) = match TpmiTdesKeyBits::unmarshal(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                let (buf, unmarshalled_mode) = match TpmiAlgSymModeWCV::unmarshal(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };


                (buf, Self::Tdes{key_bits: unmarshalled_key_bits, mode: unmarshalled_mode})
            },
            #[cfg(feature = "aes")]
            value if value == TpmAlgId::Aes as u16 => {
                let (buf, unmarshalled_key_bits) = match TpmiAesKeyBits::unmarshal(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                let (buf, unmarshalled_mode) = match TpmiAlgSymModeWCV::unmarshal(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };


                (buf, Self::Aes{key_bits: unmarshalled_key_bits, mode: unmarshalled_mode})
            },
            #[cfg(feature = "sm4")]
            value if value == TpmAlgId::Sm4 as u16 => {
                let (buf, unmarshalled_key_bits) = match TpmiSm4KeyBits::unmarshal(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                let (buf, unmarshalled_mode) = match TpmiAlgSymModeWCV::unmarshal(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };


                (buf, Self::Sm4{key_bits: unmarshalled_key_bits, mode: unmarshalled_mode})
            },
            #[cfg(feature = "camellia")]
            value if value == TpmAlgId::Camellia as u16 => {
                let (buf, unmarshalled_key_bits) = match TpmiCamelliaKeyBits::unmarshal(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                let (buf, unmarshalled_mode) = match TpmiAlgSymModeWCV::unmarshal(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };


                (buf, Self::Camellia{key_bits: unmarshalled_key_bits, mode: unmarshalled_mode})
            },
            value if value == TpmAlgId::Xor as u16 => {
                let (buf, unmarshalled_key_bits) = match TpmiAlgHash::unmarshal(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };



                (buf, Self::Xor{key_bits: unmarshalled_key_bits})
            },
            value if value == TpmAlgId::Null as u16 => {
                (buf, Self::Null)
            },
            _ => {
                return Err(TpmErr::Rc(TpmRc::SYMMETRIC));
            },
        };

        Ok((buf, r))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpmt_sym_def_wcv_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiAlgSymWCV::marshalled_size();
    size += TpmuSymKeyBits::marshalled_max_size();
    size += TpmuSymMode::marshalled_max_size();
    size += TpmuSymDetails::marshalled_max_size();

    size
}

impl convert::From<&TpmtSymDefWCV> for TpmiAlgSymWCV {
    fn from(value: &TpmtSymDefWCV) -> Self {
        match value {
            #[cfg(feature = "tdes")]
            TpmtSymDefWCV::Tdes{key_bits: _, mode: _} => Self::Tdes,
            #[cfg(feature = "aes")]
            TpmtSymDefWCV::Aes{key_bits: _, mode: _} => Self::Aes,
            #[cfg(feature = "sm4")]
            TpmtSymDefWCV::Sm4{key_bits: _, mode: _} => Self::Sm4,
            #[cfg(feature = "camellia")]
            TpmtSymDefWCV::Camellia{key_bits: _, mode: _} => Self::Camellia,
            TpmtSymDefWCV::Xor{key_bits: _} => Self::Xor,
            TpmtSymDefWCV::Null => Self::Null,
        }
    }
}

impl convert::From<TpmtSymDef> for TpmtSymDefWCV {
    fn from(value: TpmtSymDef) -> Self {
        match value {
            #[cfg(feature = "tdes")]
            TpmtSymDef::Tdes{key_bits, mode} => Self::Tdes{key_bits, mode},
            #[cfg(feature = "aes")]
            TpmtSymDef::Aes{key_bits, mode} => Self::Aes{key_bits, mode},
            #[cfg(feature = "sm4")]
            TpmtSymDef::Sm4{key_bits, mode} => Self::Sm4{key_bits, mode},
            #[cfg(feature = "camellia")]
            TpmtSymDef::Camellia{key_bits, mode} => Self::Camellia{key_bits, mode},
            TpmtSymDef::Xor{key_bits} => Self::Xor{key_bits},
        }
    }
}

impl convert::TryFrom<TpmtSymDefWCV> for TpmtSymDef {
    type Error = TpmErr;

    fn try_from(value: TpmtSymDefWCV) -> Result<Self, TpmErr> {
        let result = match value {
            #[cfg(feature = "tdes")]
            TpmtSymDefWCV::Tdes{key_bits, mode} => Self::Tdes{key_bits, mode},
            #[cfg(feature = "aes")]
            TpmtSymDefWCV::Aes{key_bits, mode} => Self::Aes{key_bits, mode},
            #[cfg(feature = "sm4")]
            TpmtSymDefWCV::Sm4{key_bits, mode} => Self::Sm4{key_bits, mode},
            #[cfg(feature = "camellia")]
            TpmtSymDefWCV::Camellia{key_bits, mode} => Self::Camellia{key_bits, mode},
            TpmtSymDefWCV::Xor{key_bits} => Self::Xor{key_bits},
            _ => {
                return Err(TpmErr::Rc(TpmRc::SYMMETRIC));
            },
        };

        Ok(result)
    }
}

impl cmp::PartialEq<TpmtSymDef> for TpmtSymDefWCV {
    fn eq(&self, other: &TpmtSymDef) -> bool {
        match self {
            #[cfg(feature = "tdes")]
            Self::Tdes{key_bits: self_key_bits, mode: self_mode} => {
                if let TpmtSymDef::Tdes{key_bits: other_key_bits, mode: other_mode} = other {
                    self_key_bits == other_key_bits
                    && self_mode == other_mode
                } else {
                    false
                }
            },
            #[cfg(feature = "aes")]
            Self::Aes{key_bits: self_key_bits, mode: self_mode} => {
                if let TpmtSymDef::Aes{key_bits: other_key_bits, mode: other_mode} = other {
                    self_key_bits == other_key_bits
                    && self_mode == other_mode
                } else {
                    false
                }
            },
            #[cfg(feature = "sm4")]
            Self::Sm4{key_bits: self_key_bits, mode: self_mode} => {
                if let TpmtSymDef::Sm4{key_bits: other_key_bits, mode: other_mode} = other {
                    self_key_bits == other_key_bits
                    && self_mode == other_mode
                } else {
                    false
                }
            },
            #[cfg(feature = "camellia")]
            Self::Camellia{key_bits: self_key_bits, mode: self_mode} => {
                if let TpmtSymDef::Camellia{key_bits: other_key_bits, mode: other_mode} = other {
                    self_key_bits == other_key_bits
                    && self_mode == other_mode
                } else {
                    false
                }
            },
            Self::Xor{key_bits: self_key_bits} => {
                if let TpmtSymDef::Xor{key_bits: other_key_bits} = other {
                    self_key_bits == other_key_bits
                } else {
                    false
                }
            },
            _ => false,
        }
    }
}

impl cmp::PartialEq<TpmtSymDefWCV> for TpmtSymDef {
    fn eq(&self, other: &TpmtSymDefWCV) -> bool {
        other.eq(self)
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 163, table 160, TPMT_SYM_DEF_OBJECT structure (without conditional values)
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[cfg_attr(any(feature = "aes", feature = "camellia", feature = "sm4", feature = "tdes"), repr(u16))]
pub enum TpmtSymDefObject {
    #[cfg(feature = "tdes")]
    Tdes{
        key_bits: TpmiTdesKeyBits,
        mode: TpmiAlgSymModeWCV,
    } = TpmAlgId::Tdes as u16,
    #[cfg(feature = "aes")]
    Aes{
        key_bits: TpmiAesKeyBits,
        mode: TpmiAlgSymModeWCV,
    } = TpmAlgId::Aes as u16,
    #[cfg(feature = "sm4")]
    Sm4{
        key_bits: TpmiSm4KeyBits,
        mode: TpmiAlgSymModeWCV,
    } = TpmAlgId::Sm4 as u16,
    #[cfg(feature = "camellia")]
    Camellia{
        key_bits: TpmiCamelliaKeyBits,
        mode: TpmiAlgSymModeWCV,
    } = TpmAlgId::Camellia as u16,
}

impl TpmtSymDefObject {
    pub const fn marshalled_max_size() -> u16 {
        tpmt_sym_def_object_marshalled_max_size()
    }

    const fn marshalled_selector_size() -> u16 {
        TpmiAlgSymObject::marshalled_size()
    }

    fn marshalled_data_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;
        match self {
            #[cfg(feature = "tdes")]
            Self::Tdes{key_bits: _, mode: _} => {
                let key_bits_size = match usize::try_from(TpmiTdesKeyBits::marshalled_size()) {
                    Ok(key_bits_size) => key_bits_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(key_bits_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };

                let mode_size = match usize::try_from(TpmiAlgSymModeWCV::marshalled_size()) {
                    Ok(mode_size) => mode_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(mode_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(feature = "aes")]
            Self::Aes{key_bits: _, mode: _} => {
                let key_bits_size = match usize::try_from(TpmiAesKeyBits::marshalled_size()) {
                    Ok(key_bits_size) => key_bits_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(key_bits_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };

                let mode_size = match usize::try_from(TpmiAlgSymModeWCV::marshalled_size()) {
                    Ok(mode_size) => mode_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(mode_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(feature = "sm4")]
            Self::Sm4{key_bits: _, mode: _} => {
                let key_bits_size = match usize::try_from(TpmiSm4KeyBits::marshalled_size()) {
                    Ok(key_bits_size) => key_bits_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(key_bits_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };

                let mode_size = match usize::try_from(TpmiAlgSymModeWCV::marshalled_size()) {
                    Ok(mode_size) => mode_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(mode_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(feature = "camellia")]
            Self::Camellia{key_bits: _, mode: _} => {
                let key_bits_size = match usize::try_from(TpmiCamelliaKeyBits::marshalled_size()) {
                    Ok(key_bits_size) => key_bits_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(key_bits_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };

                let mode_size = match usize::try_from(TpmiAlgSymModeWCV::marshalled_size()) {
                    Ok(mode_size) => mode_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(mode_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(not(any(feature = "aes", feature = "camellia", feature = "sm4", feature = "tdes")))]
            _ => unreachable!(),
        };

        Ok(size)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let selector_size = match usize::try_from(Self::marshalled_selector_size()) {
            Ok(selector_size) => selector_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(selector_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let data_size = match self.marshalled_data_size() {
            Ok(data_size) => data_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(data_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = match self {
            #[cfg(feature = "tdes")]
            Self::Tdes{key_bits, mode} => {
                let selector = TpmAlgId::Tdes as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = key_bits.marshal(buf)?;

                let buf = mode.marshal(buf)?;

                buf
            },
            #[cfg(feature = "aes")]
            Self::Aes{key_bits, mode} => {
                let selector = TpmAlgId::Aes as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = key_bits.marshal(buf)?;

                let buf = mode.marshal(buf)?;

                buf
            },
            #[cfg(feature = "sm4")]
            Self::Sm4{key_bits, mode} => {
                let selector = TpmAlgId::Sm4 as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = key_bits.marshal(buf)?;

                let buf = mode.marshal(buf)?;

                buf
            },
            #[cfg(feature = "camellia")]
            Self::Camellia{key_bits, mode} => {
                let selector = TpmAlgId::Camellia as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = key_bits.marshal(buf)?;

                let buf = mode.marshal(buf)?;

                buf
            },
            #[cfg(not(any(feature = "aes", feature = "camellia", feature = "sm4", feature = "tdes")))]
            _ => unreachable!(),
        };
        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_algorithm) = match unmarshal_u16(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, r) = match unmarshalled_algorithm {
            #[cfg(feature = "tdes")]
            value if value == TpmAlgId::Tdes as u16 => {
                let (buf, unmarshalled_key_bits) = match TpmiTdesKeyBits::unmarshal(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                let (buf, unmarshalled_mode) = match TpmiAlgSymModeWCV::unmarshal(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };


                (buf, Self::Tdes{key_bits: unmarshalled_key_bits, mode: unmarshalled_mode})
            },
            #[cfg(feature = "aes")]
            value if value == TpmAlgId::Aes as u16 => {
                let (buf, unmarshalled_key_bits) = match TpmiAesKeyBits::unmarshal(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                let (buf, unmarshalled_mode) = match TpmiAlgSymModeWCV::unmarshal(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };


                (buf, Self::Aes{key_bits: unmarshalled_key_bits, mode: unmarshalled_mode})
            },
            #[cfg(feature = "sm4")]
            value if value == TpmAlgId::Sm4 as u16 => {
                let (buf, unmarshalled_key_bits) = match TpmiSm4KeyBits::unmarshal(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                let (buf, unmarshalled_mode) = match TpmiAlgSymModeWCV::unmarshal(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };


                (buf, Self::Sm4{key_bits: unmarshalled_key_bits, mode: unmarshalled_mode})
            },
            #[cfg(feature = "camellia")]
            value if value == TpmAlgId::Camellia as u16 => {
                let (buf, unmarshalled_key_bits) = match TpmiCamelliaKeyBits::unmarshal(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                let (buf, unmarshalled_mode) = match TpmiAlgSymModeWCV::unmarshal(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };


                (buf, Self::Camellia{key_bits: unmarshalled_key_bits, mode: unmarshalled_mode})
            },
            _ => {
                return Err(TpmErr::Rc(TpmRc::SYMMETRIC));
            },
        };

        Ok((buf, r))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpmt_sym_def_object_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiAlgSymObject::marshalled_size();
    size += TpmuSymKeyBits::marshalled_max_size();
    size += TpmuSymMode::marshalled_max_size();
    size += TpmuSymDetails::marshalled_max_size();

    size
}

impl convert::From<&TpmtSymDefObject> for TpmiAlgSymObject {
    fn from(value: &TpmtSymDefObject) -> Self {
        match value {
            #[cfg(feature = "tdes")]
            TpmtSymDefObject::Tdes{key_bits: _, mode: _} => Self::Tdes,
            #[cfg(feature = "aes")]
            TpmtSymDefObject::Aes{key_bits: _, mode: _} => Self::Aes,
            #[cfg(feature = "sm4")]
            TpmtSymDefObject::Sm4{key_bits: _, mode: _} => Self::Sm4,
            #[cfg(feature = "camellia")]
            TpmtSymDefObject::Camellia{key_bits: _, mode: _} => Self::Camellia,
            #[cfg(not(any(feature = "aes", feature = "camellia", feature = "sm4", feature = "tdes")))]
            _ => unreachable!(),
        }
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 163, table 160, TPMT_SYM_DEF_OBJECT structure (with conditional values)
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u16)]
pub enum TpmtSymDefObjectWCV {
    #[cfg(feature = "tdes")]
    Tdes{
        key_bits: TpmiTdesKeyBits,
        mode: TpmiAlgSymModeWCV,
    } = TpmAlgId::Tdes as u16,
    #[cfg(feature = "aes")]
    Aes{
        key_bits: TpmiAesKeyBits,
        mode: TpmiAlgSymModeWCV,
    } = TpmAlgId::Aes as u16,
    #[cfg(feature = "sm4")]
    Sm4{
        key_bits: TpmiSm4KeyBits,
        mode: TpmiAlgSymModeWCV,
    } = TpmAlgId::Sm4 as u16,
    #[cfg(feature = "camellia")]
    Camellia{
        key_bits: TpmiCamelliaKeyBits,
        mode: TpmiAlgSymModeWCV,
    } = TpmAlgId::Camellia as u16,
    Null = TpmAlgId::Null as u16,
}

impl TpmtSymDefObjectWCV {
    pub const fn marshalled_max_size() -> u16 {
        tpmt_sym_def_object_wcv_marshalled_max_size()
    }

    const fn marshalled_selector_size() -> u16 {
        TpmiAlgSymObjectWCV::marshalled_size()
    }

    fn marshalled_data_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;
        match self {
            #[cfg(feature = "tdes")]
            Self::Tdes{key_bits: _, mode: _} => {
                let key_bits_size = match usize::try_from(TpmiTdesKeyBits::marshalled_size()) {
                    Ok(key_bits_size) => key_bits_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(key_bits_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };

                let mode_size = match usize::try_from(TpmiAlgSymModeWCV::marshalled_size()) {
                    Ok(mode_size) => mode_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(mode_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(feature = "aes")]
            Self::Aes{key_bits: _, mode: _} => {
                let key_bits_size = match usize::try_from(TpmiAesKeyBits::marshalled_size()) {
                    Ok(key_bits_size) => key_bits_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(key_bits_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };

                let mode_size = match usize::try_from(TpmiAlgSymModeWCV::marshalled_size()) {
                    Ok(mode_size) => mode_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(mode_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(feature = "sm4")]
            Self::Sm4{key_bits: _, mode: _} => {
                let key_bits_size = match usize::try_from(TpmiSm4KeyBits::marshalled_size()) {
                    Ok(key_bits_size) => key_bits_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(key_bits_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };

                let mode_size = match usize::try_from(TpmiAlgSymModeWCV::marshalled_size()) {
                    Ok(mode_size) => mode_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(mode_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(feature = "camellia")]
            Self::Camellia{key_bits: _, mode: _} => {
                let key_bits_size = match usize::try_from(TpmiCamelliaKeyBits::marshalled_size()) {
                    Ok(key_bits_size) => key_bits_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(key_bits_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };

                let mode_size = match usize::try_from(TpmiAlgSymModeWCV::marshalled_size()) {
                    Ok(mode_size) => mode_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(mode_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            Self::Null => (),
        };

        Ok(size)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let selector_size = match usize::try_from(Self::marshalled_selector_size()) {
            Ok(selector_size) => selector_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(selector_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let data_size = match self.marshalled_data_size() {
            Ok(data_size) => data_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(data_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = match self {
            #[cfg(feature = "tdes")]
            Self::Tdes{key_bits, mode} => {
                let selector = TpmAlgId::Tdes as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = key_bits.marshal(buf)?;

                let buf = mode.marshal(buf)?;

                buf
            },
            #[cfg(feature = "aes")]
            Self::Aes{key_bits, mode} => {
                let selector = TpmAlgId::Aes as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = key_bits.marshal(buf)?;

                let buf = mode.marshal(buf)?;

                buf
            },
            #[cfg(feature = "sm4")]
            Self::Sm4{key_bits, mode} => {
                let selector = TpmAlgId::Sm4 as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = key_bits.marshal(buf)?;

                let buf = mode.marshal(buf)?;

                buf
            },
            #[cfg(feature = "camellia")]
            Self::Camellia{key_bits, mode} => {
                let selector = TpmAlgId::Camellia as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = key_bits.marshal(buf)?;

                let buf = mode.marshal(buf)?;

                buf
            },
            Self::Null => {
                let selector = TpmAlgId::Null as u16;
                let buf = marshal_u16(buf, selector)?;

                buf
            },
        };
        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_algorithm) = match unmarshal_u16(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, r) = match unmarshalled_algorithm {
            #[cfg(feature = "tdes")]
            value if value == TpmAlgId::Tdes as u16 => {
                let (buf, unmarshalled_key_bits) = match TpmiTdesKeyBits::unmarshal(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                let (buf, unmarshalled_mode) = match TpmiAlgSymModeWCV::unmarshal(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };


                (buf, Self::Tdes{key_bits: unmarshalled_key_bits, mode: unmarshalled_mode})
            },
            #[cfg(feature = "aes")]
            value if value == TpmAlgId::Aes as u16 => {
                let (buf, unmarshalled_key_bits) = match TpmiAesKeyBits::unmarshal(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                let (buf, unmarshalled_mode) = match TpmiAlgSymModeWCV::unmarshal(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };


                (buf, Self::Aes{key_bits: unmarshalled_key_bits, mode: unmarshalled_mode})
            },
            #[cfg(feature = "sm4")]
            value if value == TpmAlgId::Sm4 as u16 => {
                let (buf, unmarshalled_key_bits) = match TpmiSm4KeyBits::unmarshal(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                let (buf, unmarshalled_mode) = match TpmiAlgSymModeWCV::unmarshal(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };


                (buf, Self::Sm4{key_bits: unmarshalled_key_bits, mode: unmarshalled_mode})
            },
            #[cfg(feature = "camellia")]
            value if value == TpmAlgId::Camellia as u16 => {
                let (buf, unmarshalled_key_bits) = match TpmiCamelliaKeyBits::unmarshal(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                let (buf, unmarshalled_mode) = match TpmiAlgSymModeWCV::unmarshal(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };


                (buf, Self::Camellia{key_bits: unmarshalled_key_bits, mode: unmarshalled_mode})
            },
            value if value == TpmAlgId::Null as u16 => {
                (buf, Self::Null)
            },
            _ => {
                return Err(TpmErr::Rc(TpmRc::SYMMETRIC));
            },
        };

        Ok((buf, r))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpmt_sym_def_object_wcv_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiAlgSymObjectWCV::marshalled_size();
    size += TpmuSymKeyBits::marshalled_max_size();
    size += TpmuSymMode::marshalled_max_size();
    size += TpmuSymDetails::marshalled_max_size();

    size
}

impl convert::From<&TpmtSymDefObjectWCV> for TpmiAlgSymObjectWCV {
    fn from(value: &TpmtSymDefObjectWCV) -> Self {
        match value {
            #[cfg(feature = "tdes")]
            TpmtSymDefObjectWCV::Tdes{key_bits: _, mode: _} => Self::Tdes,
            #[cfg(feature = "aes")]
            TpmtSymDefObjectWCV::Aes{key_bits: _, mode: _} => Self::Aes,
            #[cfg(feature = "sm4")]
            TpmtSymDefObjectWCV::Sm4{key_bits: _, mode: _} => Self::Sm4,
            #[cfg(feature = "camellia")]
            TpmtSymDefObjectWCV::Camellia{key_bits: _, mode: _} => Self::Camellia,
            TpmtSymDefObjectWCV::Null => Self::Null,
        }
    }
}

impl convert::From<TpmtSymDefObject> for TpmtSymDefObjectWCV {
    fn from(value: TpmtSymDefObject) -> Self {
        match value {
            #[cfg(feature = "tdes")]
            TpmtSymDefObject::Tdes{key_bits, mode} => Self::Tdes{key_bits, mode},
            #[cfg(feature = "aes")]
            TpmtSymDefObject::Aes{key_bits, mode} => Self::Aes{key_bits, mode},
            #[cfg(feature = "sm4")]
            TpmtSymDefObject::Sm4{key_bits, mode} => Self::Sm4{key_bits, mode},
            #[cfg(feature = "camellia")]
            TpmtSymDefObject::Camellia{key_bits, mode} => Self::Camellia{key_bits, mode},
            #[cfg(not(any(feature = "aes", feature = "camellia", feature = "sm4", feature = "tdes")))]
            _ => unreachable!(),
        }
    }
}

impl convert::TryFrom<TpmtSymDefObjectWCV> for TpmtSymDefObject {
    type Error = TpmErr;

    fn try_from(value: TpmtSymDefObjectWCV) -> Result<Self, TpmErr> {
        let result = match value {
            #[cfg(feature = "tdes")]
            TpmtSymDefObjectWCV::Tdes{key_bits, mode} => Self::Tdes{key_bits, mode},
            #[cfg(feature = "aes")]
            TpmtSymDefObjectWCV::Aes{key_bits, mode} => Self::Aes{key_bits, mode},
            #[cfg(feature = "sm4")]
            TpmtSymDefObjectWCV::Sm4{key_bits, mode} => Self::Sm4{key_bits, mode},
            #[cfg(feature = "camellia")]
            TpmtSymDefObjectWCV::Camellia{key_bits, mode} => Self::Camellia{key_bits, mode},
            _ => {
                return Err(TpmErr::Rc(TpmRc::SYMMETRIC));
            },
        };

        Ok(result)
    }
}

impl cmp::PartialEq<TpmtSymDefObject> for TpmtSymDefObjectWCV {
    fn eq(&self, other: &TpmtSymDefObject) -> bool {
        match self {
            #[cfg(feature = "tdes")]
            Self::Tdes{key_bits: self_key_bits, mode: self_mode} => {
                if let TpmtSymDefObject::Tdes{key_bits: other_key_bits, mode: other_mode} = other {
                    self_key_bits == other_key_bits
                    && self_mode == other_mode
                } else {
                    false
                }
            },
            #[cfg(feature = "aes")]
            Self::Aes{key_bits: self_key_bits, mode: self_mode} => {
                if let TpmtSymDefObject::Aes{key_bits: other_key_bits, mode: other_mode} = other {
                    self_key_bits == other_key_bits
                    && self_mode == other_mode
                } else {
                    false
                }
            },
            #[cfg(feature = "sm4")]
            Self::Sm4{key_bits: self_key_bits, mode: self_mode} => {
                if let TpmtSymDefObject::Sm4{key_bits: other_key_bits, mode: other_mode} = other {
                    self_key_bits == other_key_bits
                    && self_mode == other_mode
                } else {
                    false
                }
            },
            #[cfg(feature = "camellia")]
            Self::Camellia{key_bits: self_key_bits, mode: self_mode} => {
                if let TpmtSymDefObject::Camellia{key_bits: other_key_bits, mode: other_mode} = other {
                    self_key_bits == other_key_bits
                    && self_mode == other_mode
                } else {
                    false
                }
            },
            _ => false,
        }
    }
}

impl cmp::PartialEq<TpmtSymDefObjectWCV> for TpmtSymDefObject {
    fn eq(&self, other: &TpmtSymDefObjectWCV) -> bool {
        other.eq(self)
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 163, table 161, TPM2B_SYM_KEY structure
#[derive(Debug, PartialEq)]
pub struct Tpm2bSymKey<'a> {
    pub buffer: TpmBuffer<'a>,
}

impl<'a> Tpm2bSymKey<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2b_sym_key_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let size_size = mem::size_of::<u16>();
        size = match size.checked_add(size_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let buffer_size = self.buffer.len();
        size = match size.checked_add(buffer_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let marshalled_size = match u16::try_from(self.buffer.len()) {
            Ok(marshalled_size) => marshalled_size,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::SIZE));
            },
        };
        let buf = marshal_u16(buf, marshalled_size)?;

        let buf = marshal_bytes(buf, &self.buffer)?;

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_size) = match unmarshal_u16(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let buffer_size: u16 = unmarshalled_size;
        let v0 = match limits.max_sym_key_bytes() {
            Ok(v) => v,
            Err(_) => {
                debug_assert!(false, "Unexpected runtime constant evaluation failure");
                return Err(TpmErr::InternalErr);
            },
        };
        if buffer_size > v0 {
            return Err(TpmErr::Rc(TpmRc::SIZE));
        }
        let buffer_size = match usize::try_from(buffer_size) {
            Ok(buffer_size) => buffer_size,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::INSUFFICIENT));
            },
        };
        let (unmarshalled_buffer, buf) = match split_slice_at(buf, buffer_size) {
            Ok((unmarshalled_buffer, buf)) => (unmarshalled_buffer, buf),
            Err(e) => {
                return Err(e);
            },
        };
        let unmarshalled_buffer = TpmBuffer::from(unmarshalled_buffer);

        Ok((buf, Self{buffer: unmarshalled_buffer}))
    }

    pub fn unmarshal(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2bSymKey<'static>, TpmErr> {
        let buffer = copy_vec_from_slice(&self.buffer)?;
        let buffer = TpmBuffer::Owned(buffer);

        Ok(Tpm2bSymKey {
            buffer,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2bSymKey<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2bSymKey<'static>, TpmErr> {
        let Self {
            buffer,
        } = self;

        let buffer = buffer.into_owned()?;

        Ok(Tpm2bSymKey {
            buffer,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2bSymKey<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpm2b_sym_key_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    size += mem::size_of::<u16>() as u32;

    let v0 = match limits.max_sym_key_bytes() {
        Ok(v) => v,
        Err(_) => {
            debug_assert!(false, "Unexpected runtime constant evaluation failure");
            return Err(());
        },
    };
    let buffer_size = v0 as u32;
    size = size.checked_add(buffer_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 164, table 162, TPMS_SYMCIPHER_PARMS structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct TpmsSymcipherParms {
    pub sym: TpmtSymDefObject,
}

impl TpmsSymcipherParms {
    pub const fn marshalled_max_size() -> u16 {
        tpms_symcipher_parms_marshalled_max_size()
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let sym_size = match self.sym.marshalled_size() {
            Ok(sym_size) => sym_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(sym_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.sym.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_sym) = match TpmtSymDefObject::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{sym: unmarshalled_sym}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpms_symcipher_parms_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += tpmt_sym_def_object_marshalled_max_size();

    size
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 164, table 163, TPM2B_LABEL structure
#[derive(Debug, PartialEq)]
pub struct Tpm2bLabel<'a> {
    pub buffer: TpmBuffer<'a>,
}

impl<'a> Tpm2bLabel<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2b_label_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let size_size = mem::size_of::<u16>();
        size = match size.checked_add(size_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let buffer_size = self.buffer.len();
        size = match size.checked_add(buffer_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let marshalled_size = match u16::try_from(self.buffer.len()) {
            Ok(marshalled_size) => marshalled_size,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::SIZE));
            },
        };
        let buf = marshal_u16(buf, marshalled_size)?;

        let buf = marshal_bytes(buf, &self.buffer)?;

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_size) = match unmarshal_u16(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let buffer_size: u16 = unmarshalled_size;
        let v0 = match limits.label_max_buffer() {
            Ok(v) => v,
            Err(_) => {
                debug_assert!(false, "Unexpected runtime constant evaluation failure");
                return Err(TpmErr::InternalErr);
            },
        };
        if buffer_size > v0 {
            return Err(TpmErr::Rc(TpmRc::SIZE));
        }
        let buffer_size = match usize::try_from(buffer_size) {
            Ok(buffer_size) => buffer_size,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::INSUFFICIENT));
            },
        };
        let (unmarshalled_buffer, buf) = match split_slice_at(buf, buffer_size) {
            Ok((unmarshalled_buffer, buf)) => (unmarshalled_buffer, buf),
            Err(e) => {
                return Err(e);
            },
        };
        let unmarshalled_buffer = TpmBuffer::from(unmarshalled_buffer);

        Ok((buf, Self{buffer: unmarshalled_buffer}))
    }

    pub fn unmarshal(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2bLabel<'static>, TpmErr> {
        let buffer = copy_vec_from_slice(&self.buffer)?;
        let buffer = TpmBuffer::Owned(buffer);

        Ok(Tpm2bLabel {
            buffer,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2bLabel<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2bLabel<'static>, TpmErr> {
        let Self {
            buffer,
        } = self;

        let buffer = buffer.into_owned()?;

        Ok(Tpm2bLabel {
            buffer,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2bLabel<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpm2b_label_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    size += mem::size_of::<u16>() as u32;

    let v0 = match limits.label_max_buffer() {
        Ok(v) => v,
        Err(_) => {
            debug_assert!(false, "Unexpected runtime constant evaluation failure");
            return Err(());
        },
    };
    let buffer_size = v0 as u32;
    size = size.checked_add(buffer_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 164, table 164, TPMS_DERIVE structure
#[derive(Debug, PartialEq)]
pub struct TpmsDerive<'a> {
    pub label: Tpm2bLabel<'a>,
    pub context: Tpm2bLabel<'a>,
}

impl<'a> TpmsDerive<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpms_derive_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let label_size = match self.label.marshalled_size() {
            Ok(label_size) => label_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(label_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let context_size = match self.context.marshalled_size() {
            Ok(context_size) => context_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(context_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.label.marshal(buf)?;

        let buf = self.context.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_label) = match Tpm2bLabel::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_context) = match Tpm2bLabel::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{label: unmarshalled_label, context: unmarshalled_context}))
    }

    pub fn unmarshal(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<TpmsDerive<'static>, TpmErr> {
        Ok(TpmsDerive {
            label: self.label.try_clone_intern()?,
            context: self.context.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<TpmsDerive<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<TpmsDerive<'static>, TpmErr> {
        let Self {
            label,
            context,
        } = self;

        let label = label.into_bufs_owner_intern()?;
        let context = context.into_bufs_owner_intern()?;

        Ok(TpmsDerive {
            label,
            context,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<TpmsDerive<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpms_derive_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    let label_size = match tpm2b_label_marshalled_max_size(limits) {
        Ok(label_size) => label_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(label_size).ok_or(())?;

    let context_size = match tpm2b_label_marshalled_max_size(limits) {
        Ok(context_size) => context_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(context_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 165, table 165, TPM2B_DERIVE structure
#[derive(Debug, PartialEq)]
pub struct Tpm2bDerive<'a> {
    pub buffer: TpmBuffer<'a>,
}

impl<'a> Tpm2bDerive<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2b_derive_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let size_size = mem::size_of::<u16>();
        size = match size.checked_add(size_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let buffer_size = self.buffer.len();
        size = match size.checked_add(buffer_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let marshalled_size = match u16::try_from(self.buffer.len()) {
            Ok(marshalled_size) => marshalled_size,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::SIZE));
            },
        };
        let buf = marshal_u16(buf, marshalled_size)?;

        let buf = marshal_bytes(buf, &self.buffer)?;

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_size) = match unmarshal_u16(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let buffer_size: u16 = unmarshalled_size;
        let v0 = match tpms_derive_marshalled_max_size(limits) {
            Ok(v) => v,
            Err(_) => {
                debug_assert!(false, "Unexpected sizeof() evaluation failure");
                return Err(TpmErr::InternalErr);
            },
        };
        if buffer_size as u32 > v0 {
            return Err(TpmErr::Rc(TpmRc::SIZE));
        }
        let buffer_size = match usize::try_from(buffer_size) {
            Ok(buffer_size) => buffer_size,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::INSUFFICIENT));
            },
        };
        let (unmarshalled_buffer, buf) = match split_slice_at(buf, buffer_size) {
            Ok((unmarshalled_buffer, buf)) => (unmarshalled_buffer, buf),
            Err(e) => {
                return Err(e);
            },
        };
        let unmarshalled_buffer = TpmBuffer::from(unmarshalled_buffer);

        Ok((buf, Self{buffer: unmarshalled_buffer}))
    }

    pub fn unmarshal(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2bDerive<'static>, TpmErr> {
        let buffer = copy_vec_from_slice(&self.buffer)?;
        let buffer = TpmBuffer::Owned(buffer);

        Ok(Tpm2bDerive {
            buffer,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2bDerive<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2bDerive<'static>, TpmErr> {
        let Self {
            buffer,
        } = self;

        let buffer = buffer.into_owned()?;

        Ok(Tpm2bDerive {
            buffer,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2bDerive<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpm2b_derive_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    size += mem::size_of::<u16>() as u32;

    let v0 = match tpms_derive_marshalled_max_size(limits) {
        Ok(v) => v,
        Err(_) => {
            debug_assert!(false, "Unexpected sizeof() evaluation failure");
            return Err(());
        },
    };
    let buffer_size = v0;
    size = size.checked_add(buffer_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 165, table 166, TPMU_SENSITIVE_CREATE union
struct TpmuSensitiveCreate {}

impl TpmuSensitiveCreate {
    fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        let mut size: u32 = 0;

        let v0 = match limits.max_sym_data() {
            Ok(v) => v,
            Err(_) => {
                debug_assert!(false, "Unexpected runtime constant evaluation failure");
                return Err(());
            },
        };
        let create_size = v0;
        if create_size > size {
            size = create_size;
        }

        let derive_size = match tpms_derive_marshalled_max_size(limits) {
            Ok(derive_size) => derive_size,
            Err(_) => {
                return Err(());
            },
        };
        if derive_size > size {
            size = derive_size;
        }

        Ok(size)
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 165, table 167, TPM2B_SENSITIVE_DATA structure
#[derive(Debug, PartialEq)]
pub struct Tpm2bSensitiveData<'a> {
    pub buffer: TpmBuffer<'a>,
}

impl<'a> Tpm2bSensitiveData<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2b_sensitive_data_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let size_size = mem::size_of::<u16>();
        size = match size.checked_add(size_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let buffer_size = self.buffer.len();
        size = match size.checked_add(buffer_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let marshalled_size = match u16::try_from(self.buffer.len()) {
            Ok(marshalled_size) => marshalled_size,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::SIZE));
            },
        };
        let buf = marshal_u16(buf, marshalled_size)?;

        let buf = marshal_bytes(buf, &self.buffer)?;

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_size) = match unmarshal_u16(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let buffer_size: u16 = unmarshalled_size;
        let v0 = match TpmuSensitiveCreate::marshalled_max_size(limits) {
            Ok(v) => v,
            Err(_) => {
                debug_assert!(false, "Unexpected sizeof() evaluation failure");
                return Err(TpmErr::InternalErr);
            },
        };
        if buffer_size as u32 > v0 {
            return Err(TpmErr::Rc(TpmRc::SIZE));
        }
        let buffer_size = match usize::try_from(buffer_size) {
            Ok(buffer_size) => buffer_size,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::INSUFFICIENT));
            },
        };
        let (unmarshalled_buffer, buf) = match split_slice_at(buf, buffer_size) {
            Ok((unmarshalled_buffer, buf)) => (unmarshalled_buffer, buf),
            Err(e) => {
                return Err(e);
            },
        };
        let unmarshalled_buffer = TpmBuffer::from(unmarshalled_buffer);

        Ok((buf, Self{buffer: unmarshalled_buffer}))
    }

    pub fn unmarshal(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2bSensitiveData<'static>, TpmErr> {
        let buffer = copy_vec_from_slice(&self.buffer)?;
        let buffer = TpmBuffer::Owned(buffer);

        Ok(Tpm2bSensitiveData {
            buffer,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2bSensitiveData<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2bSensitiveData<'static>, TpmErr> {
        let Self {
            buffer,
        } = self;

        let buffer = buffer.into_owned()?;

        Ok(Tpm2bSensitiveData {
            buffer,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2bSensitiveData<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpm2b_sensitive_data_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    size += mem::size_of::<u16>() as u32;

    let v0 = match TpmuSensitiveCreate::marshalled_max_size(limits) {
        Ok(v) => v,
        Err(_) => {
            debug_assert!(false, "Unexpected sizeof() evaluation failure");
            return Err(());
        },
    };
    let buffer_size = v0;
    size = size.checked_add(buffer_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 166, table 168, TPMS_SENSITIVE_CREATE structure
#[derive(Debug, PartialEq)]
pub struct TpmsSensitiveCreate<'a> {
    pub user_auth: Tpm2bDigest<'a>,
    pub data: Tpm2bSensitiveData<'a>,
}

impl<'a> TpmsSensitiveCreate<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpms_sensitive_create_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let user_auth_size = match self.user_auth.marshalled_size() {
            Ok(user_auth_size) => user_auth_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(user_auth_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let data_size = match self.data.marshalled_size() {
            Ok(data_size) => data_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(data_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.user_auth.marshal(buf)?;

        let buf = self.data.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_user_auth) = match Tpm2bDigest::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_data) = match Tpm2bSensitiveData::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{user_auth: unmarshalled_user_auth, data: unmarshalled_data}))
    }

    pub fn unmarshal(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<TpmsSensitiveCreate<'static>, TpmErr> {
        Ok(TpmsSensitiveCreate {
            user_auth: self.user_auth.try_clone_intern()?,
            data: self.data.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<TpmsSensitiveCreate<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<TpmsSensitiveCreate<'static>, TpmErr> {
        let Self {
            user_auth,
            data,
        } = self;

        let user_auth = user_auth.into_bufs_owner_intern()?;
        let data = data.into_bufs_owner_intern()?;

        Ok(TpmsSensitiveCreate {
            user_auth,
            data,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<TpmsSensitiveCreate<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpms_sensitive_create_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    size += tpm2b_digest_marshalled_max_size() as u32;

    let data_size = match tpm2b_sensitive_data_marshalled_max_size(limits) {
        Ok(data_size) => data_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(data_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 166, table 169, TPM2B_SENSITIVE_CREATE structure
#[derive(Debug, PartialEq)]
pub struct Tpm2bSensitiveCreate<'a> {
    pub sensitive: TpmsSensitiveCreate<'a>,
}

impl<'a> Tpm2bSensitiveCreate<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2b_sensitive_create_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let size_size = mem::size_of::<u16>();
        size = match size.checked_add(size_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let sensitive_size = match self.sensitive.marshalled_size() {
            Ok(sensitive_size) => sensitive_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(sensitive_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let mut marshalled_size: usize = 0;

        let sensitive_size = match self.sensitive.marshalled_size() {
            Ok(sensitive_size) => sensitive_size,
            Err(_) => {
                return Err(TpmErr::InternalErr);
            },
        };
        marshalled_size = match marshalled_size.checked_add(sensitive_size) {
            Some(marshalled_size) => marshalled_size,
            None => {
                return Err(TpmErr::InternalErr);
            },
        };

        let marshalled_size = match u16::try_from(marshalled_size) {
            Ok(marshalled_size) => marshalled_size,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::SIZE));
            },
        };
        let buf = marshal_u16(buf, marshalled_size)?;

        let buf = self.sensitive.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_size) = match unmarshal_u16(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let unmarshalled_size = match usize::try_from(unmarshalled_size) {
            Ok(unmarshalled_size) => unmarshalled_size,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::SIZE));
            },
        };
        if unmarshalled_size == 0usize {
            return Err(TpmErr::Rc(TpmRc::SIZE));
        }
        let buf_len_at_size = buf.len();

        let (buf, unmarshalled_sensitive) = match TpmsSensitiveCreate::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        if unmarshalled_size != buf_len_at_size - buf.len() {
            return Err(TpmErr::Rc(TpmRc::SIZE));
        }

        Ok((buf, Self{sensitive: unmarshalled_sensitive}))
    }

    pub fn unmarshal(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2bSensitiveCreate<'static>, TpmErr> {
        Ok(Tpm2bSensitiveCreate {
            sensitive: self.sensitive.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2bSensitiveCreate<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2bSensitiveCreate<'static>, TpmErr> {
        let Self {
            sensitive,
        } = self;

        let sensitive = sensitive.into_bufs_owner_intern()?;

        Ok(Tpm2bSensitiveCreate {
            sensitive,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2bSensitiveCreate<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpm2b_sensitive_create_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    size += mem::size_of::<u16>() as u32;

    let sensitive_size = match tpms_sensitive_create_marshalled_max_size(limits) {
        Ok(sensitive_size) => sensitive_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(sensitive_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 166, table 170, TPMS_SCHEME_HASH structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct TpmsSchemeHash {
    pub hash_alg: TpmiAlgHash,
}

impl TpmsSchemeHash {
    pub const fn marshalled_size() -> u16 {
        tpms_scheme_hash_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.hash_alg.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_hash_alg) = match TpmiAlgHash::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{hash_alg: unmarshalled_hash_alg}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpms_scheme_hash_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiAlgHash::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 167, table 171, TPMS_SCHEME_ECDAA structure
#[cfg(feature = "ecc")]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct TpmsSchemeEcdaa {
    pub hash_alg: TpmiAlgHash,
    pub count: u16,
}

#[cfg(feature = "ecc")]
impl TpmsSchemeEcdaa {
    pub const fn marshalled_size() -> u16 {
        tpms_scheme_ecdaa_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.hash_alg.marshal(buf)?;

        let buf = marshal_u16(buf, self.count)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_hash_alg) = match TpmiAlgHash::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_count) = match unmarshal_u16(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{hash_alg: unmarshalled_hash_alg, count: unmarshalled_count}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

#[cfg(feature = "ecc")]
const fn tpms_scheme_ecdaa_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiAlgHash::marshalled_size();
    size += mem::size_of::<u16>() as u16;

    size
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 167, table 172, TPMI_ALG_KEYEDHASH_SCHEME type (without conditional values)
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u16)]
pub enum TpmiAlgKeyedhashScheme {
    #[cfg(feature = "hmac")]
    Hmac = TpmAlgId::Hmac as u16,
    Xor = TpmAlgId::Xor as u16,
}

impl TpmiAlgKeyedhashScheme {
    pub const fn marshalled_size() -> u16 {
        mem::size_of::<u16>() as u16
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u16(buf, *self as u16)
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u16(buf)?;
        let result = Self::try_from(value)?;
        Ok((buf, result))
    }
}

impl convert::TryFrom<u16> for TpmiAlgKeyedhashScheme {
    type Error = TpmErr;

    fn try_from(value: u16) -> Result<Self, TpmErr> {
        let result = match value {
            #[cfg(feature = "hmac")]
            value if value == Self::Hmac as u16 => Self::Hmac,
            value if value == Self::Xor as u16 => Self::Xor,
            _ => {
                return Err(TpmErr::Rc(TpmRc::VALUE));
            },
        };

        Ok(result)
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 167, table 172, TPMI_ALG_KEYEDHASH_SCHEME type (with conditional values)
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u16)]
pub enum TpmiAlgKeyedhashSchemeWCV {
    #[cfg(feature = "hmac")]
    Hmac = TpmAlgId::Hmac as u16,
    Xor = TpmAlgId::Xor as u16,
    Null = TpmAlgId::Null as u16,
}

impl TpmiAlgKeyedhashSchemeWCV {
    pub const fn marshalled_size() -> u16 {
        mem::size_of::<u16>() as u16
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u16(buf, *self as u16)
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u16(buf)?;
        let result = Self::try_from(value)?;
        Ok((buf, result))
    }
}

impl convert::TryFrom<u16> for TpmiAlgKeyedhashSchemeWCV {
    type Error = TpmErr;

    fn try_from(value: u16) -> Result<Self, TpmErr> {
        let result = match value {
            #[cfg(feature = "hmac")]
            value if value == Self::Hmac as u16 => Self::Hmac,
            value if value == Self::Xor as u16 => Self::Xor,
            value if value == Self::Null as u16 => Self::Null,
            _ => {
                return Err(TpmErr::Rc(TpmRc::VALUE));
            },
        };

        Ok(result)
    }
}

impl convert::From<TpmiAlgKeyedhashScheme> for TpmiAlgKeyedhashSchemeWCV {
    fn from(value: TpmiAlgKeyedhashScheme) -> Self {
        match value {
            #[cfg(feature = "hmac")]
            TpmiAlgKeyedhashScheme::Hmac => Self::Hmac,
            TpmiAlgKeyedhashScheme::Xor => Self::Xor,
        }
    }
}

impl convert::TryFrom<TpmiAlgKeyedhashSchemeWCV> for TpmiAlgKeyedhashScheme {
    type Error = TpmErr;

    fn try_from(value: TpmiAlgKeyedhashSchemeWCV) -> Result<Self, TpmErr> {
        let result = match value {
            #[cfg(feature = "hmac")]
            TpmiAlgKeyedhashSchemeWCV::Hmac => Self::Hmac,
            TpmiAlgKeyedhashSchemeWCV::Xor => Self::Xor,
            TpmiAlgKeyedhashSchemeWCV::Null => {
                return Err(TpmErr::Rc(TpmRc::VALUE));
            },
        };
        Ok(result)
    }
}

impl cmp::PartialEq<TpmiAlgKeyedhashScheme> for TpmiAlgKeyedhashSchemeWCV {
    fn eq(&self, other: &TpmiAlgKeyedhashScheme) -> bool {
        *self as u16 == *other as u16
    }
}

impl cmp::PartialEq<TpmiAlgKeyedhashSchemeWCV> for TpmiAlgKeyedhashScheme {
    fn eq(&self, other: &TpmiAlgKeyedhashSchemeWCV) -> bool {
        other.eq(self)
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 167, table 174, TPMS_SCHEME_XOR structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct TpmsSchemeXor {
    pub hash_alg: TpmiAlgHash,
    pub kdf: TpmiAlgKdfWCV,
}

impl TpmsSchemeXor {
    pub const fn marshalled_size() -> u16 {
        tpms_scheme_xor_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.hash_alg.marshal(buf)?;

        let buf = self.kdf.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_hash_alg) = match TpmiAlgHash::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_kdf) = match TpmiAlgKdfWCV::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{hash_alg: unmarshalled_hash_alg, kdf: unmarshalled_kdf}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpms_scheme_xor_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiAlgHash::marshalled_size();
    size += TpmiAlgKdfWCV::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 168, table 175, TPMU_SCHEME_KEYEDHASH union
struct TpmuSchemeKeyedhash {}

impl TpmuSchemeKeyedhash {
    const fn marshalled_max_size() -> u16 {
        let mut size: u16 = 0;

        #[cfg(feature = "hmac")]
        {
            let hmac_size = tpms_scheme_hash_marshalled_size();
            if hmac_size > size {
                size = hmac_size;
            }
        }

        let xor_size = tpms_scheme_xor_marshalled_size();
        if xor_size > size {
            size = xor_size;
        }

        size
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 168, table 176, TPMT_KEYEDHASH_SCHEME structure (without conditional values)
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u16)]
pub enum TpmtKeyedhashScheme {
    #[cfg(feature = "hmac")]
    Hmac(TpmsSchemeHash) = TpmAlgId::Hmac as u16,
    Xor(TpmsSchemeXor) = TpmAlgId::Xor as u16,
}

impl TpmtKeyedhashScheme {
    pub const fn marshalled_max_size() -> u16 {
        tpmt_keyedhash_scheme_marshalled_max_size()
    }

    const fn marshalled_selector_size() -> u16 {
        TpmiAlgKeyedhashScheme::marshalled_size()
    }

    fn marshalled_data_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;
        match self {
            #[cfg(feature = "hmac")]
            Self::Hmac(_) => {
                let details_size = match usize::try_from(tpms_scheme_hash_marshalled_size()) {
                    Ok(details_size) => details_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(details_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            Self::Xor(_) => {
                let details_size = match usize::try_from(tpms_scheme_xor_marshalled_size()) {
                    Ok(details_size) => details_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(details_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
        };

        Ok(size)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let selector_size = match usize::try_from(Self::marshalled_selector_size()) {
            Ok(selector_size) => selector_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(selector_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let data_size = match self.marshalled_data_size() {
            Ok(data_size) => data_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(data_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = match self {
            #[cfg(feature = "hmac")]
            Self::Hmac(details) => {
                let selector = TpmAlgId::Hmac as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = details.marshal(buf)?;

                buf
            },
            Self::Xor(details) => {
                let selector = TpmAlgId::Xor as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = details.marshal(buf)?;

                buf
            },
        };
        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_scheme) = match unmarshal_u16(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, r) = match unmarshalled_scheme {
            #[cfg(feature = "hmac")]
            value if value == TpmAlgId::Hmac as u16 => {
                let (buf, unmarshalled_details) = match TpmsSchemeHash::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Hmac(unmarshalled_details))
            },
            value if value == TpmAlgId::Xor as u16 => {
                let (buf, unmarshalled_details) = match TpmsSchemeXor::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Xor(unmarshalled_details))
            },
            _ => {
                return Err(TpmErr::Rc(TpmRc::VALUE));
            },
        };

        Ok((buf, r))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpmt_keyedhash_scheme_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiAlgKeyedhashScheme::marshalled_size();
    size += TpmuSchemeKeyedhash::marshalled_max_size();

    size
}

impl convert::From<&TpmtKeyedhashScheme> for TpmiAlgKeyedhashScheme {
    fn from(value: &TpmtKeyedhashScheme) -> Self {
        match value {
            #[cfg(feature = "hmac")]
            TpmtKeyedhashScheme::Hmac(_) => Self::Hmac,
            TpmtKeyedhashScheme::Xor(_) => Self::Xor,
        }
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 168, table 176, TPMT_KEYEDHASH_SCHEME structure (with conditional values)
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u16)]
pub enum TpmtKeyedhashSchemeWCV {
    #[cfg(feature = "hmac")]
    Hmac(TpmsSchemeHash) = TpmAlgId::Hmac as u16,
    Xor(TpmsSchemeXor) = TpmAlgId::Xor as u16,
    Null = TpmAlgId::Null as u16,
}

impl TpmtKeyedhashSchemeWCV {
    pub const fn marshalled_max_size() -> u16 {
        tpmt_keyedhash_scheme_wcv_marshalled_max_size()
    }

    const fn marshalled_selector_size() -> u16 {
        TpmiAlgKeyedhashSchemeWCV::marshalled_size()
    }

    fn marshalled_data_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;
        match self {
            #[cfg(feature = "hmac")]
            Self::Hmac(_) => {
                let details_size = match usize::try_from(tpms_scheme_hash_marshalled_size()) {
                    Ok(details_size) => details_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(details_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            Self::Xor(_) => {
                let details_size = match usize::try_from(tpms_scheme_xor_marshalled_size()) {
                    Ok(details_size) => details_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(details_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            Self::Null => (),
        };

        Ok(size)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let selector_size = match usize::try_from(Self::marshalled_selector_size()) {
            Ok(selector_size) => selector_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(selector_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let data_size = match self.marshalled_data_size() {
            Ok(data_size) => data_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(data_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = match self {
            #[cfg(feature = "hmac")]
            Self::Hmac(details) => {
                let selector = TpmAlgId::Hmac as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = details.marshal(buf)?;

                buf
            },
            Self::Xor(details) => {
                let selector = TpmAlgId::Xor as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = details.marshal(buf)?;

                buf
            },
            Self::Null => {
                let selector = TpmAlgId::Null as u16;
                let buf = marshal_u16(buf, selector)?;

                buf
            },
        };
        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_scheme) = match unmarshal_u16(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, r) = match unmarshalled_scheme {
            #[cfg(feature = "hmac")]
            value if value == TpmAlgId::Hmac as u16 => {
                let (buf, unmarshalled_details) = match TpmsSchemeHash::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Hmac(unmarshalled_details))
            },
            value if value == TpmAlgId::Xor as u16 => {
                let (buf, unmarshalled_details) = match TpmsSchemeXor::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Xor(unmarshalled_details))
            },
            value if value == TpmAlgId::Null as u16 => {
                (buf, Self::Null)
            },
            _ => {
                return Err(TpmErr::Rc(TpmRc::VALUE));
            },
        };

        Ok((buf, r))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpmt_keyedhash_scheme_wcv_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiAlgKeyedhashSchemeWCV::marshalled_size();
    size += TpmuSchemeKeyedhash::marshalled_max_size();

    size
}

impl convert::From<&TpmtKeyedhashSchemeWCV> for TpmiAlgKeyedhashSchemeWCV {
    fn from(value: &TpmtKeyedhashSchemeWCV) -> Self {
        match value {
            #[cfg(feature = "hmac")]
            TpmtKeyedhashSchemeWCV::Hmac(_) => Self::Hmac,
            TpmtKeyedhashSchemeWCV::Xor(_) => Self::Xor,
            TpmtKeyedhashSchemeWCV::Null => Self::Null,
        }
    }
}

impl convert::From<TpmtKeyedhashScheme> for TpmtKeyedhashSchemeWCV {
    fn from(value: TpmtKeyedhashScheme) -> Self {
        match value {
            #[cfg(feature = "hmac")]
            TpmtKeyedhashScheme::Hmac(details) => Self::Hmac(details),
            TpmtKeyedhashScheme::Xor(details) => Self::Xor(details),
        }
    }
}

impl convert::TryFrom<TpmtKeyedhashSchemeWCV> for TpmtKeyedhashScheme {
    type Error = TpmErr;

    fn try_from(value: TpmtKeyedhashSchemeWCV) -> Result<Self, TpmErr> {
        let result = match value {
            #[cfg(feature = "hmac")]
            TpmtKeyedhashSchemeWCV::Hmac(details) => Self::Hmac(details),
            TpmtKeyedhashSchemeWCV::Xor(details) => Self::Xor(details),
            _ => {
                return Err(TpmErr::Rc(TpmRc::VALUE));
            },
        };

        Ok(result)
    }
}

impl cmp::PartialEq<TpmtKeyedhashScheme> for TpmtKeyedhashSchemeWCV {
    fn eq(&self, other: &TpmtKeyedhashScheme) -> bool {
        match self {
            #[cfg(feature = "hmac")]
            Self::Hmac(self_details) => {
                if let TpmtKeyedhashScheme::Hmac(other_details) = other {
                    self_details == other_details
                } else {
                    false
                }
            },
            Self::Xor(self_details) => {
                if let TpmtKeyedhashScheme::Xor(other_details) = other {
                    self_details == other_details
                } else {
                    false
                }
            },
            _ => false,
        }
    }
}

impl cmp::PartialEq<TpmtKeyedhashSchemeWCV> for TpmtKeyedhashScheme {
    fn eq(&self, other: &TpmtKeyedhashSchemeWCV) -> bool {
        other.eq(self)
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 169, table 179, TPMU_SIG_SCHEME union
struct TpmuSigScheme {}

impl TpmuSigScheme {
    const fn marshalled_max_size() -> u16 {
        let mut size: u16 = 0;

        #[cfg(all(feature = "rsa", feature = "rsassa"))]
        {
            let rsassa_size = tpms_scheme_hash_marshalled_size();
            if rsassa_size > size {
                size = rsassa_size;
            }
        }

        #[cfg(all(feature = "rsa", feature = "rsapss"))]
        {
            let rsapss_size = tpms_scheme_hash_marshalled_size();
            if rsapss_size > size {
                size = rsapss_size;
            }
        }

        #[cfg(all(feature = "ecc", feature = "ecdsa"))]
        {
            let ecdsa_size = tpms_scheme_hash_marshalled_size();
            if ecdsa_size > size {
                size = ecdsa_size;
            }
        }

        #[cfg(all(feature = "ecc", feature = "ecdaa"))]
        {
            let ecdaa_size = tpms_scheme_ecdaa_marshalled_size();
            if ecdaa_size > size {
                size = ecdaa_size;
            }
        }

        #[cfg(all(feature = "ecc", feature = "sm2"))]
        {
            let sm2_size = tpms_scheme_hash_marshalled_size();
            if sm2_size > size {
                size = sm2_size;
            }
        }

        #[cfg(all(feature = "ecc", feature = "ecschnorr"))]
        {
            let ecschnorr_size = tpms_scheme_hash_marshalled_size();
            if ecschnorr_size > size {
                size = ecschnorr_size;
            }
        }

        #[cfg(all(feature = "ecc", feature = "eddsa"))]
        {
            let eddsa_size = tpms_scheme_hash_marshalled_size();
            if eddsa_size > size {
                size = eddsa_size;
            }
        }

        #[cfg(all(feature = "ecc", feature = "eddsa_ph"))]
        {
            let eddsa_ph_size = tpms_scheme_hash_marshalled_size();
            if eddsa_ph_size > size {
                size = eddsa_ph_size;
            }
        }

        #[cfg(feature = "hmac")]
        {
            let hmac_size = tpms_scheme_hash_marshalled_size();
            if hmac_size > size {
                size = hmac_size;
            }
        }

        let any_size = tpms_scheme_hash_marshalled_size();
        if any_size > size {
            size = any_size;
        }

        size
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 169, table 180, TPMT_SIG_SCHEME structure (without conditional values)
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[cfg_attr(any(feature = "hmac", all(feature = "ecc", feature = "ecdaa"), all(feature = "ecc", feature = "ecdsa"), all(feature = "ecc", feature = "ecschnorr"), all(feature = "ecc", feature = "eddsa"), all(feature = "ecc", feature = "eddsa_ph"), all(feature = "ecc", feature = "sm2"), all(feature = "rsa", feature = "rsapss"), all(feature = "rsa", feature = "rsassa")), repr(u16))]
pub enum TpmtSigScheme {
    #[cfg(all(feature = "rsa", feature = "rsassa"))]
    Rsassa(TpmsSchemeHash) = TpmAlgId::Rsassa as u16,
    #[cfg(all(feature = "rsa", feature = "rsapss"))]
    Rsapss(TpmsSchemeHash) = TpmAlgId::Rsapss as u16,
    #[cfg(all(feature = "ecc", feature = "ecdsa"))]
    Ecdsa(TpmsSchemeHash) = TpmAlgId::Ecdsa as u16,
    #[cfg(all(feature = "ecc", feature = "ecdaa"))]
    Ecdaa(TpmsSchemeEcdaa) = TpmAlgId::Ecdaa as u16,
    #[cfg(all(feature = "ecc", feature = "sm2"))]
    Sm2(TpmsSchemeHash) = TpmAlgId::Sm2 as u16,
    #[cfg(all(feature = "ecc", feature = "ecschnorr"))]
    Ecschnorr(TpmsSchemeHash) = TpmAlgId::Ecschnorr as u16,
    #[cfg(all(feature = "ecc", feature = "eddsa"))]
    Eddsa(TpmsSchemeHash) = TpmAlgId::Eddsa as u16,
    #[cfg(all(feature = "ecc", feature = "eddsa_ph"))]
    EddsaPh(TpmsSchemeHash) = TpmAlgId::EddsaPh as u16,
    #[cfg(feature = "hmac")]
    Hmac(TpmsSchemeHash) = TpmAlgId::Hmac as u16,
}

impl TpmtSigScheme {
    pub const fn marshalled_max_size() -> u16 {
        tpmt_sig_scheme_marshalled_max_size()
    }

    const fn marshalled_selector_size() -> u16 {
        TpmiAlgSigScheme::marshalled_size()
    }

    fn marshalled_data_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;
        match self {
            #[cfg(all(feature = "rsa", feature = "rsassa"))]
            Self::Rsassa(_) => {
                let details_size = match usize::try_from(tpms_scheme_hash_marshalled_size()) {
                    Ok(details_size) => details_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(details_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(all(feature = "rsa", feature = "rsapss"))]
            Self::Rsapss(_) => {
                let details_size = match usize::try_from(tpms_scheme_hash_marshalled_size()) {
                    Ok(details_size) => details_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(details_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(all(feature = "ecc", feature = "ecdsa"))]
            Self::Ecdsa(_) => {
                let details_size = match usize::try_from(tpms_scheme_hash_marshalled_size()) {
                    Ok(details_size) => details_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(details_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(all(feature = "ecc", feature = "ecdaa"))]
            Self::Ecdaa(_) => {
                let details_size = match usize::try_from(tpms_scheme_ecdaa_marshalled_size()) {
                    Ok(details_size) => details_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(details_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(all(feature = "ecc", feature = "sm2"))]
            Self::Sm2(_) => {
                let details_size = match usize::try_from(tpms_scheme_hash_marshalled_size()) {
                    Ok(details_size) => details_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(details_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(all(feature = "ecc", feature = "ecschnorr"))]
            Self::Ecschnorr(_) => {
                let details_size = match usize::try_from(tpms_scheme_hash_marshalled_size()) {
                    Ok(details_size) => details_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(details_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(all(feature = "ecc", feature = "eddsa"))]
            Self::Eddsa(_) => {
                let details_size = match usize::try_from(tpms_scheme_hash_marshalled_size()) {
                    Ok(details_size) => details_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(details_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(all(feature = "ecc", feature = "eddsa_ph"))]
            Self::EddsaPh(_) => {
                let details_size = match usize::try_from(tpms_scheme_hash_marshalled_size()) {
                    Ok(details_size) => details_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(details_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(feature = "hmac")]
            Self::Hmac(_) => {
                let details_size = match usize::try_from(tpms_scheme_hash_marshalled_size()) {
                    Ok(details_size) => details_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(details_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(not(any(feature = "hmac", all(feature = "ecc", feature = "ecdaa"), all(feature = "ecc", feature = "ecdsa"), all(feature = "ecc", feature = "ecschnorr"), all(feature = "ecc", feature = "eddsa"), all(feature = "ecc", feature = "eddsa_ph"), all(feature = "ecc", feature = "sm2"), all(feature = "rsa", feature = "rsapss"), all(feature = "rsa", feature = "rsassa"))))]
            _ => unreachable!(),
        };

        Ok(size)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let selector_size = match usize::try_from(Self::marshalled_selector_size()) {
            Ok(selector_size) => selector_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(selector_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let data_size = match self.marshalled_data_size() {
            Ok(data_size) => data_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(data_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = match self {
            #[cfg(all(feature = "rsa", feature = "rsassa"))]
            Self::Rsassa(details) => {
                let selector = TpmAlgId::Rsassa as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = details.marshal(buf)?;

                buf
            },
            #[cfg(all(feature = "rsa", feature = "rsapss"))]
            Self::Rsapss(details) => {
                let selector = TpmAlgId::Rsapss as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = details.marshal(buf)?;

                buf
            },
            #[cfg(all(feature = "ecc", feature = "ecdsa"))]
            Self::Ecdsa(details) => {
                let selector = TpmAlgId::Ecdsa as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = details.marshal(buf)?;

                buf
            },
            #[cfg(all(feature = "ecc", feature = "ecdaa"))]
            Self::Ecdaa(details) => {
                let selector = TpmAlgId::Ecdaa as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = details.marshal(buf)?;

                buf
            },
            #[cfg(all(feature = "ecc", feature = "sm2"))]
            Self::Sm2(details) => {
                let selector = TpmAlgId::Sm2 as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = details.marshal(buf)?;

                buf
            },
            #[cfg(all(feature = "ecc", feature = "ecschnorr"))]
            Self::Ecschnorr(details) => {
                let selector = TpmAlgId::Ecschnorr as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = details.marshal(buf)?;

                buf
            },
            #[cfg(all(feature = "ecc", feature = "eddsa"))]
            Self::Eddsa(details) => {
                let selector = TpmAlgId::Eddsa as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = details.marshal(buf)?;

                buf
            },
            #[cfg(all(feature = "ecc", feature = "eddsa_ph"))]
            Self::EddsaPh(details) => {
                let selector = TpmAlgId::EddsaPh as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = details.marshal(buf)?;

                buf
            },
            #[cfg(feature = "hmac")]
            Self::Hmac(details) => {
                let selector = TpmAlgId::Hmac as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = details.marshal(buf)?;

                buf
            },
            #[cfg(not(any(feature = "hmac", all(feature = "ecc", feature = "ecdaa"), all(feature = "ecc", feature = "ecdsa"), all(feature = "ecc", feature = "ecschnorr"), all(feature = "ecc", feature = "eddsa"), all(feature = "ecc", feature = "eddsa_ph"), all(feature = "ecc", feature = "sm2"), all(feature = "rsa", feature = "rsapss"), all(feature = "rsa", feature = "rsassa"))))]
            _ => unreachable!(),
        };
        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_scheme) = match unmarshal_u16(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, r) = match unmarshalled_scheme {
            #[cfg(all(feature = "rsa", feature = "rsassa"))]
            value if value == TpmAlgId::Rsassa as u16 => {
                let (buf, unmarshalled_details) = match TpmsSchemeHash::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Rsassa(unmarshalled_details))
            },
            #[cfg(all(feature = "rsa", feature = "rsapss"))]
            value if value == TpmAlgId::Rsapss as u16 => {
                let (buf, unmarshalled_details) = match TpmsSchemeHash::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Rsapss(unmarshalled_details))
            },
            #[cfg(all(feature = "ecc", feature = "ecdsa"))]
            value if value == TpmAlgId::Ecdsa as u16 => {
                let (buf, unmarshalled_details) = match TpmsSchemeHash::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Ecdsa(unmarshalled_details))
            },
            #[cfg(all(feature = "ecc", feature = "ecdaa"))]
            value if value == TpmAlgId::Ecdaa as u16 => {
                let (buf, unmarshalled_details) = match TpmsSchemeEcdaa::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Ecdaa(unmarshalled_details))
            },
            #[cfg(all(feature = "ecc", feature = "sm2"))]
            value if value == TpmAlgId::Sm2 as u16 => {
                let (buf, unmarshalled_details) = match TpmsSchemeHash::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Sm2(unmarshalled_details))
            },
            #[cfg(all(feature = "ecc", feature = "ecschnorr"))]
            value if value == TpmAlgId::Ecschnorr as u16 => {
                let (buf, unmarshalled_details) = match TpmsSchemeHash::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Ecschnorr(unmarshalled_details))
            },
            #[cfg(all(feature = "ecc", feature = "eddsa"))]
            value if value == TpmAlgId::Eddsa as u16 => {
                let (buf, unmarshalled_details) = match TpmsSchemeHash::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Eddsa(unmarshalled_details))
            },
            #[cfg(all(feature = "ecc", feature = "eddsa_ph"))]
            value if value == TpmAlgId::EddsaPh as u16 => {
                let (buf, unmarshalled_details) = match TpmsSchemeHash::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::EddsaPh(unmarshalled_details))
            },
            #[cfg(feature = "hmac")]
            value if value == TpmAlgId::Hmac as u16 => {
                let (buf, unmarshalled_details) = match TpmsSchemeHash::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Hmac(unmarshalled_details))
            },
            _ => {
                return Err(TpmErr::Rc(TpmRc::SCHEME));
            },
        };

        Ok((buf, r))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpmt_sig_scheme_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiAlgSigScheme::marshalled_size();
    size += TpmuSigScheme::marshalled_max_size();

    size
}

impl convert::From<&TpmtSigScheme> for TpmiAlgSigScheme {
    fn from(value: &TpmtSigScheme) -> Self {
        match value {
            #[cfg(all(feature = "rsa", feature = "rsassa"))]
            TpmtSigScheme::Rsassa(_) => Self::Rsassa,
            #[cfg(all(feature = "rsa", feature = "rsapss"))]
            TpmtSigScheme::Rsapss(_) => Self::Rsapss,
            #[cfg(all(feature = "ecc", feature = "ecdsa"))]
            TpmtSigScheme::Ecdsa(_) => Self::Ecdsa,
            #[cfg(all(feature = "ecc", feature = "ecdaa"))]
            TpmtSigScheme::Ecdaa(_) => Self::Ecdaa,
            #[cfg(all(feature = "ecc", feature = "sm2"))]
            TpmtSigScheme::Sm2(_) => Self::Sm2,
            #[cfg(all(feature = "ecc", feature = "ecschnorr"))]
            TpmtSigScheme::Ecschnorr(_) => Self::Ecschnorr,
            #[cfg(all(feature = "ecc", feature = "eddsa"))]
            TpmtSigScheme::Eddsa(_) => Self::Eddsa,
            #[cfg(all(feature = "ecc", feature = "eddsa_ph"))]
            TpmtSigScheme::EddsaPh(_) => Self::EddsaPh,
            #[cfg(feature = "hmac")]
            TpmtSigScheme::Hmac(_) => Self::Hmac,
            #[cfg(not(any(feature = "hmac", all(feature = "ecc", feature = "ecdaa"), all(feature = "ecc", feature = "ecdsa"), all(feature = "ecc", feature = "ecschnorr"), all(feature = "ecc", feature = "eddsa"), all(feature = "ecc", feature = "eddsa_ph"), all(feature = "ecc", feature = "sm2"), all(feature = "rsa", feature = "rsapss"), all(feature = "rsa", feature = "rsassa"))))]
            _ => unreachable!(),
        }
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 169, table 180, TPMT_SIG_SCHEME structure (with conditional values)
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u16)]
pub enum TpmtSigSchemeWCV {
    #[cfg(all(feature = "rsa", feature = "rsassa"))]
    Rsassa(TpmsSchemeHash) = TpmAlgId::Rsassa as u16,
    #[cfg(all(feature = "rsa", feature = "rsapss"))]
    Rsapss(TpmsSchemeHash) = TpmAlgId::Rsapss as u16,
    #[cfg(all(feature = "ecc", feature = "ecdsa"))]
    Ecdsa(TpmsSchemeHash) = TpmAlgId::Ecdsa as u16,
    #[cfg(all(feature = "ecc", feature = "ecdaa"))]
    Ecdaa(TpmsSchemeEcdaa) = TpmAlgId::Ecdaa as u16,
    #[cfg(all(feature = "ecc", feature = "sm2"))]
    Sm2(TpmsSchemeHash) = TpmAlgId::Sm2 as u16,
    #[cfg(all(feature = "ecc", feature = "ecschnorr"))]
    Ecschnorr(TpmsSchemeHash) = TpmAlgId::Ecschnorr as u16,
    #[cfg(all(feature = "ecc", feature = "eddsa"))]
    Eddsa(TpmsSchemeHash) = TpmAlgId::Eddsa as u16,
    #[cfg(all(feature = "ecc", feature = "eddsa_ph"))]
    EddsaPh(TpmsSchemeHash) = TpmAlgId::EddsaPh as u16,
    #[cfg(feature = "hmac")]
    Hmac(TpmsSchemeHash) = TpmAlgId::Hmac as u16,
    Null = TpmAlgId::Null as u16,
}

impl TpmtSigSchemeWCV {
    pub const fn marshalled_max_size() -> u16 {
        tpmt_sig_scheme_wcv_marshalled_max_size()
    }

    const fn marshalled_selector_size() -> u16 {
        TpmiAlgSigSchemeWCV::marshalled_size()
    }

    fn marshalled_data_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;
        match self {
            #[cfg(all(feature = "rsa", feature = "rsassa"))]
            Self::Rsassa(_) => {
                let details_size = match usize::try_from(tpms_scheme_hash_marshalled_size()) {
                    Ok(details_size) => details_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(details_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(all(feature = "rsa", feature = "rsapss"))]
            Self::Rsapss(_) => {
                let details_size = match usize::try_from(tpms_scheme_hash_marshalled_size()) {
                    Ok(details_size) => details_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(details_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(all(feature = "ecc", feature = "ecdsa"))]
            Self::Ecdsa(_) => {
                let details_size = match usize::try_from(tpms_scheme_hash_marshalled_size()) {
                    Ok(details_size) => details_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(details_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(all(feature = "ecc", feature = "ecdaa"))]
            Self::Ecdaa(_) => {
                let details_size = match usize::try_from(tpms_scheme_ecdaa_marshalled_size()) {
                    Ok(details_size) => details_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(details_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(all(feature = "ecc", feature = "sm2"))]
            Self::Sm2(_) => {
                let details_size = match usize::try_from(tpms_scheme_hash_marshalled_size()) {
                    Ok(details_size) => details_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(details_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(all(feature = "ecc", feature = "ecschnorr"))]
            Self::Ecschnorr(_) => {
                let details_size = match usize::try_from(tpms_scheme_hash_marshalled_size()) {
                    Ok(details_size) => details_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(details_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(all(feature = "ecc", feature = "eddsa"))]
            Self::Eddsa(_) => {
                let details_size = match usize::try_from(tpms_scheme_hash_marshalled_size()) {
                    Ok(details_size) => details_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(details_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(all(feature = "ecc", feature = "eddsa_ph"))]
            Self::EddsaPh(_) => {
                let details_size = match usize::try_from(tpms_scheme_hash_marshalled_size()) {
                    Ok(details_size) => details_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(details_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(feature = "hmac")]
            Self::Hmac(_) => {
                let details_size = match usize::try_from(tpms_scheme_hash_marshalled_size()) {
                    Ok(details_size) => details_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(details_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            Self::Null => (),
        };

        Ok(size)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let selector_size = match usize::try_from(Self::marshalled_selector_size()) {
            Ok(selector_size) => selector_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(selector_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let data_size = match self.marshalled_data_size() {
            Ok(data_size) => data_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(data_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = match self {
            #[cfg(all(feature = "rsa", feature = "rsassa"))]
            Self::Rsassa(details) => {
                let selector = TpmAlgId::Rsassa as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = details.marshal(buf)?;

                buf
            },
            #[cfg(all(feature = "rsa", feature = "rsapss"))]
            Self::Rsapss(details) => {
                let selector = TpmAlgId::Rsapss as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = details.marshal(buf)?;

                buf
            },
            #[cfg(all(feature = "ecc", feature = "ecdsa"))]
            Self::Ecdsa(details) => {
                let selector = TpmAlgId::Ecdsa as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = details.marshal(buf)?;

                buf
            },
            #[cfg(all(feature = "ecc", feature = "ecdaa"))]
            Self::Ecdaa(details) => {
                let selector = TpmAlgId::Ecdaa as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = details.marshal(buf)?;

                buf
            },
            #[cfg(all(feature = "ecc", feature = "sm2"))]
            Self::Sm2(details) => {
                let selector = TpmAlgId::Sm2 as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = details.marshal(buf)?;

                buf
            },
            #[cfg(all(feature = "ecc", feature = "ecschnorr"))]
            Self::Ecschnorr(details) => {
                let selector = TpmAlgId::Ecschnorr as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = details.marshal(buf)?;

                buf
            },
            #[cfg(all(feature = "ecc", feature = "eddsa"))]
            Self::Eddsa(details) => {
                let selector = TpmAlgId::Eddsa as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = details.marshal(buf)?;

                buf
            },
            #[cfg(all(feature = "ecc", feature = "eddsa_ph"))]
            Self::EddsaPh(details) => {
                let selector = TpmAlgId::EddsaPh as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = details.marshal(buf)?;

                buf
            },
            #[cfg(feature = "hmac")]
            Self::Hmac(details) => {
                let selector = TpmAlgId::Hmac as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = details.marshal(buf)?;

                buf
            },
            Self::Null => {
                let selector = TpmAlgId::Null as u16;
                let buf = marshal_u16(buf, selector)?;

                buf
            },
        };
        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_scheme) = match unmarshal_u16(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, r) = match unmarshalled_scheme {
            #[cfg(all(feature = "rsa", feature = "rsassa"))]
            value if value == TpmAlgId::Rsassa as u16 => {
                let (buf, unmarshalled_details) = match TpmsSchemeHash::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Rsassa(unmarshalled_details))
            },
            #[cfg(all(feature = "rsa", feature = "rsapss"))]
            value if value == TpmAlgId::Rsapss as u16 => {
                let (buf, unmarshalled_details) = match TpmsSchemeHash::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Rsapss(unmarshalled_details))
            },
            #[cfg(all(feature = "ecc", feature = "ecdsa"))]
            value if value == TpmAlgId::Ecdsa as u16 => {
                let (buf, unmarshalled_details) = match TpmsSchemeHash::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Ecdsa(unmarshalled_details))
            },
            #[cfg(all(feature = "ecc", feature = "ecdaa"))]
            value if value == TpmAlgId::Ecdaa as u16 => {
                let (buf, unmarshalled_details) = match TpmsSchemeEcdaa::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Ecdaa(unmarshalled_details))
            },
            #[cfg(all(feature = "ecc", feature = "sm2"))]
            value if value == TpmAlgId::Sm2 as u16 => {
                let (buf, unmarshalled_details) = match TpmsSchemeHash::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Sm2(unmarshalled_details))
            },
            #[cfg(all(feature = "ecc", feature = "ecschnorr"))]
            value if value == TpmAlgId::Ecschnorr as u16 => {
                let (buf, unmarshalled_details) = match TpmsSchemeHash::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Ecschnorr(unmarshalled_details))
            },
            #[cfg(all(feature = "ecc", feature = "eddsa"))]
            value if value == TpmAlgId::Eddsa as u16 => {
                let (buf, unmarshalled_details) = match TpmsSchemeHash::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Eddsa(unmarshalled_details))
            },
            #[cfg(all(feature = "ecc", feature = "eddsa_ph"))]
            value if value == TpmAlgId::EddsaPh as u16 => {
                let (buf, unmarshalled_details) = match TpmsSchemeHash::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::EddsaPh(unmarshalled_details))
            },
            #[cfg(feature = "hmac")]
            value if value == TpmAlgId::Hmac as u16 => {
                let (buf, unmarshalled_details) = match TpmsSchemeHash::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Hmac(unmarshalled_details))
            },
            value if value == TpmAlgId::Null as u16 => {
                (buf, Self::Null)
            },
            _ => {
                return Err(TpmErr::Rc(TpmRc::SCHEME));
            },
        };

        Ok((buf, r))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpmt_sig_scheme_wcv_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiAlgSigSchemeWCV::marshalled_size();
    size += TpmuSigScheme::marshalled_max_size();

    size
}

impl convert::From<&TpmtSigSchemeWCV> for TpmiAlgSigSchemeWCV {
    fn from(value: &TpmtSigSchemeWCV) -> Self {
        match value {
            #[cfg(all(feature = "rsa", feature = "rsassa"))]
            TpmtSigSchemeWCV::Rsassa(_) => Self::Rsassa,
            #[cfg(all(feature = "rsa", feature = "rsapss"))]
            TpmtSigSchemeWCV::Rsapss(_) => Self::Rsapss,
            #[cfg(all(feature = "ecc", feature = "ecdsa"))]
            TpmtSigSchemeWCV::Ecdsa(_) => Self::Ecdsa,
            #[cfg(all(feature = "ecc", feature = "ecdaa"))]
            TpmtSigSchemeWCV::Ecdaa(_) => Self::Ecdaa,
            #[cfg(all(feature = "ecc", feature = "sm2"))]
            TpmtSigSchemeWCV::Sm2(_) => Self::Sm2,
            #[cfg(all(feature = "ecc", feature = "ecschnorr"))]
            TpmtSigSchemeWCV::Ecschnorr(_) => Self::Ecschnorr,
            #[cfg(all(feature = "ecc", feature = "eddsa"))]
            TpmtSigSchemeWCV::Eddsa(_) => Self::Eddsa,
            #[cfg(all(feature = "ecc", feature = "eddsa_ph"))]
            TpmtSigSchemeWCV::EddsaPh(_) => Self::EddsaPh,
            #[cfg(feature = "hmac")]
            TpmtSigSchemeWCV::Hmac(_) => Self::Hmac,
            TpmtSigSchemeWCV::Null => Self::Null,
        }
    }
}

impl convert::From<TpmtSigScheme> for TpmtSigSchemeWCV {
    fn from(value: TpmtSigScheme) -> Self {
        match value {
            #[cfg(all(feature = "rsa", feature = "rsassa"))]
            TpmtSigScheme::Rsassa(details) => Self::Rsassa(details),
            #[cfg(all(feature = "rsa", feature = "rsapss"))]
            TpmtSigScheme::Rsapss(details) => Self::Rsapss(details),
            #[cfg(all(feature = "ecc", feature = "ecdsa"))]
            TpmtSigScheme::Ecdsa(details) => Self::Ecdsa(details),
            #[cfg(all(feature = "ecc", feature = "ecdaa"))]
            TpmtSigScheme::Ecdaa(details) => Self::Ecdaa(details),
            #[cfg(all(feature = "ecc", feature = "sm2"))]
            TpmtSigScheme::Sm2(details) => Self::Sm2(details),
            #[cfg(all(feature = "ecc", feature = "ecschnorr"))]
            TpmtSigScheme::Ecschnorr(details) => Self::Ecschnorr(details),
            #[cfg(all(feature = "ecc", feature = "eddsa"))]
            TpmtSigScheme::Eddsa(details) => Self::Eddsa(details),
            #[cfg(all(feature = "ecc", feature = "eddsa_ph"))]
            TpmtSigScheme::EddsaPh(details) => Self::EddsaPh(details),
            #[cfg(feature = "hmac")]
            TpmtSigScheme::Hmac(details) => Self::Hmac(details),
            #[cfg(not(any(feature = "hmac", all(feature = "ecc", feature = "ecdaa"), all(feature = "ecc", feature = "ecdsa"), all(feature = "ecc", feature = "ecschnorr"), all(feature = "ecc", feature = "eddsa"), all(feature = "ecc", feature = "eddsa_ph"), all(feature = "ecc", feature = "sm2"), all(feature = "rsa", feature = "rsapss"), all(feature = "rsa", feature = "rsassa"))))]
            _ => unreachable!(),
        }
    }
}

impl convert::TryFrom<TpmtSigSchemeWCV> for TpmtSigScheme {
    type Error = TpmErr;

    fn try_from(value: TpmtSigSchemeWCV) -> Result<Self, TpmErr> {
        let result = match value {
            #[cfg(all(feature = "rsa", feature = "rsassa"))]
            TpmtSigSchemeWCV::Rsassa(details) => Self::Rsassa(details),
            #[cfg(all(feature = "rsa", feature = "rsapss"))]
            TpmtSigSchemeWCV::Rsapss(details) => Self::Rsapss(details),
            #[cfg(all(feature = "ecc", feature = "ecdsa"))]
            TpmtSigSchemeWCV::Ecdsa(details) => Self::Ecdsa(details),
            #[cfg(all(feature = "ecc", feature = "ecdaa"))]
            TpmtSigSchemeWCV::Ecdaa(details) => Self::Ecdaa(details),
            #[cfg(all(feature = "ecc", feature = "sm2"))]
            TpmtSigSchemeWCV::Sm2(details) => Self::Sm2(details),
            #[cfg(all(feature = "ecc", feature = "ecschnorr"))]
            TpmtSigSchemeWCV::Ecschnorr(details) => Self::Ecschnorr(details),
            #[cfg(all(feature = "ecc", feature = "eddsa"))]
            TpmtSigSchemeWCV::Eddsa(details) => Self::Eddsa(details),
            #[cfg(all(feature = "ecc", feature = "eddsa_ph"))]
            TpmtSigSchemeWCV::EddsaPh(details) => Self::EddsaPh(details),
            #[cfg(feature = "hmac")]
            TpmtSigSchemeWCV::Hmac(details) => Self::Hmac(details),
            _ => {
                return Err(TpmErr::Rc(TpmRc::SCHEME));
            },
        };

        Ok(result)
    }
}

impl cmp::PartialEq<TpmtSigScheme> for TpmtSigSchemeWCV {
    fn eq(&self, other: &TpmtSigScheme) -> bool {
        match self {
            #[cfg(all(feature = "rsa", feature = "rsassa"))]
            Self::Rsassa(self_details) => {
                if let TpmtSigScheme::Rsassa(other_details) = other {
                    self_details == other_details
                } else {
                    false
                }
            },
            #[cfg(all(feature = "rsa", feature = "rsapss"))]
            Self::Rsapss(self_details) => {
                if let TpmtSigScheme::Rsapss(other_details) = other {
                    self_details == other_details
                } else {
                    false
                }
            },
            #[cfg(all(feature = "ecc", feature = "ecdsa"))]
            Self::Ecdsa(self_details) => {
                if let TpmtSigScheme::Ecdsa(other_details) = other {
                    self_details == other_details
                } else {
                    false
                }
            },
            #[cfg(all(feature = "ecc", feature = "ecdaa"))]
            Self::Ecdaa(self_details) => {
                if let TpmtSigScheme::Ecdaa(other_details) = other {
                    self_details == other_details
                } else {
                    false
                }
            },
            #[cfg(all(feature = "ecc", feature = "sm2"))]
            Self::Sm2(self_details) => {
                if let TpmtSigScheme::Sm2(other_details) = other {
                    self_details == other_details
                } else {
                    false
                }
            },
            #[cfg(all(feature = "ecc", feature = "ecschnorr"))]
            Self::Ecschnorr(self_details) => {
                if let TpmtSigScheme::Ecschnorr(other_details) = other {
                    self_details == other_details
                } else {
                    false
                }
            },
            #[cfg(all(feature = "ecc", feature = "eddsa"))]
            Self::Eddsa(self_details) => {
                if let TpmtSigScheme::Eddsa(other_details) = other {
                    self_details == other_details
                } else {
                    false
                }
            },
            #[cfg(all(feature = "ecc", feature = "eddsa_ph"))]
            Self::EddsaPh(self_details) => {
                if let TpmtSigScheme::EddsaPh(other_details) = other {
                    self_details == other_details
                } else {
                    false
                }
            },
            #[cfg(feature = "hmac")]
            Self::Hmac(self_details) => {
                if let TpmtSigScheme::Hmac(other_details) = other {
                    self_details == other_details
                } else {
                    false
                }
            },
            _ => false,
        }
    }
}

impl cmp::PartialEq<TpmtSigSchemeWCV> for TpmtSigScheme {
    fn eq(&self, other: &TpmtSigSchemeWCV) -> bool {
        other.eq(self)
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 171, table 184, TPMU_KDF_SCHEME union
struct TpmuKdfScheme {}

impl TpmuKdfScheme {
    const fn marshalled_max_size() -> u16 {
        let mut size: u16 = 0;

        #[cfg(feature = "mgf1")]
        {
            let mgf1_size = tpms_scheme_hash_marshalled_size();
            if mgf1_size > size {
                size = mgf1_size;
            }
        }

        #[cfg(all(feature = "ecc", feature = "kdf1_sp800_56a"))]
        {
            let kdf1_sp800_56_a_size = tpms_scheme_hash_marshalled_size();
            if kdf1_sp800_56_a_size > size {
                size = kdf1_sp800_56_a_size;
            }
        }

        #[cfg(feature = "kdf2")]
        {
            let kdf2_size = tpms_scheme_hash_marshalled_size();
            if kdf2_size > size {
                size = kdf2_size;
            }
        }

        #[cfg(feature = "kdf1_sp800_108")]
        {
            let kdf1_sp800_108_size = tpms_scheme_hash_marshalled_size();
            if kdf1_sp800_108_size > size {
                size = kdf1_sp800_108_size;
            }
        }

        let any_kdf_size = tpms_scheme_hash_marshalled_size();
        if any_kdf_size > size {
            size = any_kdf_size;
        }

        size
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 171, table 185, TPMT_KDF_SCHEME structure (without conditional values)
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[cfg_attr(any(feature = "kdf1_sp800_108", feature = "kdf2", feature = "mgf1", all(feature = "ecc", feature = "kdf1_sp800_56a")), repr(u16))]
pub enum TpmtKdfScheme {
    #[cfg(feature = "mgf1")]
    Mgf1(TpmsSchemeHash) = TpmAlgId::Mgf1 as u16,
    #[cfg(all(feature = "ecc", feature = "kdf1_sp800_56a"))]
    Kdf1Sp800_56a(TpmsSchemeHash) = TpmAlgId::Kdf1Sp800_56a as u16,
    #[cfg(feature = "kdf2")]
    Kdf2(TpmsSchemeHash) = TpmAlgId::Kdf2 as u16,
    #[cfg(feature = "kdf1_sp800_108")]
    Kdf1Sp800_108(TpmsSchemeHash) = TpmAlgId::Kdf1Sp800_108 as u16,
}

impl TpmtKdfScheme {
    pub const fn marshalled_max_size() -> u16 {
        tpmt_kdf_scheme_marshalled_max_size()
    }

    const fn marshalled_selector_size() -> u16 {
        TpmiAlgKdf::marshalled_size()
    }

    fn marshalled_data_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;
        match self {
            #[cfg(feature = "mgf1")]
            Self::Mgf1(_) => {
                let details_size = match usize::try_from(tpms_scheme_hash_marshalled_size()) {
                    Ok(details_size) => details_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(details_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(all(feature = "ecc", feature = "kdf1_sp800_56a"))]
            Self::Kdf1Sp800_56a(_) => {
                let details_size = match usize::try_from(tpms_scheme_hash_marshalled_size()) {
                    Ok(details_size) => details_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(details_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(feature = "kdf2")]
            Self::Kdf2(_) => {
                let details_size = match usize::try_from(tpms_scheme_hash_marshalled_size()) {
                    Ok(details_size) => details_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(details_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(feature = "kdf1_sp800_108")]
            Self::Kdf1Sp800_108(_) => {
                let details_size = match usize::try_from(tpms_scheme_hash_marshalled_size()) {
                    Ok(details_size) => details_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(details_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(not(any(feature = "kdf1_sp800_108", feature = "kdf2", feature = "mgf1", all(feature = "ecc", feature = "kdf1_sp800_56a"))))]
            _ => unreachable!(),
        };

        Ok(size)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let selector_size = match usize::try_from(Self::marshalled_selector_size()) {
            Ok(selector_size) => selector_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(selector_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let data_size = match self.marshalled_data_size() {
            Ok(data_size) => data_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(data_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = match self {
            #[cfg(feature = "mgf1")]
            Self::Mgf1(details) => {
                let selector = TpmAlgId::Mgf1 as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = details.marshal(buf)?;

                buf
            },
            #[cfg(all(feature = "ecc", feature = "kdf1_sp800_56a"))]
            Self::Kdf1Sp800_56a(details) => {
                let selector = TpmAlgId::Kdf1Sp800_56a as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = details.marshal(buf)?;

                buf
            },
            #[cfg(feature = "kdf2")]
            Self::Kdf2(details) => {
                let selector = TpmAlgId::Kdf2 as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = details.marshal(buf)?;

                buf
            },
            #[cfg(feature = "kdf1_sp800_108")]
            Self::Kdf1Sp800_108(details) => {
                let selector = TpmAlgId::Kdf1Sp800_108 as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = details.marshal(buf)?;

                buf
            },
            #[cfg(not(any(feature = "kdf1_sp800_108", feature = "kdf2", feature = "mgf1", all(feature = "ecc", feature = "kdf1_sp800_56a"))))]
            _ => unreachable!(),
        };
        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_scheme) = match unmarshal_u16(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, r) = match unmarshalled_scheme {
            #[cfg(feature = "mgf1")]
            value if value == TpmAlgId::Mgf1 as u16 => {
                let (buf, unmarshalled_details) = match TpmsSchemeHash::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Mgf1(unmarshalled_details))
            },
            #[cfg(all(feature = "ecc", feature = "kdf1_sp800_56a"))]
            value if value == TpmAlgId::Kdf1Sp800_56a as u16 => {
                let (buf, unmarshalled_details) = match TpmsSchemeHash::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Kdf1Sp800_56a(unmarshalled_details))
            },
            #[cfg(feature = "kdf2")]
            value if value == TpmAlgId::Kdf2 as u16 => {
                let (buf, unmarshalled_details) = match TpmsSchemeHash::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Kdf2(unmarshalled_details))
            },
            #[cfg(feature = "kdf1_sp800_108")]
            value if value == TpmAlgId::Kdf1Sp800_108 as u16 => {
                let (buf, unmarshalled_details) = match TpmsSchemeHash::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Kdf1Sp800_108(unmarshalled_details))
            },
            _ => {
                return Err(TpmErr::Rc(TpmRc::KDF));
            },
        };

        Ok((buf, r))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpmt_kdf_scheme_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiAlgKdf::marshalled_size();
    size += TpmuKdfScheme::marshalled_max_size();

    size
}

impl convert::From<&TpmtKdfScheme> for TpmiAlgKdf {
    fn from(value: &TpmtKdfScheme) -> Self {
        match value {
            #[cfg(feature = "mgf1")]
            TpmtKdfScheme::Mgf1(_) => Self::Mgf1,
            #[cfg(all(feature = "ecc", feature = "kdf1_sp800_56a"))]
            TpmtKdfScheme::Kdf1Sp800_56a(_) => Self::Kdf1Sp800_56a,
            #[cfg(feature = "kdf2")]
            TpmtKdfScheme::Kdf2(_) => Self::Kdf2,
            #[cfg(feature = "kdf1_sp800_108")]
            TpmtKdfScheme::Kdf1Sp800_108(_) => Self::Kdf1Sp800_108,
            #[cfg(not(any(feature = "kdf1_sp800_108", feature = "kdf2", feature = "mgf1", all(feature = "ecc", feature = "kdf1_sp800_56a"))))]
            _ => unreachable!(),
        }
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 171, table 185, TPMT_KDF_SCHEME structure (with conditional values)
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u16)]
pub enum TpmtKdfSchemeWCV {
    #[cfg(feature = "mgf1")]
    Mgf1(TpmsSchemeHash) = TpmAlgId::Mgf1 as u16,
    #[cfg(all(feature = "ecc", feature = "kdf1_sp800_56a"))]
    Kdf1Sp800_56a(TpmsSchemeHash) = TpmAlgId::Kdf1Sp800_56a as u16,
    #[cfg(feature = "kdf2")]
    Kdf2(TpmsSchemeHash) = TpmAlgId::Kdf2 as u16,
    #[cfg(feature = "kdf1_sp800_108")]
    Kdf1Sp800_108(TpmsSchemeHash) = TpmAlgId::Kdf1Sp800_108 as u16,
    Null = TpmAlgId::Null as u16,
}

impl TpmtKdfSchemeWCV {
    pub const fn marshalled_max_size() -> u16 {
        tpmt_kdf_scheme_wcv_marshalled_max_size()
    }

    const fn marshalled_selector_size() -> u16 {
        TpmiAlgKdfWCV::marshalled_size()
    }

    fn marshalled_data_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;
        match self {
            #[cfg(feature = "mgf1")]
            Self::Mgf1(_) => {
                let details_size = match usize::try_from(tpms_scheme_hash_marshalled_size()) {
                    Ok(details_size) => details_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(details_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(all(feature = "ecc", feature = "kdf1_sp800_56a"))]
            Self::Kdf1Sp800_56a(_) => {
                let details_size = match usize::try_from(tpms_scheme_hash_marshalled_size()) {
                    Ok(details_size) => details_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(details_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(feature = "kdf2")]
            Self::Kdf2(_) => {
                let details_size = match usize::try_from(tpms_scheme_hash_marshalled_size()) {
                    Ok(details_size) => details_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(details_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(feature = "kdf1_sp800_108")]
            Self::Kdf1Sp800_108(_) => {
                let details_size = match usize::try_from(tpms_scheme_hash_marshalled_size()) {
                    Ok(details_size) => details_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(details_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            Self::Null => (),
        };

        Ok(size)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let selector_size = match usize::try_from(Self::marshalled_selector_size()) {
            Ok(selector_size) => selector_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(selector_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let data_size = match self.marshalled_data_size() {
            Ok(data_size) => data_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(data_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = match self {
            #[cfg(feature = "mgf1")]
            Self::Mgf1(details) => {
                let selector = TpmAlgId::Mgf1 as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = details.marshal(buf)?;

                buf
            },
            #[cfg(all(feature = "ecc", feature = "kdf1_sp800_56a"))]
            Self::Kdf1Sp800_56a(details) => {
                let selector = TpmAlgId::Kdf1Sp800_56a as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = details.marshal(buf)?;

                buf
            },
            #[cfg(feature = "kdf2")]
            Self::Kdf2(details) => {
                let selector = TpmAlgId::Kdf2 as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = details.marshal(buf)?;

                buf
            },
            #[cfg(feature = "kdf1_sp800_108")]
            Self::Kdf1Sp800_108(details) => {
                let selector = TpmAlgId::Kdf1Sp800_108 as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = details.marshal(buf)?;

                buf
            },
            Self::Null => {
                let selector = TpmAlgId::Null as u16;
                let buf = marshal_u16(buf, selector)?;

                buf
            },
        };
        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_scheme) = match unmarshal_u16(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, r) = match unmarshalled_scheme {
            #[cfg(feature = "mgf1")]
            value if value == TpmAlgId::Mgf1 as u16 => {
                let (buf, unmarshalled_details) = match TpmsSchemeHash::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Mgf1(unmarshalled_details))
            },
            #[cfg(all(feature = "ecc", feature = "kdf1_sp800_56a"))]
            value if value == TpmAlgId::Kdf1Sp800_56a as u16 => {
                let (buf, unmarshalled_details) = match TpmsSchemeHash::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Kdf1Sp800_56a(unmarshalled_details))
            },
            #[cfg(feature = "kdf2")]
            value if value == TpmAlgId::Kdf2 as u16 => {
                let (buf, unmarshalled_details) = match TpmsSchemeHash::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Kdf2(unmarshalled_details))
            },
            #[cfg(feature = "kdf1_sp800_108")]
            value if value == TpmAlgId::Kdf1Sp800_108 as u16 => {
                let (buf, unmarshalled_details) = match TpmsSchemeHash::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Kdf1Sp800_108(unmarshalled_details))
            },
            value if value == TpmAlgId::Null as u16 => {
                (buf, Self::Null)
            },
            _ => {
                return Err(TpmErr::Rc(TpmRc::KDF));
            },
        };

        Ok((buf, r))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpmt_kdf_scheme_wcv_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiAlgKdfWCV::marshalled_size();
    size += TpmuKdfScheme::marshalled_max_size();

    size
}

impl convert::From<&TpmtKdfSchemeWCV> for TpmiAlgKdfWCV {
    fn from(value: &TpmtKdfSchemeWCV) -> Self {
        match value {
            #[cfg(feature = "mgf1")]
            TpmtKdfSchemeWCV::Mgf1(_) => Self::Mgf1,
            #[cfg(all(feature = "ecc", feature = "kdf1_sp800_56a"))]
            TpmtKdfSchemeWCV::Kdf1Sp800_56a(_) => Self::Kdf1Sp800_56a,
            #[cfg(feature = "kdf2")]
            TpmtKdfSchemeWCV::Kdf2(_) => Self::Kdf2,
            #[cfg(feature = "kdf1_sp800_108")]
            TpmtKdfSchemeWCV::Kdf1Sp800_108(_) => Self::Kdf1Sp800_108,
            TpmtKdfSchemeWCV::Null => Self::Null,
        }
    }
}

impl convert::From<TpmtKdfScheme> for TpmtKdfSchemeWCV {
    fn from(value: TpmtKdfScheme) -> Self {
        match value {
            #[cfg(feature = "mgf1")]
            TpmtKdfScheme::Mgf1(details) => Self::Mgf1(details),
            #[cfg(all(feature = "ecc", feature = "kdf1_sp800_56a"))]
            TpmtKdfScheme::Kdf1Sp800_56a(details) => Self::Kdf1Sp800_56a(details),
            #[cfg(feature = "kdf2")]
            TpmtKdfScheme::Kdf2(details) => Self::Kdf2(details),
            #[cfg(feature = "kdf1_sp800_108")]
            TpmtKdfScheme::Kdf1Sp800_108(details) => Self::Kdf1Sp800_108(details),
            #[cfg(not(any(feature = "kdf1_sp800_108", feature = "kdf2", feature = "mgf1", all(feature = "ecc", feature = "kdf1_sp800_56a"))))]
            _ => unreachable!(),
        }
    }
}

impl convert::TryFrom<TpmtKdfSchemeWCV> for TpmtKdfScheme {
    type Error = TpmErr;

    fn try_from(value: TpmtKdfSchemeWCV) -> Result<Self, TpmErr> {
        let result = match value {
            #[cfg(feature = "mgf1")]
            TpmtKdfSchemeWCV::Mgf1(details) => Self::Mgf1(details),
            #[cfg(all(feature = "ecc", feature = "kdf1_sp800_56a"))]
            TpmtKdfSchemeWCV::Kdf1Sp800_56a(details) => Self::Kdf1Sp800_56a(details),
            #[cfg(feature = "kdf2")]
            TpmtKdfSchemeWCV::Kdf2(details) => Self::Kdf2(details),
            #[cfg(feature = "kdf1_sp800_108")]
            TpmtKdfSchemeWCV::Kdf1Sp800_108(details) => Self::Kdf1Sp800_108(details),
            _ => {
                return Err(TpmErr::Rc(TpmRc::KDF));
            },
        };

        Ok(result)
    }
}

impl cmp::PartialEq<TpmtKdfScheme> for TpmtKdfSchemeWCV {
    fn eq(&self, other: &TpmtKdfScheme) -> bool {
        match self {
            #[cfg(feature = "mgf1")]
            Self::Mgf1(self_details) => {
                if let TpmtKdfScheme::Mgf1(other_details) = other {
                    self_details == other_details
                } else {
                    false
                }
            },
            #[cfg(all(feature = "ecc", feature = "kdf1_sp800_56a"))]
            Self::Kdf1Sp800_56a(self_details) => {
                if let TpmtKdfScheme::Kdf1Sp800_56a(other_details) = other {
                    self_details == other_details
                } else {
                    false
                }
            },
            #[cfg(feature = "kdf2")]
            Self::Kdf2(self_details) => {
                if let TpmtKdfScheme::Kdf2(other_details) = other {
                    self_details == other_details
                } else {
                    false
                }
            },
            #[cfg(feature = "kdf1_sp800_108")]
            Self::Kdf1Sp800_108(self_details) => {
                if let TpmtKdfScheme::Kdf1Sp800_108(other_details) = other {
                    self_details == other_details
                } else {
                    false
                }
            },
            _ => false,
        }
    }
}

impl cmp::PartialEq<TpmtKdfSchemeWCV> for TpmtKdfScheme {
    fn eq(&self, other: &TpmtKdfSchemeWCV) -> bool {
        other.eq(self)
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 171, table 186, TPMI_ALG_ASYM_SCHEME type (without conditional values)
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[cfg_attr(any(all(feature = "ecc", feature = "ecdaa"), all(feature = "ecc", feature = "ecdh"), all(feature = "ecc", feature = "ecdsa"), all(feature = "ecc", feature = "ecmqv"), all(feature = "ecc", feature = "ecschnorr"), all(feature = "ecc", feature = "eddsa"), all(feature = "ecc", feature = "eddsa_ph"), all(feature = "ecc", feature = "sm2"), all(feature = "oaep", feature = "rsa"), all(feature = "rsa", feature = "rsaes"), all(feature = "rsa", feature = "rsapss"), all(feature = "rsa", feature = "rsassa")), repr(u16))]
pub enum TpmiAlgAsymScheme {
    #[cfg(all(feature = "ecc", feature = "ecdh"))]
    Ecdh = TpmAlgId::Ecdh as u16,
    #[cfg(all(feature = "ecc", feature = "ecmqv"))]
    Ecmqv = TpmAlgId::Ecmqv as u16,
    #[cfg(all(feature = "rsa", feature = "rsassa"))]
    Rsassa = TpmAlgId::Rsassa as u16,
    #[cfg(all(feature = "rsa", feature = "rsapss"))]
    Rsapss = TpmAlgId::Rsapss as u16,
    #[cfg(all(feature = "ecc", feature = "ecdsa"))]
    Ecdsa = TpmAlgId::Ecdsa as u16,
    #[cfg(all(feature = "ecc", feature = "ecdaa"))]
    Ecdaa = TpmAlgId::Ecdaa as u16,
    #[cfg(all(feature = "ecc", feature = "sm2"))]
    Sm2 = TpmAlgId::Sm2 as u16,
    #[cfg(all(feature = "ecc", feature = "ecschnorr"))]
    Ecschnorr = TpmAlgId::Ecschnorr as u16,
    #[cfg(all(feature = "ecc", feature = "eddsa"))]
    Eddsa = TpmAlgId::Eddsa as u16,
    #[cfg(all(feature = "ecc", feature = "eddsa_ph"))]
    EddsaPh = TpmAlgId::EddsaPh as u16,
    #[cfg(all(feature = "rsa", feature = "rsaes"))]
    Rsaes = TpmAlgId::Rsaes as u16,
    #[cfg(all(feature = "oaep", feature = "rsa"))]
    Oaep = TpmAlgId::Oaep as u16,
}

impl TpmiAlgAsymScheme {
    pub const fn marshalled_size() -> u16 {
        mem::size_of::<u16>() as u16
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u16(buf, *self as u16)
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u16(buf)?;
        let result = Self::try_from(value)?;
        Ok((buf, result))
    }
}

impl convert::TryFrom<u16> for TpmiAlgAsymScheme {
    type Error = TpmErr;

    fn try_from(value: u16) -> Result<Self, TpmErr> {
        let result = match value {
            #[cfg(all(feature = "ecc", feature = "ecdh"))]
            value if value == Self::Ecdh as u16 => Self::Ecdh,
            #[cfg(all(feature = "ecc", feature = "ecmqv"))]
            value if value == Self::Ecmqv as u16 => Self::Ecmqv,
            #[cfg(all(feature = "rsa", feature = "rsassa"))]
            value if value == Self::Rsassa as u16 => Self::Rsassa,
            #[cfg(all(feature = "rsa", feature = "rsapss"))]
            value if value == Self::Rsapss as u16 => Self::Rsapss,
            #[cfg(all(feature = "ecc", feature = "ecdsa"))]
            value if value == Self::Ecdsa as u16 => Self::Ecdsa,
            #[cfg(all(feature = "ecc", feature = "ecdaa"))]
            value if value == Self::Ecdaa as u16 => Self::Ecdaa,
            #[cfg(all(feature = "ecc", feature = "sm2"))]
            value if value == Self::Sm2 as u16 => Self::Sm2,
            #[cfg(all(feature = "ecc", feature = "ecschnorr"))]
            value if value == Self::Ecschnorr as u16 => Self::Ecschnorr,
            #[cfg(all(feature = "ecc", feature = "eddsa"))]
            value if value == Self::Eddsa as u16 => Self::Eddsa,
            #[cfg(all(feature = "ecc", feature = "eddsa_ph"))]
            value if value == Self::EddsaPh as u16 => Self::EddsaPh,
            #[cfg(all(feature = "rsa", feature = "rsaes"))]
            value if value == Self::Rsaes as u16 => Self::Rsaes,
            #[cfg(all(feature = "oaep", feature = "rsa"))]
            value if value == Self::Oaep as u16 => Self::Oaep,
            _ => {
                return Err(TpmErr::Rc(TpmRc::VALUE));
            },
        };

        Ok(result)
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 171, table 186, TPMI_ALG_ASYM_SCHEME type (with conditional values)
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u16)]
pub enum TpmiAlgAsymSchemeWCV {
    #[cfg(all(feature = "ecc", feature = "ecdh"))]
    Ecdh = TpmAlgId::Ecdh as u16,
    #[cfg(all(feature = "ecc", feature = "ecmqv"))]
    Ecmqv = TpmAlgId::Ecmqv as u16,
    #[cfg(all(feature = "rsa", feature = "rsassa"))]
    Rsassa = TpmAlgId::Rsassa as u16,
    #[cfg(all(feature = "rsa", feature = "rsapss"))]
    Rsapss = TpmAlgId::Rsapss as u16,
    #[cfg(all(feature = "ecc", feature = "ecdsa"))]
    Ecdsa = TpmAlgId::Ecdsa as u16,
    #[cfg(all(feature = "ecc", feature = "ecdaa"))]
    Ecdaa = TpmAlgId::Ecdaa as u16,
    #[cfg(all(feature = "ecc", feature = "sm2"))]
    Sm2 = TpmAlgId::Sm2 as u16,
    #[cfg(all(feature = "ecc", feature = "ecschnorr"))]
    Ecschnorr = TpmAlgId::Ecschnorr as u16,
    #[cfg(all(feature = "ecc", feature = "eddsa"))]
    Eddsa = TpmAlgId::Eddsa as u16,
    #[cfg(all(feature = "ecc", feature = "eddsa_ph"))]
    EddsaPh = TpmAlgId::EddsaPh as u16,
    #[cfg(all(feature = "rsa", feature = "rsaes"))]
    Rsaes = TpmAlgId::Rsaes as u16,
    #[cfg(all(feature = "oaep", feature = "rsa"))]
    Oaep = TpmAlgId::Oaep as u16,
    Null = TpmAlgId::Null as u16,
}

impl TpmiAlgAsymSchemeWCV {
    pub const fn marshalled_size() -> u16 {
        mem::size_of::<u16>() as u16
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u16(buf, *self as u16)
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u16(buf)?;
        let result = Self::try_from(value)?;
        Ok((buf, result))
    }
}

impl convert::TryFrom<u16> for TpmiAlgAsymSchemeWCV {
    type Error = TpmErr;

    fn try_from(value: u16) -> Result<Self, TpmErr> {
        let result = match value {
            #[cfg(all(feature = "ecc", feature = "ecdh"))]
            value if value == Self::Ecdh as u16 => Self::Ecdh,
            #[cfg(all(feature = "ecc", feature = "ecmqv"))]
            value if value == Self::Ecmqv as u16 => Self::Ecmqv,
            #[cfg(all(feature = "rsa", feature = "rsassa"))]
            value if value == Self::Rsassa as u16 => Self::Rsassa,
            #[cfg(all(feature = "rsa", feature = "rsapss"))]
            value if value == Self::Rsapss as u16 => Self::Rsapss,
            #[cfg(all(feature = "ecc", feature = "ecdsa"))]
            value if value == Self::Ecdsa as u16 => Self::Ecdsa,
            #[cfg(all(feature = "ecc", feature = "ecdaa"))]
            value if value == Self::Ecdaa as u16 => Self::Ecdaa,
            #[cfg(all(feature = "ecc", feature = "sm2"))]
            value if value == Self::Sm2 as u16 => Self::Sm2,
            #[cfg(all(feature = "ecc", feature = "ecschnorr"))]
            value if value == Self::Ecschnorr as u16 => Self::Ecschnorr,
            #[cfg(all(feature = "ecc", feature = "eddsa"))]
            value if value == Self::Eddsa as u16 => Self::Eddsa,
            #[cfg(all(feature = "ecc", feature = "eddsa_ph"))]
            value if value == Self::EddsaPh as u16 => Self::EddsaPh,
            #[cfg(all(feature = "rsa", feature = "rsaes"))]
            value if value == Self::Rsaes as u16 => Self::Rsaes,
            #[cfg(all(feature = "oaep", feature = "rsa"))]
            value if value == Self::Oaep as u16 => Self::Oaep,
            value if value == Self::Null as u16 => Self::Null,
            _ => {
                return Err(TpmErr::Rc(TpmRc::VALUE));
            },
        };

        Ok(result)
    }
}

impl convert::From<TpmiAlgAsymScheme> for TpmiAlgAsymSchemeWCV {
    fn from(value: TpmiAlgAsymScheme) -> Self {
        match value {
            #[cfg(all(feature = "ecc", feature = "ecdh"))]
            TpmiAlgAsymScheme::Ecdh => Self::Ecdh,
            #[cfg(all(feature = "ecc", feature = "ecmqv"))]
            TpmiAlgAsymScheme::Ecmqv => Self::Ecmqv,
            #[cfg(all(feature = "rsa", feature = "rsassa"))]
            TpmiAlgAsymScheme::Rsassa => Self::Rsassa,
            #[cfg(all(feature = "rsa", feature = "rsapss"))]
            TpmiAlgAsymScheme::Rsapss => Self::Rsapss,
            #[cfg(all(feature = "ecc", feature = "ecdsa"))]
            TpmiAlgAsymScheme::Ecdsa => Self::Ecdsa,
            #[cfg(all(feature = "ecc", feature = "ecdaa"))]
            TpmiAlgAsymScheme::Ecdaa => Self::Ecdaa,
            #[cfg(all(feature = "ecc", feature = "sm2"))]
            TpmiAlgAsymScheme::Sm2 => Self::Sm2,
            #[cfg(all(feature = "ecc", feature = "ecschnorr"))]
            TpmiAlgAsymScheme::Ecschnorr => Self::Ecschnorr,
            #[cfg(all(feature = "ecc", feature = "eddsa"))]
            TpmiAlgAsymScheme::Eddsa => Self::Eddsa,
            #[cfg(all(feature = "ecc", feature = "eddsa_ph"))]
            TpmiAlgAsymScheme::EddsaPh => Self::EddsaPh,
            #[cfg(all(feature = "rsa", feature = "rsaes"))]
            TpmiAlgAsymScheme::Rsaes => Self::Rsaes,
            #[cfg(all(feature = "oaep", feature = "rsa"))]
            TpmiAlgAsymScheme::Oaep => Self::Oaep,
        }
    }
}

impl convert::TryFrom<TpmiAlgAsymSchemeWCV> for TpmiAlgAsymScheme {
    type Error = TpmErr;

    fn try_from(value: TpmiAlgAsymSchemeWCV) -> Result<Self, TpmErr> {
        let result = match value {
            #[cfg(all(feature = "ecc", feature = "ecdh"))]
            TpmiAlgAsymSchemeWCV::Ecdh => Self::Ecdh,
            #[cfg(all(feature = "ecc", feature = "ecmqv"))]
            TpmiAlgAsymSchemeWCV::Ecmqv => Self::Ecmqv,
            #[cfg(all(feature = "rsa", feature = "rsassa"))]
            TpmiAlgAsymSchemeWCV::Rsassa => Self::Rsassa,
            #[cfg(all(feature = "rsa", feature = "rsapss"))]
            TpmiAlgAsymSchemeWCV::Rsapss => Self::Rsapss,
            #[cfg(all(feature = "ecc", feature = "ecdsa"))]
            TpmiAlgAsymSchemeWCV::Ecdsa => Self::Ecdsa,
            #[cfg(all(feature = "ecc", feature = "ecdaa"))]
            TpmiAlgAsymSchemeWCV::Ecdaa => Self::Ecdaa,
            #[cfg(all(feature = "ecc", feature = "sm2"))]
            TpmiAlgAsymSchemeWCV::Sm2 => Self::Sm2,
            #[cfg(all(feature = "ecc", feature = "ecschnorr"))]
            TpmiAlgAsymSchemeWCV::Ecschnorr => Self::Ecschnorr,
            #[cfg(all(feature = "ecc", feature = "eddsa"))]
            TpmiAlgAsymSchemeWCV::Eddsa => Self::Eddsa,
            #[cfg(all(feature = "ecc", feature = "eddsa_ph"))]
            TpmiAlgAsymSchemeWCV::EddsaPh => Self::EddsaPh,
            #[cfg(all(feature = "rsa", feature = "rsaes"))]
            TpmiAlgAsymSchemeWCV::Rsaes => Self::Rsaes,
            #[cfg(all(feature = "oaep", feature = "rsa"))]
            TpmiAlgAsymSchemeWCV::Oaep => Self::Oaep,
            TpmiAlgAsymSchemeWCV::Null => {
                return Err(TpmErr::Rc(TpmRc::VALUE));
            },
        };
        Ok(result)
    }
}

impl cmp::PartialEq<TpmiAlgAsymScheme> for TpmiAlgAsymSchemeWCV {
    fn eq(&self, other: &TpmiAlgAsymScheme) -> bool {
        *self as u16 == *other as u16
    }
}

impl cmp::PartialEq<TpmiAlgAsymSchemeWCV> for TpmiAlgAsymScheme {
    fn eq(&self, other: &TpmiAlgAsymSchemeWCV) -> bool {
        other.eq(self)
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 172, table 187, TPMU_ASYM_SCHEME union
struct TpmuAsymScheme {}

impl TpmuAsymScheme {
    const fn marshalled_max_size() -> u16 {
        let mut size: u16 = 0;

        #[cfg(all(feature = "ecc", feature = "ecdh"))]
        {
            let ecdh_size = tpms_scheme_hash_marshalled_size();
            if ecdh_size > size {
                size = ecdh_size;
            }
        }

        #[cfg(all(feature = "ecc", feature = "ecmqv"))]
        {
            let ecmqv_size = tpms_scheme_hash_marshalled_size();
            if ecmqv_size > size {
                size = ecmqv_size;
            }
        }

        #[cfg(all(feature = "rsa", feature = "rsassa"))]
        {
            let rsassa_size = tpms_scheme_hash_marshalled_size();
            if rsassa_size > size {
                size = rsassa_size;
            }
        }

        #[cfg(all(feature = "rsa", feature = "rsapss"))]
        {
            let rsapss_size = tpms_scheme_hash_marshalled_size();
            if rsapss_size > size {
                size = rsapss_size;
            }
        }

        #[cfg(all(feature = "ecc", feature = "ecdsa"))]
        {
            let ecdsa_size = tpms_scheme_hash_marshalled_size();
            if ecdsa_size > size {
                size = ecdsa_size;
            }
        }

        #[cfg(all(feature = "ecc", feature = "ecdaa"))]
        {
            let ecdaa_size = tpms_scheme_ecdaa_marshalled_size();
            if ecdaa_size > size {
                size = ecdaa_size;
            }
        }

        #[cfg(all(feature = "ecc", feature = "sm2"))]
        {
            let sm2_size = tpms_scheme_hash_marshalled_size();
            if sm2_size > size {
                size = sm2_size;
            }
        }

        #[cfg(all(feature = "ecc", feature = "ecschnorr"))]
        {
            let ecschnorr_size = tpms_scheme_hash_marshalled_size();
            if ecschnorr_size > size {
                size = ecschnorr_size;
            }
        }

        #[cfg(all(feature = "ecc", feature = "eddsa"))]
        {
            let eddsa_size = tpms_scheme_hash_marshalled_size();
            if eddsa_size > size {
                size = eddsa_size;
            }
        }

        #[cfg(all(feature = "ecc", feature = "eddsa_ph"))]
        {
            let eddsa_ph_size = tpms_scheme_hash_marshalled_size();
            if eddsa_ph_size > size {
                size = eddsa_ph_size;
            }
        }

        #[cfg(all(feature = "rsa", feature = "rsaes"))]
        {
            let rsaes_size = tpms_empty_marshalled_size();
            if rsaes_size > size {
                size = rsaes_size;
            }
        }

        #[cfg(all(feature = "oaep", feature = "rsa"))]
        {
            let oaep_size = tpms_empty_marshalled_size();
            if oaep_size > size {
                size = oaep_size;
            }
        }

        let any_sig_size = tpms_scheme_hash_marshalled_size();
        if any_sig_size > size {
            size = any_sig_size;
        }

        size
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 172, table 188, TPMT_ASYM_SCHEME structure (without conditional values)
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[cfg_attr(any(all(feature = "ecc", feature = "ecdaa"), all(feature = "ecc", feature = "ecdh"), all(feature = "ecc", feature = "ecdsa"), all(feature = "ecc", feature = "ecmqv"), all(feature = "ecc", feature = "ecschnorr"), all(feature = "ecc", feature = "eddsa"), all(feature = "ecc", feature = "eddsa_ph"), all(feature = "ecc", feature = "sm2"), all(feature = "oaep", feature = "rsa"), all(feature = "rsa", feature = "rsaes"), all(feature = "rsa", feature = "rsapss"), all(feature = "rsa", feature = "rsassa")), repr(u16))]
pub enum TpmtAsymScheme {
    #[cfg(all(feature = "ecc", feature = "ecdh"))]
    Ecdh(TpmsSchemeHash) = TpmAlgId::Ecdh as u16,
    #[cfg(all(feature = "ecc", feature = "ecmqv"))]
    Ecmqv(TpmsSchemeHash) = TpmAlgId::Ecmqv as u16,
    #[cfg(all(feature = "rsa", feature = "rsassa"))]
    Rsassa(TpmsSchemeHash) = TpmAlgId::Rsassa as u16,
    #[cfg(all(feature = "rsa", feature = "rsapss"))]
    Rsapss(TpmsSchemeHash) = TpmAlgId::Rsapss as u16,
    #[cfg(all(feature = "ecc", feature = "ecdsa"))]
    Ecdsa(TpmsSchemeHash) = TpmAlgId::Ecdsa as u16,
    #[cfg(all(feature = "ecc", feature = "ecdaa"))]
    Ecdaa(TpmsSchemeEcdaa) = TpmAlgId::Ecdaa as u16,
    #[cfg(all(feature = "ecc", feature = "sm2"))]
    Sm2(TpmsSchemeHash) = TpmAlgId::Sm2 as u16,
    #[cfg(all(feature = "ecc", feature = "ecschnorr"))]
    Ecschnorr(TpmsSchemeHash) = TpmAlgId::Ecschnorr as u16,
    #[cfg(all(feature = "ecc", feature = "eddsa"))]
    Eddsa(TpmsSchemeHash) = TpmAlgId::Eddsa as u16,
    #[cfg(all(feature = "ecc", feature = "eddsa_ph"))]
    EddsaPh(TpmsSchemeHash) = TpmAlgId::EddsaPh as u16,
    #[cfg(all(feature = "rsa", feature = "rsaes"))]
    Rsaes(TpmsEmpty) = TpmAlgId::Rsaes as u16,
    #[cfg(all(feature = "oaep", feature = "rsa"))]
    Oaep(TpmsEmpty) = TpmAlgId::Oaep as u16,
}

impl TpmtAsymScheme {
    pub const fn marshalled_max_size() -> u16 {
        tpmt_asym_scheme_marshalled_max_size()
    }

    const fn marshalled_selector_size() -> u16 {
        TpmiAlgAsymScheme::marshalled_size()
    }

    fn marshalled_data_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;
        match self {
            #[cfg(all(feature = "ecc", feature = "ecdh"))]
            Self::Ecdh(_) => {
                let details_size = match usize::try_from(tpms_scheme_hash_marshalled_size()) {
                    Ok(details_size) => details_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(details_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(all(feature = "ecc", feature = "ecmqv"))]
            Self::Ecmqv(_) => {
                let details_size = match usize::try_from(tpms_scheme_hash_marshalled_size()) {
                    Ok(details_size) => details_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(details_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(all(feature = "rsa", feature = "rsassa"))]
            Self::Rsassa(_) => {
                let details_size = match usize::try_from(tpms_scheme_hash_marshalled_size()) {
                    Ok(details_size) => details_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(details_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(all(feature = "rsa", feature = "rsapss"))]
            Self::Rsapss(_) => {
                let details_size = match usize::try_from(tpms_scheme_hash_marshalled_size()) {
                    Ok(details_size) => details_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(details_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(all(feature = "ecc", feature = "ecdsa"))]
            Self::Ecdsa(_) => {
                let details_size = match usize::try_from(tpms_scheme_hash_marshalled_size()) {
                    Ok(details_size) => details_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(details_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(all(feature = "ecc", feature = "ecdaa"))]
            Self::Ecdaa(_) => {
                let details_size = match usize::try_from(tpms_scheme_ecdaa_marshalled_size()) {
                    Ok(details_size) => details_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(details_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(all(feature = "ecc", feature = "sm2"))]
            Self::Sm2(_) => {
                let details_size = match usize::try_from(tpms_scheme_hash_marshalled_size()) {
                    Ok(details_size) => details_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(details_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(all(feature = "ecc", feature = "ecschnorr"))]
            Self::Ecschnorr(_) => {
                let details_size = match usize::try_from(tpms_scheme_hash_marshalled_size()) {
                    Ok(details_size) => details_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(details_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(all(feature = "ecc", feature = "eddsa"))]
            Self::Eddsa(_) => {
                let details_size = match usize::try_from(tpms_scheme_hash_marshalled_size()) {
                    Ok(details_size) => details_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(details_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(all(feature = "ecc", feature = "eddsa_ph"))]
            Self::EddsaPh(_) => {
                let details_size = match usize::try_from(tpms_scheme_hash_marshalled_size()) {
                    Ok(details_size) => details_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(details_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(all(feature = "rsa", feature = "rsaes"))]
            Self::Rsaes(_) => {
                let details_size = match usize::try_from(tpms_empty_marshalled_size()) {
                    Ok(details_size) => details_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(details_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(all(feature = "oaep", feature = "rsa"))]
            Self::Oaep(_) => {
                let details_size = match usize::try_from(tpms_empty_marshalled_size()) {
                    Ok(details_size) => details_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(details_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(not(any(all(feature = "ecc", feature = "ecdaa"), all(feature = "ecc", feature = "ecdh"), all(feature = "ecc", feature = "ecdsa"), all(feature = "ecc", feature = "ecmqv"), all(feature = "ecc", feature = "ecschnorr"), all(feature = "ecc", feature = "eddsa"), all(feature = "ecc", feature = "eddsa_ph"), all(feature = "ecc", feature = "sm2"), all(feature = "oaep", feature = "rsa"), all(feature = "rsa", feature = "rsaes"), all(feature = "rsa", feature = "rsapss"), all(feature = "rsa", feature = "rsassa"))))]
            _ => unreachable!(),
        };

        Ok(size)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let selector_size = match usize::try_from(Self::marshalled_selector_size()) {
            Ok(selector_size) => selector_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(selector_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let data_size = match self.marshalled_data_size() {
            Ok(data_size) => data_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(data_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = match self {
            #[cfg(all(feature = "ecc", feature = "ecdh"))]
            Self::Ecdh(details) => {
                let selector = TpmAlgId::Ecdh as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = details.marshal(buf)?;

                buf
            },
            #[cfg(all(feature = "ecc", feature = "ecmqv"))]
            Self::Ecmqv(details) => {
                let selector = TpmAlgId::Ecmqv as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = details.marshal(buf)?;

                buf
            },
            #[cfg(all(feature = "rsa", feature = "rsassa"))]
            Self::Rsassa(details) => {
                let selector = TpmAlgId::Rsassa as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = details.marshal(buf)?;

                buf
            },
            #[cfg(all(feature = "rsa", feature = "rsapss"))]
            Self::Rsapss(details) => {
                let selector = TpmAlgId::Rsapss as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = details.marshal(buf)?;

                buf
            },
            #[cfg(all(feature = "ecc", feature = "ecdsa"))]
            Self::Ecdsa(details) => {
                let selector = TpmAlgId::Ecdsa as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = details.marshal(buf)?;

                buf
            },
            #[cfg(all(feature = "ecc", feature = "ecdaa"))]
            Self::Ecdaa(details) => {
                let selector = TpmAlgId::Ecdaa as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = details.marshal(buf)?;

                buf
            },
            #[cfg(all(feature = "ecc", feature = "sm2"))]
            Self::Sm2(details) => {
                let selector = TpmAlgId::Sm2 as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = details.marshal(buf)?;

                buf
            },
            #[cfg(all(feature = "ecc", feature = "ecschnorr"))]
            Self::Ecschnorr(details) => {
                let selector = TpmAlgId::Ecschnorr as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = details.marshal(buf)?;

                buf
            },
            #[cfg(all(feature = "ecc", feature = "eddsa"))]
            Self::Eddsa(details) => {
                let selector = TpmAlgId::Eddsa as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = details.marshal(buf)?;

                buf
            },
            #[cfg(all(feature = "ecc", feature = "eddsa_ph"))]
            Self::EddsaPh(details) => {
                let selector = TpmAlgId::EddsaPh as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = details.marshal(buf)?;

                buf
            },
            #[cfg(all(feature = "rsa", feature = "rsaes"))]
            Self::Rsaes(details) => {
                let selector = TpmAlgId::Rsaes as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = details.marshal(buf)?;

                buf
            },
            #[cfg(all(feature = "oaep", feature = "rsa"))]
            Self::Oaep(details) => {
                let selector = TpmAlgId::Oaep as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = details.marshal(buf)?;

                buf
            },
            #[cfg(not(any(all(feature = "ecc", feature = "ecdaa"), all(feature = "ecc", feature = "ecdh"), all(feature = "ecc", feature = "ecdsa"), all(feature = "ecc", feature = "ecmqv"), all(feature = "ecc", feature = "ecschnorr"), all(feature = "ecc", feature = "eddsa"), all(feature = "ecc", feature = "eddsa_ph"), all(feature = "ecc", feature = "sm2"), all(feature = "oaep", feature = "rsa"), all(feature = "rsa", feature = "rsaes"), all(feature = "rsa", feature = "rsapss"), all(feature = "rsa", feature = "rsassa"))))]
            _ => unreachable!(),
        };
        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_scheme) = match unmarshal_u16(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, r) = match unmarshalled_scheme {
            #[cfg(all(feature = "ecc", feature = "ecdh"))]
            value if value == TpmAlgId::Ecdh as u16 => {
                let (buf, unmarshalled_details) = match TpmsSchemeHash::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Ecdh(unmarshalled_details))
            },
            #[cfg(all(feature = "ecc", feature = "ecmqv"))]
            value if value == TpmAlgId::Ecmqv as u16 => {
                let (buf, unmarshalled_details) = match TpmsSchemeHash::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Ecmqv(unmarshalled_details))
            },
            #[cfg(all(feature = "rsa", feature = "rsassa"))]
            value if value == TpmAlgId::Rsassa as u16 => {
                let (buf, unmarshalled_details) = match TpmsSchemeHash::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Rsassa(unmarshalled_details))
            },
            #[cfg(all(feature = "rsa", feature = "rsapss"))]
            value if value == TpmAlgId::Rsapss as u16 => {
                let (buf, unmarshalled_details) = match TpmsSchemeHash::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Rsapss(unmarshalled_details))
            },
            #[cfg(all(feature = "ecc", feature = "ecdsa"))]
            value if value == TpmAlgId::Ecdsa as u16 => {
                let (buf, unmarshalled_details) = match TpmsSchemeHash::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Ecdsa(unmarshalled_details))
            },
            #[cfg(all(feature = "ecc", feature = "ecdaa"))]
            value if value == TpmAlgId::Ecdaa as u16 => {
                let (buf, unmarshalled_details) = match TpmsSchemeEcdaa::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Ecdaa(unmarshalled_details))
            },
            #[cfg(all(feature = "ecc", feature = "sm2"))]
            value if value == TpmAlgId::Sm2 as u16 => {
                let (buf, unmarshalled_details) = match TpmsSchemeHash::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Sm2(unmarshalled_details))
            },
            #[cfg(all(feature = "ecc", feature = "ecschnorr"))]
            value if value == TpmAlgId::Ecschnorr as u16 => {
                let (buf, unmarshalled_details) = match TpmsSchemeHash::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Ecschnorr(unmarshalled_details))
            },
            #[cfg(all(feature = "ecc", feature = "eddsa"))]
            value if value == TpmAlgId::Eddsa as u16 => {
                let (buf, unmarshalled_details) = match TpmsSchemeHash::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Eddsa(unmarshalled_details))
            },
            #[cfg(all(feature = "ecc", feature = "eddsa_ph"))]
            value if value == TpmAlgId::EddsaPh as u16 => {
                let (buf, unmarshalled_details) = match TpmsSchemeHash::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::EddsaPh(unmarshalled_details))
            },
            #[cfg(all(feature = "rsa", feature = "rsaes"))]
            value if value == TpmAlgId::Rsaes as u16 => {
                let (buf, unmarshalled_details) = match TpmsEmpty::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Rsaes(unmarshalled_details))
            },
            #[cfg(all(feature = "oaep", feature = "rsa"))]
            value if value == TpmAlgId::Oaep as u16 => {
                let (buf, unmarshalled_details) = match TpmsEmpty::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Oaep(unmarshalled_details))
            },
            _ => {
                return Err(TpmErr::Rc(TpmRc::VALUE));
            },
        };

        Ok((buf, r))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpmt_asym_scheme_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiAlgAsymScheme::marshalled_size();
    size += TpmuAsymScheme::marshalled_max_size();

    size
}

impl convert::From<&TpmtAsymScheme> for TpmiAlgAsymScheme {
    fn from(value: &TpmtAsymScheme) -> Self {
        match value {
            #[cfg(all(feature = "ecc", feature = "ecdh"))]
            TpmtAsymScheme::Ecdh(_) => Self::Ecdh,
            #[cfg(all(feature = "ecc", feature = "ecmqv"))]
            TpmtAsymScheme::Ecmqv(_) => Self::Ecmqv,
            #[cfg(all(feature = "rsa", feature = "rsassa"))]
            TpmtAsymScheme::Rsassa(_) => Self::Rsassa,
            #[cfg(all(feature = "rsa", feature = "rsapss"))]
            TpmtAsymScheme::Rsapss(_) => Self::Rsapss,
            #[cfg(all(feature = "ecc", feature = "ecdsa"))]
            TpmtAsymScheme::Ecdsa(_) => Self::Ecdsa,
            #[cfg(all(feature = "ecc", feature = "ecdaa"))]
            TpmtAsymScheme::Ecdaa(_) => Self::Ecdaa,
            #[cfg(all(feature = "ecc", feature = "sm2"))]
            TpmtAsymScheme::Sm2(_) => Self::Sm2,
            #[cfg(all(feature = "ecc", feature = "ecschnorr"))]
            TpmtAsymScheme::Ecschnorr(_) => Self::Ecschnorr,
            #[cfg(all(feature = "ecc", feature = "eddsa"))]
            TpmtAsymScheme::Eddsa(_) => Self::Eddsa,
            #[cfg(all(feature = "ecc", feature = "eddsa_ph"))]
            TpmtAsymScheme::EddsaPh(_) => Self::EddsaPh,
            #[cfg(all(feature = "rsa", feature = "rsaes"))]
            TpmtAsymScheme::Rsaes(_) => Self::Rsaes,
            #[cfg(all(feature = "oaep", feature = "rsa"))]
            TpmtAsymScheme::Oaep(_) => Self::Oaep,
            #[cfg(not(any(all(feature = "ecc", feature = "ecdaa"), all(feature = "ecc", feature = "ecdh"), all(feature = "ecc", feature = "ecdsa"), all(feature = "ecc", feature = "ecmqv"), all(feature = "ecc", feature = "ecschnorr"), all(feature = "ecc", feature = "eddsa"), all(feature = "ecc", feature = "eddsa_ph"), all(feature = "ecc", feature = "sm2"), all(feature = "oaep", feature = "rsa"), all(feature = "rsa", feature = "rsaes"), all(feature = "rsa", feature = "rsapss"), all(feature = "rsa", feature = "rsassa"))))]
            _ => unreachable!(),
        }
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 172, table 188, TPMT_ASYM_SCHEME structure (with conditional values)
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u16)]
pub enum TpmtAsymSchemeWCV {
    #[cfg(all(feature = "ecc", feature = "ecdh"))]
    Ecdh(TpmsSchemeHash) = TpmAlgId::Ecdh as u16,
    #[cfg(all(feature = "ecc", feature = "ecmqv"))]
    Ecmqv(TpmsSchemeHash) = TpmAlgId::Ecmqv as u16,
    #[cfg(all(feature = "rsa", feature = "rsassa"))]
    Rsassa(TpmsSchemeHash) = TpmAlgId::Rsassa as u16,
    #[cfg(all(feature = "rsa", feature = "rsapss"))]
    Rsapss(TpmsSchemeHash) = TpmAlgId::Rsapss as u16,
    #[cfg(all(feature = "ecc", feature = "ecdsa"))]
    Ecdsa(TpmsSchemeHash) = TpmAlgId::Ecdsa as u16,
    #[cfg(all(feature = "ecc", feature = "ecdaa"))]
    Ecdaa(TpmsSchemeEcdaa) = TpmAlgId::Ecdaa as u16,
    #[cfg(all(feature = "ecc", feature = "sm2"))]
    Sm2(TpmsSchemeHash) = TpmAlgId::Sm2 as u16,
    #[cfg(all(feature = "ecc", feature = "ecschnorr"))]
    Ecschnorr(TpmsSchemeHash) = TpmAlgId::Ecschnorr as u16,
    #[cfg(all(feature = "ecc", feature = "eddsa"))]
    Eddsa(TpmsSchemeHash) = TpmAlgId::Eddsa as u16,
    #[cfg(all(feature = "ecc", feature = "eddsa_ph"))]
    EddsaPh(TpmsSchemeHash) = TpmAlgId::EddsaPh as u16,
    #[cfg(all(feature = "rsa", feature = "rsaes"))]
    Rsaes(TpmsEmpty) = TpmAlgId::Rsaes as u16,
    #[cfg(all(feature = "oaep", feature = "rsa"))]
    Oaep(TpmsEmpty) = TpmAlgId::Oaep as u16,
    Null = TpmAlgId::Null as u16,
}

impl TpmtAsymSchemeWCV {
    pub const fn marshalled_max_size() -> u16 {
        tpmt_asym_scheme_wcv_marshalled_max_size()
    }

    const fn marshalled_selector_size() -> u16 {
        TpmiAlgAsymSchemeWCV::marshalled_size()
    }

    fn marshalled_data_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;
        match self {
            #[cfg(all(feature = "ecc", feature = "ecdh"))]
            Self::Ecdh(_) => {
                let details_size = match usize::try_from(tpms_scheme_hash_marshalled_size()) {
                    Ok(details_size) => details_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(details_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(all(feature = "ecc", feature = "ecmqv"))]
            Self::Ecmqv(_) => {
                let details_size = match usize::try_from(tpms_scheme_hash_marshalled_size()) {
                    Ok(details_size) => details_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(details_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(all(feature = "rsa", feature = "rsassa"))]
            Self::Rsassa(_) => {
                let details_size = match usize::try_from(tpms_scheme_hash_marshalled_size()) {
                    Ok(details_size) => details_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(details_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(all(feature = "rsa", feature = "rsapss"))]
            Self::Rsapss(_) => {
                let details_size = match usize::try_from(tpms_scheme_hash_marshalled_size()) {
                    Ok(details_size) => details_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(details_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(all(feature = "ecc", feature = "ecdsa"))]
            Self::Ecdsa(_) => {
                let details_size = match usize::try_from(tpms_scheme_hash_marshalled_size()) {
                    Ok(details_size) => details_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(details_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(all(feature = "ecc", feature = "ecdaa"))]
            Self::Ecdaa(_) => {
                let details_size = match usize::try_from(tpms_scheme_ecdaa_marshalled_size()) {
                    Ok(details_size) => details_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(details_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(all(feature = "ecc", feature = "sm2"))]
            Self::Sm2(_) => {
                let details_size = match usize::try_from(tpms_scheme_hash_marshalled_size()) {
                    Ok(details_size) => details_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(details_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(all(feature = "ecc", feature = "ecschnorr"))]
            Self::Ecschnorr(_) => {
                let details_size = match usize::try_from(tpms_scheme_hash_marshalled_size()) {
                    Ok(details_size) => details_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(details_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(all(feature = "ecc", feature = "eddsa"))]
            Self::Eddsa(_) => {
                let details_size = match usize::try_from(tpms_scheme_hash_marshalled_size()) {
                    Ok(details_size) => details_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(details_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(all(feature = "ecc", feature = "eddsa_ph"))]
            Self::EddsaPh(_) => {
                let details_size = match usize::try_from(tpms_scheme_hash_marshalled_size()) {
                    Ok(details_size) => details_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(details_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(all(feature = "rsa", feature = "rsaes"))]
            Self::Rsaes(_) => {
                let details_size = match usize::try_from(tpms_empty_marshalled_size()) {
                    Ok(details_size) => details_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(details_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(all(feature = "oaep", feature = "rsa"))]
            Self::Oaep(_) => {
                let details_size = match usize::try_from(tpms_empty_marshalled_size()) {
                    Ok(details_size) => details_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(details_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            Self::Null => (),
        };

        Ok(size)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let selector_size = match usize::try_from(Self::marshalled_selector_size()) {
            Ok(selector_size) => selector_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(selector_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let data_size = match self.marshalled_data_size() {
            Ok(data_size) => data_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(data_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = match self {
            #[cfg(all(feature = "ecc", feature = "ecdh"))]
            Self::Ecdh(details) => {
                let selector = TpmAlgId::Ecdh as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = details.marshal(buf)?;

                buf
            },
            #[cfg(all(feature = "ecc", feature = "ecmqv"))]
            Self::Ecmqv(details) => {
                let selector = TpmAlgId::Ecmqv as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = details.marshal(buf)?;

                buf
            },
            #[cfg(all(feature = "rsa", feature = "rsassa"))]
            Self::Rsassa(details) => {
                let selector = TpmAlgId::Rsassa as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = details.marshal(buf)?;

                buf
            },
            #[cfg(all(feature = "rsa", feature = "rsapss"))]
            Self::Rsapss(details) => {
                let selector = TpmAlgId::Rsapss as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = details.marshal(buf)?;

                buf
            },
            #[cfg(all(feature = "ecc", feature = "ecdsa"))]
            Self::Ecdsa(details) => {
                let selector = TpmAlgId::Ecdsa as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = details.marshal(buf)?;

                buf
            },
            #[cfg(all(feature = "ecc", feature = "ecdaa"))]
            Self::Ecdaa(details) => {
                let selector = TpmAlgId::Ecdaa as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = details.marshal(buf)?;

                buf
            },
            #[cfg(all(feature = "ecc", feature = "sm2"))]
            Self::Sm2(details) => {
                let selector = TpmAlgId::Sm2 as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = details.marshal(buf)?;

                buf
            },
            #[cfg(all(feature = "ecc", feature = "ecschnorr"))]
            Self::Ecschnorr(details) => {
                let selector = TpmAlgId::Ecschnorr as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = details.marshal(buf)?;

                buf
            },
            #[cfg(all(feature = "ecc", feature = "eddsa"))]
            Self::Eddsa(details) => {
                let selector = TpmAlgId::Eddsa as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = details.marshal(buf)?;

                buf
            },
            #[cfg(all(feature = "ecc", feature = "eddsa_ph"))]
            Self::EddsaPh(details) => {
                let selector = TpmAlgId::EddsaPh as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = details.marshal(buf)?;

                buf
            },
            #[cfg(all(feature = "rsa", feature = "rsaes"))]
            Self::Rsaes(details) => {
                let selector = TpmAlgId::Rsaes as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = details.marshal(buf)?;

                buf
            },
            #[cfg(all(feature = "oaep", feature = "rsa"))]
            Self::Oaep(details) => {
                let selector = TpmAlgId::Oaep as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = details.marshal(buf)?;

                buf
            },
            Self::Null => {
                let selector = TpmAlgId::Null as u16;
                let buf = marshal_u16(buf, selector)?;

                buf
            },
        };
        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_scheme) = match unmarshal_u16(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, r) = match unmarshalled_scheme {
            #[cfg(all(feature = "ecc", feature = "ecdh"))]
            value if value == TpmAlgId::Ecdh as u16 => {
                let (buf, unmarshalled_details) = match TpmsSchemeHash::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Ecdh(unmarshalled_details))
            },
            #[cfg(all(feature = "ecc", feature = "ecmqv"))]
            value if value == TpmAlgId::Ecmqv as u16 => {
                let (buf, unmarshalled_details) = match TpmsSchemeHash::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Ecmqv(unmarshalled_details))
            },
            #[cfg(all(feature = "rsa", feature = "rsassa"))]
            value if value == TpmAlgId::Rsassa as u16 => {
                let (buf, unmarshalled_details) = match TpmsSchemeHash::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Rsassa(unmarshalled_details))
            },
            #[cfg(all(feature = "rsa", feature = "rsapss"))]
            value if value == TpmAlgId::Rsapss as u16 => {
                let (buf, unmarshalled_details) = match TpmsSchemeHash::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Rsapss(unmarshalled_details))
            },
            #[cfg(all(feature = "ecc", feature = "ecdsa"))]
            value if value == TpmAlgId::Ecdsa as u16 => {
                let (buf, unmarshalled_details) = match TpmsSchemeHash::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Ecdsa(unmarshalled_details))
            },
            #[cfg(all(feature = "ecc", feature = "ecdaa"))]
            value if value == TpmAlgId::Ecdaa as u16 => {
                let (buf, unmarshalled_details) = match TpmsSchemeEcdaa::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Ecdaa(unmarshalled_details))
            },
            #[cfg(all(feature = "ecc", feature = "sm2"))]
            value if value == TpmAlgId::Sm2 as u16 => {
                let (buf, unmarshalled_details) = match TpmsSchemeHash::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Sm2(unmarshalled_details))
            },
            #[cfg(all(feature = "ecc", feature = "ecschnorr"))]
            value if value == TpmAlgId::Ecschnorr as u16 => {
                let (buf, unmarshalled_details) = match TpmsSchemeHash::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Ecschnorr(unmarshalled_details))
            },
            #[cfg(all(feature = "ecc", feature = "eddsa"))]
            value if value == TpmAlgId::Eddsa as u16 => {
                let (buf, unmarshalled_details) = match TpmsSchemeHash::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Eddsa(unmarshalled_details))
            },
            #[cfg(all(feature = "ecc", feature = "eddsa_ph"))]
            value if value == TpmAlgId::EddsaPh as u16 => {
                let (buf, unmarshalled_details) = match TpmsSchemeHash::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::EddsaPh(unmarshalled_details))
            },
            #[cfg(all(feature = "rsa", feature = "rsaes"))]
            value if value == TpmAlgId::Rsaes as u16 => {
                let (buf, unmarshalled_details) = match TpmsEmpty::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Rsaes(unmarshalled_details))
            },
            #[cfg(all(feature = "oaep", feature = "rsa"))]
            value if value == TpmAlgId::Oaep as u16 => {
                let (buf, unmarshalled_details) = match TpmsEmpty::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Oaep(unmarshalled_details))
            },
            value if value == TpmAlgId::Null as u16 => {
                (buf, Self::Null)
            },
            _ => {
                return Err(TpmErr::Rc(TpmRc::VALUE));
            },
        };

        Ok((buf, r))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpmt_asym_scheme_wcv_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiAlgAsymSchemeWCV::marshalled_size();
    size += TpmuAsymScheme::marshalled_max_size();

    size
}

impl convert::From<&TpmtAsymSchemeWCV> for TpmiAlgAsymSchemeWCV {
    fn from(value: &TpmtAsymSchemeWCV) -> Self {
        match value {
            #[cfg(all(feature = "ecc", feature = "ecdh"))]
            TpmtAsymSchemeWCV::Ecdh(_) => Self::Ecdh,
            #[cfg(all(feature = "ecc", feature = "ecmqv"))]
            TpmtAsymSchemeWCV::Ecmqv(_) => Self::Ecmqv,
            #[cfg(all(feature = "rsa", feature = "rsassa"))]
            TpmtAsymSchemeWCV::Rsassa(_) => Self::Rsassa,
            #[cfg(all(feature = "rsa", feature = "rsapss"))]
            TpmtAsymSchemeWCV::Rsapss(_) => Self::Rsapss,
            #[cfg(all(feature = "ecc", feature = "ecdsa"))]
            TpmtAsymSchemeWCV::Ecdsa(_) => Self::Ecdsa,
            #[cfg(all(feature = "ecc", feature = "ecdaa"))]
            TpmtAsymSchemeWCV::Ecdaa(_) => Self::Ecdaa,
            #[cfg(all(feature = "ecc", feature = "sm2"))]
            TpmtAsymSchemeWCV::Sm2(_) => Self::Sm2,
            #[cfg(all(feature = "ecc", feature = "ecschnorr"))]
            TpmtAsymSchemeWCV::Ecschnorr(_) => Self::Ecschnorr,
            #[cfg(all(feature = "ecc", feature = "eddsa"))]
            TpmtAsymSchemeWCV::Eddsa(_) => Self::Eddsa,
            #[cfg(all(feature = "ecc", feature = "eddsa_ph"))]
            TpmtAsymSchemeWCV::EddsaPh(_) => Self::EddsaPh,
            #[cfg(all(feature = "rsa", feature = "rsaes"))]
            TpmtAsymSchemeWCV::Rsaes(_) => Self::Rsaes,
            #[cfg(all(feature = "oaep", feature = "rsa"))]
            TpmtAsymSchemeWCV::Oaep(_) => Self::Oaep,
            TpmtAsymSchemeWCV::Null => Self::Null,
        }
    }
}

impl convert::From<TpmtAsymScheme> for TpmtAsymSchemeWCV {
    fn from(value: TpmtAsymScheme) -> Self {
        match value {
            #[cfg(all(feature = "ecc", feature = "ecdh"))]
            TpmtAsymScheme::Ecdh(details) => Self::Ecdh(details),
            #[cfg(all(feature = "ecc", feature = "ecmqv"))]
            TpmtAsymScheme::Ecmqv(details) => Self::Ecmqv(details),
            #[cfg(all(feature = "rsa", feature = "rsassa"))]
            TpmtAsymScheme::Rsassa(details) => Self::Rsassa(details),
            #[cfg(all(feature = "rsa", feature = "rsapss"))]
            TpmtAsymScheme::Rsapss(details) => Self::Rsapss(details),
            #[cfg(all(feature = "ecc", feature = "ecdsa"))]
            TpmtAsymScheme::Ecdsa(details) => Self::Ecdsa(details),
            #[cfg(all(feature = "ecc", feature = "ecdaa"))]
            TpmtAsymScheme::Ecdaa(details) => Self::Ecdaa(details),
            #[cfg(all(feature = "ecc", feature = "sm2"))]
            TpmtAsymScheme::Sm2(details) => Self::Sm2(details),
            #[cfg(all(feature = "ecc", feature = "ecschnorr"))]
            TpmtAsymScheme::Ecschnorr(details) => Self::Ecschnorr(details),
            #[cfg(all(feature = "ecc", feature = "eddsa"))]
            TpmtAsymScheme::Eddsa(details) => Self::Eddsa(details),
            #[cfg(all(feature = "ecc", feature = "eddsa_ph"))]
            TpmtAsymScheme::EddsaPh(details) => Self::EddsaPh(details),
            #[cfg(all(feature = "rsa", feature = "rsaes"))]
            TpmtAsymScheme::Rsaes(details) => Self::Rsaes(details),
            #[cfg(all(feature = "oaep", feature = "rsa"))]
            TpmtAsymScheme::Oaep(details) => Self::Oaep(details),
            #[cfg(not(any(all(feature = "ecc", feature = "ecdaa"), all(feature = "ecc", feature = "ecdh"), all(feature = "ecc", feature = "ecdsa"), all(feature = "ecc", feature = "ecmqv"), all(feature = "ecc", feature = "ecschnorr"), all(feature = "ecc", feature = "eddsa"), all(feature = "ecc", feature = "eddsa_ph"), all(feature = "ecc", feature = "sm2"), all(feature = "oaep", feature = "rsa"), all(feature = "rsa", feature = "rsaes"), all(feature = "rsa", feature = "rsapss"), all(feature = "rsa", feature = "rsassa"))))]
            _ => unreachable!(),
        }
    }
}

impl convert::TryFrom<TpmtAsymSchemeWCV> for TpmtAsymScheme {
    type Error = TpmErr;

    fn try_from(value: TpmtAsymSchemeWCV) -> Result<Self, TpmErr> {
        let result = match value {
            #[cfg(all(feature = "ecc", feature = "ecdh"))]
            TpmtAsymSchemeWCV::Ecdh(details) => Self::Ecdh(details),
            #[cfg(all(feature = "ecc", feature = "ecmqv"))]
            TpmtAsymSchemeWCV::Ecmqv(details) => Self::Ecmqv(details),
            #[cfg(all(feature = "rsa", feature = "rsassa"))]
            TpmtAsymSchemeWCV::Rsassa(details) => Self::Rsassa(details),
            #[cfg(all(feature = "rsa", feature = "rsapss"))]
            TpmtAsymSchemeWCV::Rsapss(details) => Self::Rsapss(details),
            #[cfg(all(feature = "ecc", feature = "ecdsa"))]
            TpmtAsymSchemeWCV::Ecdsa(details) => Self::Ecdsa(details),
            #[cfg(all(feature = "ecc", feature = "ecdaa"))]
            TpmtAsymSchemeWCV::Ecdaa(details) => Self::Ecdaa(details),
            #[cfg(all(feature = "ecc", feature = "sm2"))]
            TpmtAsymSchemeWCV::Sm2(details) => Self::Sm2(details),
            #[cfg(all(feature = "ecc", feature = "ecschnorr"))]
            TpmtAsymSchemeWCV::Ecschnorr(details) => Self::Ecschnorr(details),
            #[cfg(all(feature = "ecc", feature = "eddsa"))]
            TpmtAsymSchemeWCV::Eddsa(details) => Self::Eddsa(details),
            #[cfg(all(feature = "ecc", feature = "eddsa_ph"))]
            TpmtAsymSchemeWCV::EddsaPh(details) => Self::EddsaPh(details),
            #[cfg(all(feature = "rsa", feature = "rsaes"))]
            TpmtAsymSchemeWCV::Rsaes(details) => Self::Rsaes(details),
            #[cfg(all(feature = "oaep", feature = "rsa"))]
            TpmtAsymSchemeWCV::Oaep(details) => Self::Oaep(details),
            _ => {
                return Err(TpmErr::Rc(TpmRc::VALUE));
            },
        };

        Ok(result)
    }
}

impl cmp::PartialEq<TpmtAsymScheme> for TpmtAsymSchemeWCV {
    fn eq(&self, other: &TpmtAsymScheme) -> bool {
        match self {
            #[cfg(all(feature = "ecc", feature = "ecdh"))]
            Self::Ecdh(self_details) => {
                if let TpmtAsymScheme::Ecdh(other_details) = other {
                    self_details == other_details
                } else {
                    false
                }
            },
            #[cfg(all(feature = "ecc", feature = "ecmqv"))]
            Self::Ecmqv(self_details) => {
                if let TpmtAsymScheme::Ecmqv(other_details) = other {
                    self_details == other_details
                } else {
                    false
                }
            },
            #[cfg(all(feature = "rsa", feature = "rsassa"))]
            Self::Rsassa(self_details) => {
                if let TpmtAsymScheme::Rsassa(other_details) = other {
                    self_details == other_details
                } else {
                    false
                }
            },
            #[cfg(all(feature = "rsa", feature = "rsapss"))]
            Self::Rsapss(self_details) => {
                if let TpmtAsymScheme::Rsapss(other_details) = other {
                    self_details == other_details
                } else {
                    false
                }
            },
            #[cfg(all(feature = "ecc", feature = "ecdsa"))]
            Self::Ecdsa(self_details) => {
                if let TpmtAsymScheme::Ecdsa(other_details) = other {
                    self_details == other_details
                } else {
                    false
                }
            },
            #[cfg(all(feature = "ecc", feature = "ecdaa"))]
            Self::Ecdaa(self_details) => {
                if let TpmtAsymScheme::Ecdaa(other_details) = other {
                    self_details == other_details
                } else {
                    false
                }
            },
            #[cfg(all(feature = "ecc", feature = "sm2"))]
            Self::Sm2(self_details) => {
                if let TpmtAsymScheme::Sm2(other_details) = other {
                    self_details == other_details
                } else {
                    false
                }
            },
            #[cfg(all(feature = "ecc", feature = "ecschnorr"))]
            Self::Ecschnorr(self_details) => {
                if let TpmtAsymScheme::Ecschnorr(other_details) = other {
                    self_details == other_details
                } else {
                    false
                }
            },
            #[cfg(all(feature = "ecc", feature = "eddsa"))]
            Self::Eddsa(self_details) => {
                if let TpmtAsymScheme::Eddsa(other_details) = other {
                    self_details == other_details
                } else {
                    false
                }
            },
            #[cfg(all(feature = "ecc", feature = "eddsa_ph"))]
            Self::EddsaPh(self_details) => {
                if let TpmtAsymScheme::EddsaPh(other_details) = other {
                    self_details == other_details
                } else {
                    false
                }
            },
            #[cfg(all(feature = "rsa", feature = "rsaes"))]
            Self::Rsaes(self_details) => {
                if let TpmtAsymScheme::Rsaes(other_details) = other {
                    self_details == other_details
                } else {
                    false
                }
            },
            #[cfg(all(feature = "oaep", feature = "rsa"))]
            Self::Oaep(self_details) => {
                if let TpmtAsymScheme::Oaep(other_details) = other {
                    self_details == other_details
                } else {
                    false
                }
            },
            _ => false,
        }
    }
}

impl cmp::PartialEq<TpmtAsymSchemeWCV> for TpmtAsymScheme {
    fn eq(&self, other: &TpmtAsymSchemeWCV) -> bool {
        other.eq(self)
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 173, table 189, TPMI_ALG_RSA_SCHEME type (without conditional values)
#[cfg(feature = "rsa")]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[cfg_attr(any(feature = "oaep", feature = "rsaes", feature = "rsapss", feature = "rsassa"), repr(u16))]
pub enum TpmiAlgRsaScheme {
    #[cfg(feature = "rsassa")]
    Rsassa = TpmAlgId::Rsassa as u16,
    #[cfg(feature = "rsaes")]
    Rsaes = TpmAlgId::Rsaes as u16,
    #[cfg(feature = "rsapss")]
    Rsapss = TpmAlgId::Rsapss as u16,
    #[cfg(feature = "oaep")]
    Oaep = TpmAlgId::Oaep as u16,
}

#[cfg(feature = "rsa")]
impl TpmiAlgRsaScheme {
    pub const fn marshalled_size() -> u16 {
        mem::size_of::<u16>() as u16
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u16(buf, *self as u16)
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u16(buf)?;
        let result = Self::try_from(value)?;
        Ok((buf, result))
    }
}

#[cfg(feature = "rsa")]
impl convert::TryFrom<u16> for TpmiAlgRsaScheme {
    type Error = TpmErr;

    fn try_from(value: u16) -> Result<Self, TpmErr> {
        let result = match value {
            #[cfg(feature = "rsassa")]
            value if value == Self::Rsassa as u16 => Self::Rsassa,
            #[cfg(feature = "rsaes")]
            value if value == Self::Rsaes as u16 => Self::Rsaes,
            #[cfg(feature = "rsapss")]
            value if value == Self::Rsapss as u16 => Self::Rsapss,
            #[cfg(feature = "oaep")]
            value if value == Self::Oaep as u16 => Self::Oaep,
            _ => {
                return Err(TpmErr::Rc(TpmRc::VALUE));
            },
        };

        Ok(result)
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 173, table 189, TPMI_ALG_RSA_SCHEME type (with conditional values)
#[cfg(feature = "rsa")]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u16)]
pub enum TpmiAlgRsaSchemeWCV {
    #[cfg(feature = "rsassa")]
    Rsassa = TpmAlgId::Rsassa as u16,
    #[cfg(feature = "rsaes")]
    Rsaes = TpmAlgId::Rsaes as u16,
    #[cfg(feature = "rsapss")]
    Rsapss = TpmAlgId::Rsapss as u16,
    #[cfg(feature = "oaep")]
    Oaep = TpmAlgId::Oaep as u16,
    Null = TpmAlgId::Null as u16,
}

#[cfg(feature = "rsa")]
impl TpmiAlgRsaSchemeWCV {
    pub const fn marshalled_size() -> u16 {
        mem::size_of::<u16>() as u16
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u16(buf, *self as u16)
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u16(buf)?;
        let result = Self::try_from(value)?;
        Ok((buf, result))
    }
}

#[cfg(feature = "rsa")]
impl convert::TryFrom<u16> for TpmiAlgRsaSchemeWCV {
    type Error = TpmErr;

    fn try_from(value: u16) -> Result<Self, TpmErr> {
        let result = match value {
            #[cfg(feature = "rsassa")]
            value if value == Self::Rsassa as u16 => Self::Rsassa,
            #[cfg(feature = "rsaes")]
            value if value == Self::Rsaes as u16 => Self::Rsaes,
            #[cfg(feature = "rsapss")]
            value if value == Self::Rsapss as u16 => Self::Rsapss,
            #[cfg(feature = "oaep")]
            value if value == Self::Oaep as u16 => Self::Oaep,
            value if value == Self::Null as u16 => Self::Null,
            _ => {
                return Err(TpmErr::Rc(TpmRc::VALUE));
            },
        };

        Ok(result)
    }
}

#[cfg(feature = "rsa")]
impl convert::From<TpmiAlgRsaScheme> for TpmiAlgRsaSchemeWCV {
    fn from(value: TpmiAlgRsaScheme) -> Self {
        match value {
            #[cfg(feature = "rsassa")]
            TpmiAlgRsaScheme::Rsassa => Self::Rsassa,
            #[cfg(feature = "rsaes")]
            TpmiAlgRsaScheme::Rsaes => Self::Rsaes,
            #[cfg(feature = "rsapss")]
            TpmiAlgRsaScheme::Rsapss => Self::Rsapss,
            #[cfg(feature = "oaep")]
            TpmiAlgRsaScheme::Oaep => Self::Oaep,
        }
    }
}

#[cfg(feature = "rsa")]
impl convert::TryFrom<TpmiAlgRsaSchemeWCV> for TpmiAlgRsaScheme {
    type Error = TpmErr;

    fn try_from(value: TpmiAlgRsaSchemeWCV) -> Result<Self, TpmErr> {
        let result = match value {
            #[cfg(feature = "rsassa")]
            TpmiAlgRsaSchemeWCV::Rsassa => Self::Rsassa,
            #[cfg(feature = "rsaes")]
            TpmiAlgRsaSchemeWCV::Rsaes => Self::Rsaes,
            #[cfg(feature = "rsapss")]
            TpmiAlgRsaSchemeWCV::Rsapss => Self::Rsapss,
            #[cfg(feature = "oaep")]
            TpmiAlgRsaSchemeWCV::Oaep => Self::Oaep,
            TpmiAlgRsaSchemeWCV::Null => {
                return Err(TpmErr::Rc(TpmRc::VALUE));
            },
        };
        Ok(result)
    }
}

#[cfg(feature = "rsa")]
impl cmp::PartialEq<TpmiAlgRsaScheme> for TpmiAlgRsaSchemeWCV {
    fn eq(&self, other: &TpmiAlgRsaScheme) -> bool {
        *self as u16 == *other as u16
    }
}

#[cfg(feature = "rsa")]
impl cmp::PartialEq<TpmiAlgRsaSchemeWCV> for TpmiAlgRsaScheme {
    fn eq(&self, other: &TpmiAlgRsaSchemeWCV) -> bool {
        other.eq(self)
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 173, table 190, TPMT_RSA_SCHEME structure (without conditional values)
#[cfg(feature = "rsa")]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[cfg_attr(any(feature = "oaep", feature = "rsaes", feature = "rsapss", feature = "rsassa"), repr(u16))]
pub enum TpmtRsaScheme {
    #[cfg(feature = "rsassa")]
    Rsassa(TpmsSchemeHash) = TpmAlgId::Rsassa as u16,
    #[cfg(feature = "rsaes")]
    Rsaes(TpmsEmpty) = TpmAlgId::Rsaes as u16,
    #[cfg(feature = "rsapss")]
    Rsapss(TpmsSchemeHash) = TpmAlgId::Rsapss as u16,
    #[cfg(feature = "oaep")]
    Oaep(TpmsEmpty) = TpmAlgId::Oaep as u16,
}

#[cfg(feature = "rsa")]
impl TpmtRsaScheme {
    pub const fn marshalled_max_size() -> u16 {
        tpmt_rsa_scheme_marshalled_max_size()
    }

    const fn marshalled_selector_size() -> u16 {
        TpmiAlgRsaScheme::marshalled_size()
    }

    fn marshalled_data_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;
        match self {
            #[cfg(feature = "rsassa")]
            Self::Rsassa(_) => {
                let details_size = match usize::try_from(tpms_scheme_hash_marshalled_size()) {
                    Ok(details_size) => details_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(details_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(feature = "rsaes")]
            Self::Rsaes(_) => {
                let details_size = match usize::try_from(tpms_empty_marshalled_size()) {
                    Ok(details_size) => details_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(details_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(feature = "rsapss")]
            Self::Rsapss(_) => {
                let details_size = match usize::try_from(tpms_scheme_hash_marshalled_size()) {
                    Ok(details_size) => details_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(details_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(feature = "oaep")]
            Self::Oaep(_) => {
                let details_size = match usize::try_from(tpms_empty_marshalled_size()) {
                    Ok(details_size) => details_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(details_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(not(any(feature = "oaep", feature = "rsaes", feature = "rsapss", feature = "rsassa")))]
            _ => unreachable!(),
        };

        Ok(size)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let selector_size = match usize::try_from(Self::marshalled_selector_size()) {
            Ok(selector_size) => selector_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(selector_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let data_size = match self.marshalled_data_size() {
            Ok(data_size) => data_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(data_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = match self {
            #[cfg(feature = "rsassa")]
            Self::Rsassa(details) => {
                let selector = TpmAlgId::Rsassa as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = details.marshal(buf)?;

                buf
            },
            #[cfg(feature = "rsaes")]
            Self::Rsaes(details) => {
                let selector = TpmAlgId::Rsaes as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = details.marshal(buf)?;

                buf
            },
            #[cfg(feature = "rsapss")]
            Self::Rsapss(details) => {
                let selector = TpmAlgId::Rsapss as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = details.marshal(buf)?;

                buf
            },
            #[cfg(feature = "oaep")]
            Self::Oaep(details) => {
                let selector = TpmAlgId::Oaep as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = details.marshal(buf)?;

                buf
            },
            #[cfg(not(any(feature = "oaep", feature = "rsaes", feature = "rsapss", feature = "rsassa")))]
            _ => unreachable!(),
        };
        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_scheme) = match unmarshal_u16(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, r) = match unmarshalled_scheme {
            #[cfg(feature = "rsassa")]
            value if value == TpmAlgId::Rsassa as u16 => {
                let (buf, unmarshalled_details) = match TpmsSchemeHash::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Rsassa(unmarshalled_details))
            },
            #[cfg(feature = "rsaes")]
            value if value == TpmAlgId::Rsaes as u16 => {
                let (buf, unmarshalled_details) = match TpmsEmpty::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Rsaes(unmarshalled_details))
            },
            #[cfg(feature = "rsapss")]
            value if value == TpmAlgId::Rsapss as u16 => {
                let (buf, unmarshalled_details) = match TpmsSchemeHash::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Rsapss(unmarshalled_details))
            },
            #[cfg(feature = "oaep")]
            value if value == TpmAlgId::Oaep as u16 => {
                let (buf, unmarshalled_details) = match TpmsEmpty::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Oaep(unmarshalled_details))
            },
            _ => {
                return Err(TpmErr::Rc(TpmRc::VALUE));
            },
        };

        Ok((buf, r))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

#[cfg(feature = "rsa")]
const fn tpmt_rsa_scheme_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiAlgRsaScheme::marshalled_size();
    size += TpmuAsymScheme::marshalled_max_size();

    size
}

#[cfg(feature = "rsa")]
impl convert::From<&TpmtRsaScheme> for TpmiAlgRsaScheme {
    fn from(value: &TpmtRsaScheme) -> Self {
        match value {
            #[cfg(feature = "rsassa")]
            TpmtRsaScheme::Rsassa(_) => Self::Rsassa,
            #[cfg(feature = "rsaes")]
            TpmtRsaScheme::Rsaes(_) => Self::Rsaes,
            #[cfg(feature = "rsapss")]
            TpmtRsaScheme::Rsapss(_) => Self::Rsapss,
            #[cfg(feature = "oaep")]
            TpmtRsaScheme::Oaep(_) => Self::Oaep,
            #[cfg(not(any(feature = "oaep", feature = "rsaes", feature = "rsapss", feature = "rsassa")))]
            _ => unreachable!(),
        }
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 173, table 190, TPMT_RSA_SCHEME structure (with conditional values)
#[cfg(feature = "rsa")]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u16)]
pub enum TpmtRsaSchemeWCV {
    #[cfg(feature = "rsassa")]
    Rsassa(TpmsSchemeHash) = TpmAlgId::Rsassa as u16,
    #[cfg(feature = "rsaes")]
    Rsaes(TpmsEmpty) = TpmAlgId::Rsaes as u16,
    #[cfg(feature = "rsapss")]
    Rsapss(TpmsSchemeHash) = TpmAlgId::Rsapss as u16,
    #[cfg(feature = "oaep")]
    Oaep(TpmsEmpty) = TpmAlgId::Oaep as u16,
    Null = TpmAlgId::Null as u16,
}

#[cfg(feature = "rsa")]
impl TpmtRsaSchemeWCV {
    pub const fn marshalled_max_size() -> u16 {
        tpmt_rsa_scheme_wcv_marshalled_max_size()
    }

    const fn marshalled_selector_size() -> u16 {
        TpmiAlgRsaSchemeWCV::marshalled_size()
    }

    fn marshalled_data_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;
        match self {
            #[cfg(feature = "rsassa")]
            Self::Rsassa(_) => {
                let details_size = match usize::try_from(tpms_scheme_hash_marshalled_size()) {
                    Ok(details_size) => details_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(details_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(feature = "rsaes")]
            Self::Rsaes(_) => {
                let details_size = match usize::try_from(tpms_empty_marshalled_size()) {
                    Ok(details_size) => details_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(details_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(feature = "rsapss")]
            Self::Rsapss(_) => {
                let details_size = match usize::try_from(tpms_scheme_hash_marshalled_size()) {
                    Ok(details_size) => details_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(details_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(feature = "oaep")]
            Self::Oaep(_) => {
                let details_size = match usize::try_from(tpms_empty_marshalled_size()) {
                    Ok(details_size) => details_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(details_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            Self::Null => (),
        };

        Ok(size)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let selector_size = match usize::try_from(Self::marshalled_selector_size()) {
            Ok(selector_size) => selector_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(selector_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let data_size = match self.marshalled_data_size() {
            Ok(data_size) => data_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(data_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = match self {
            #[cfg(feature = "rsassa")]
            Self::Rsassa(details) => {
                let selector = TpmAlgId::Rsassa as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = details.marshal(buf)?;

                buf
            },
            #[cfg(feature = "rsaes")]
            Self::Rsaes(details) => {
                let selector = TpmAlgId::Rsaes as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = details.marshal(buf)?;

                buf
            },
            #[cfg(feature = "rsapss")]
            Self::Rsapss(details) => {
                let selector = TpmAlgId::Rsapss as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = details.marshal(buf)?;

                buf
            },
            #[cfg(feature = "oaep")]
            Self::Oaep(details) => {
                let selector = TpmAlgId::Oaep as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = details.marshal(buf)?;

                buf
            },
            Self::Null => {
                let selector = TpmAlgId::Null as u16;
                let buf = marshal_u16(buf, selector)?;

                buf
            },
        };
        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_scheme) = match unmarshal_u16(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, r) = match unmarshalled_scheme {
            #[cfg(feature = "rsassa")]
            value if value == TpmAlgId::Rsassa as u16 => {
                let (buf, unmarshalled_details) = match TpmsSchemeHash::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Rsassa(unmarshalled_details))
            },
            #[cfg(feature = "rsaes")]
            value if value == TpmAlgId::Rsaes as u16 => {
                let (buf, unmarshalled_details) = match TpmsEmpty::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Rsaes(unmarshalled_details))
            },
            #[cfg(feature = "rsapss")]
            value if value == TpmAlgId::Rsapss as u16 => {
                let (buf, unmarshalled_details) = match TpmsSchemeHash::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Rsapss(unmarshalled_details))
            },
            #[cfg(feature = "oaep")]
            value if value == TpmAlgId::Oaep as u16 => {
                let (buf, unmarshalled_details) = match TpmsEmpty::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Oaep(unmarshalled_details))
            },
            value if value == TpmAlgId::Null as u16 => {
                (buf, Self::Null)
            },
            _ => {
                return Err(TpmErr::Rc(TpmRc::VALUE));
            },
        };

        Ok((buf, r))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

#[cfg(feature = "rsa")]
const fn tpmt_rsa_scheme_wcv_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiAlgRsaSchemeWCV::marshalled_size();
    size += TpmuAsymScheme::marshalled_max_size();

    size
}

#[cfg(feature = "rsa")]
impl convert::From<&TpmtRsaSchemeWCV> for TpmiAlgRsaSchemeWCV {
    fn from(value: &TpmtRsaSchemeWCV) -> Self {
        match value {
            #[cfg(feature = "rsassa")]
            TpmtRsaSchemeWCV::Rsassa(_) => Self::Rsassa,
            #[cfg(feature = "rsaes")]
            TpmtRsaSchemeWCV::Rsaes(_) => Self::Rsaes,
            #[cfg(feature = "rsapss")]
            TpmtRsaSchemeWCV::Rsapss(_) => Self::Rsapss,
            #[cfg(feature = "oaep")]
            TpmtRsaSchemeWCV::Oaep(_) => Self::Oaep,
            TpmtRsaSchemeWCV::Null => Self::Null,
        }
    }
}

#[cfg(feature = "rsa")]
impl convert::From<TpmtRsaScheme> for TpmtRsaSchemeWCV {
    fn from(value: TpmtRsaScheme) -> Self {
        match value {
            #[cfg(feature = "rsassa")]
            TpmtRsaScheme::Rsassa(details) => Self::Rsassa(details),
            #[cfg(feature = "rsaes")]
            TpmtRsaScheme::Rsaes(details) => Self::Rsaes(details),
            #[cfg(feature = "rsapss")]
            TpmtRsaScheme::Rsapss(details) => Self::Rsapss(details),
            #[cfg(feature = "oaep")]
            TpmtRsaScheme::Oaep(details) => Self::Oaep(details),
            #[cfg(not(any(feature = "oaep", feature = "rsaes", feature = "rsapss", feature = "rsassa")))]
            _ => unreachable!(),
        }
    }
}

#[cfg(feature = "rsa")]
impl convert::TryFrom<TpmtRsaSchemeWCV> for TpmtRsaScheme {
    type Error = TpmErr;

    fn try_from(value: TpmtRsaSchemeWCV) -> Result<Self, TpmErr> {
        let result = match value {
            #[cfg(feature = "rsassa")]
            TpmtRsaSchemeWCV::Rsassa(details) => Self::Rsassa(details),
            #[cfg(feature = "rsaes")]
            TpmtRsaSchemeWCV::Rsaes(details) => Self::Rsaes(details),
            #[cfg(feature = "rsapss")]
            TpmtRsaSchemeWCV::Rsapss(details) => Self::Rsapss(details),
            #[cfg(feature = "oaep")]
            TpmtRsaSchemeWCV::Oaep(details) => Self::Oaep(details),
            _ => {
                return Err(TpmErr::Rc(TpmRc::VALUE));
            },
        };

        Ok(result)
    }
}

#[cfg(feature = "rsa")]
impl cmp::PartialEq<TpmtRsaScheme> for TpmtRsaSchemeWCV {
    fn eq(&self, other: &TpmtRsaScheme) -> bool {
        match self {
            #[cfg(feature = "rsassa")]
            Self::Rsassa(self_details) => {
                if let TpmtRsaScheme::Rsassa(other_details) = other {
                    self_details == other_details
                } else {
                    false
                }
            },
            #[cfg(feature = "rsaes")]
            Self::Rsaes(self_details) => {
                if let TpmtRsaScheme::Rsaes(other_details) = other {
                    self_details == other_details
                } else {
                    false
                }
            },
            #[cfg(feature = "rsapss")]
            Self::Rsapss(self_details) => {
                if let TpmtRsaScheme::Rsapss(other_details) = other {
                    self_details == other_details
                } else {
                    false
                }
            },
            #[cfg(feature = "oaep")]
            Self::Oaep(self_details) => {
                if let TpmtRsaScheme::Oaep(other_details) = other {
                    self_details == other_details
                } else {
                    false
                }
            },
            _ => false,
        }
    }
}

#[cfg(feature = "rsa")]
impl cmp::PartialEq<TpmtRsaSchemeWCV> for TpmtRsaScheme {
    fn eq(&self, other: &TpmtRsaSchemeWCV) -> bool {
        other.eq(self)
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 173, table 191, TPMI_ALG_RSA_DECRYPT type (without conditional values)
#[cfg(feature = "rsa")]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[cfg_attr(any(feature = "oaep", feature = "rsaes"), repr(u16))]
pub enum TpmiAlgRsaDecrypt {
    #[cfg(feature = "rsaes")]
    Rsaes = TpmAlgId::Rsaes as u16,
    #[cfg(feature = "oaep")]
    Oaep = TpmAlgId::Oaep as u16,
}

#[cfg(feature = "rsa")]
impl TpmiAlgRsaDecrypt {
    pub const fn marshalled_size() -> u16 {
        mem::size_of::<u16>() as u16
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u16(buf, *self as u16)
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u16(buf)?;
        let result = Self::try_from(value)?;
        Ok((buf, result))
    }
}

#[cfg(feature = "rsa")]
impl convert::TryFrom<u16> for TpmiAlgRsaDecrypt {
    type Error = TpmErr;

    fn try_from(value: u16) -> Result<Self, TpmErr> {
        let result = match value {
            #[cfg(feature = "rsaes")]
            value if value == Self::Rsaes as u16 => Self::Rsaes,
            #[cfg(feature = "oaep")]
            value if value == Self::Oaep as u16 => Self::Oaep,
            _ => {
                return Err(TpmErr::Rc(TpmRc::VALUE));
            },
        };

        Ok(result)
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 173, table 191, TPMI_ALG_RSA_DECRYPT type (with conditional values)
#[cfg(feature = "rsa")]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u16)]
pub enum TpmiAlgRsaDecryptWCV {
    #[cfg(feature = "rsaes")]
    Rsaes = TpmAlgId::Rsaes as u16,
    #[cfg(feature = "oaep")]
    Oaep = TpmAlgId::Oaep as u16,
    Null = TpmAlgId::Null as u16,
}

#[cfg(feature = "rsa")]
impl TpmiAlgRsaDecryptWCV {
    pub const fn marshalled_size() -> u16 {
        mem::size_of::<u16>() as u16
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u16(buf, *self as u16)
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u16(buf)?;
        let result = Self::try_from(value)?;
        Ok((buf, result))
    }
}

#[cfg(feature = "rsa")]
impl convert::TryFrom<u16> for TpmiAlgRsaDecryptWCV {
    type Error = TpmErr;

    fn try_from(value: u16) -> Result<Self, TpmErr> {
        let result = match value {
            #[cfg(feature = "rsaes")]
            value if value == Self::Rsaes as u16 => Self::Rsaes,
            #[cfg(feature = "oaep")]
            value if value == Self::Oaep as u16 => Self::Oaep,
            value if value == Self::Null as u16 => Self::Null,
            _ => {
                return Err(TpmErr::Rc(TpmRc::VALUE));
            },
        };

        Ok(result)
    }
}

#[cfg(feature = "rsa")]
impl convert::From<TpmiAlgRsaDecrypt> for TpmiAlgRsaDecryptWCV {
    fn from(value: TpmiAlgRsaDecrypt) -> Self {
        match value {
            #[cfg(feature = "rsaes")]
            TpmiAlgRsaDecrypt::Rsaes => Self::Rsaes,
            #[cfg(feature = "oaep")]
            TpmiAlgRsaDecrypt::Oaep => Self::Oaep,
        }
    }
}

#[cfg(feature = "rsa")]
impl convert::TryFrom<TpmiAlgRsaDecryptWCV> for TpmiAlgRsaDecrypt {
    type Error = TpmErr;

    fn try_from(value: TpmiAlgRsaDecryptWCV) -> Result<Self, TpmErr> {
        let result = match value {
            #[cfg(feature = "rsaes")]
            TpmiAlgRsaDecryptWCV::Rsaes => Self::Rsaes,
            #[cfg(feature = "oaep")]
            TpmiAlgRsaDecryptWCV::Oaep => Self::Oaep,
            TpmiAlgRsaDecryptWCV::Null => {
                return Err(TpmErr::Rc(TpmRc::VALUE));
            },
        };
        Ok(result)
    }
}

#[cfg(feature = "rsa")]
impl cmp::PartialEq<TpmiAlgRsaDecrypt> for TpmiAlgRsaDecryptWCV {
    fn eq(&self, other: &TpmiAlgRsaDecrypt) -> bool {
        *self as u16 == *other as u16
    }
}

#[cfg(feature = "rsa")]
impl cmp::PartialEq<TpmiAlgRsaDecryptWCV> for TpmiAlgRsaDecrypt {
    fn eq(&self, other: &TpmiAlgRsaDecryptWCV) -> bool {
        other.eq(self)
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 173, table 192, TPMT_RSA_DECRYPT structure (without conditional values)
#[cfg(feature = "rsa")]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[cfg_attr(any(feature = "oaep", feature = "rsaes"), repr(u16))]
pub enum TpmtRsaDecrypt {
    #[cfg(feature = "rsaes")]
    Rsaes(TpmsEmpty) = TpmAlgId::Rsaes as u16,
    #[cfg(feature = "oaep")]
    Oaep(TpmsEmpty) = TpmAlgId::Oaep as u16,
}

#[cfg(feature = "rsa")]
impl TpmtRsaDecrypt {
    pub const fn marshalled_max_size() -> u16 {
        tpmt_rsa_decrypt_marshalled_max_size()
    }

    const fn marshalled_selector_size() -> u16 {
        TpmiAlgRsaDecrypt::marshalled_size()
    }

    fn marshalled_data_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;
        match self {
            #[cfg(feature = "rsaes")]
            Self::Rsaes(_) => {
                let details_size = match usize::try_from(tpms_empty_marshalled_size()) {
                    Ok(details_size) => details_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(details_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(feature = "oaep")]
            Self::Oaep(_) => {
                let details_size = match usize::try_from(tpms_empty_marshalled_size()) {
                    Ok(details_size) => details_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(details_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(not(any(feature = "oaep", feature = "rsaes")))]
            _ => unreachable!(),
        };

        Ok(size)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let selector_size = match usize::try_from(Self::marshalled_selector_size()) {
            Ok(selector_size) => selector_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(selector_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let data_size = match self.marshalled_data_size() {
            Ok(data_size) => data_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(data_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = match self {
            #[cfg(feature = "rsaes")]
            Self::Rsaes(details) => {
                let selector = TpmAlgId::Rsaes as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = details.marshal(buf)?;

                buf
            },
            #[cfg(feature = "oaep")]
            Self::Oaep(details) => {
                let selector = TpmAlgId::Oaep as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = details.marshal(buf)?;

                buf
            },
            #[cfg(not(any(feature = "oaep", feature = "rsaes")))]
            _ => unreachable!(),
        };
        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_scheme) = match unmarshal_u16(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, r) = match unmarshalled_scheme {
            #[cfg(feature = "rsaes")]
            value if value == TpmAlgId::Rsaes as u16 => {
                let (buf, unmarshalled_details) = match TpmsEmpty::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Rsaes(unmarshalled_details))
            },
            #[cfg(feature = "oaep")]
            value if value == TpmAlgId::Oaep as u16 => {
                let (buf, unmarshalled_details) = match TpmsEmpty::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Oaep(unmarshalled_details))
            },
            _ => {
                return Err(TpmErr::Rc(TpmRc::VALUE));
            },
        };

        Ok((buf, r))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

#[cfg(feature = "rsa")]
const fn tpmt_rsa_decrypt_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiAlgRsaDecrypt::marshalled_size();
    size += TpmuAsymScheme::marshalled_max_size();

    size
}

#[cfg(feature = "rsa")]
impl convert::From<&TpmtRsaDecrypt> for TpmiAlgRsaDecrypt {
    fn from(value: &TpmtRsaDecrypt) -> Self {
        match value {
            #[cfg(feature = "rsaes")]
            TpmtRsaDecrypt::Rsaes(_) => Self::Rsaes,
            #[cfg(feature = "oaep")]
            TpmtRsaDecrypt::Oaep(_) => Self::Oaep,
            #[cfg(not(any(feature = "oaep", feature = "rsaes")))]
            _ => unreachable!(),
        }
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 173, table 192, TPMT_RSA_DECRYPT structure (with conditional values)
#[cfg(feature = "rsa")]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u16)]
pub enum TpmtRsaDecryptWCV {
    #[cfg(feature = "rsaes")]
    Rsaes(TpmsEmpty) = TpmAlgId::Rsaes as u16,
    #[cfg(feature = "oaep")]
    Oaep(TpmsEmpty) = TpmAlgId::Oaep as u16,
    Null = TpmAlgId::Null as u16,
}

#[cfg(feature = "rsa")]
impl TpmtRsaDecryptWCV {
    pub const fn marshalled_max_size() -> u16 {
        tpmt_rsa_decrypt_wcv_marshalled_max_size()
    }

    const fn marshalled_selector_size() -> u16 {
        TpmiAlgRsaDecryptWCV::marshalled_size()
    }

    fn marshalled_data_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;
        match self {
            #[cfg(feature = "rsaes")]
            Self::Rsaes(_) => {
                let details_size = match usize::try_from(tpms_empty_marshalled_size()) {
                    Ok(details_size) => details_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(details_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(feature = "oaep")]
            Self::Oaep(_) => {
                let details_size = match usize::try_from(tpms_empty_marshalled_size()) {
                    Ok(details_size) => details_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(details_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            Self::Null => (),
        };

        Ok(size)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let selector_size = match usize::try_from(Self::marshalled_selector_size()) {
            Ok(selector_size) => selector_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(selector_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let data_size = match self.marshalled_data_size() {
            Ok(data_size) => data_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(data_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = match self {
            #[cfg(feature = "rsaes")]
            Self::Rsaes(details) => {
                let selector = TpmAlgId::Rsaes as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = details.marshal(buf)?;

                buf
            },
            #[cfg(feature = "oaep")]
            Self::Oaep(details) => {
                let selector = TpmAlgId::Oaep as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = details.marshal(buf)?;

                buf
            },
            Self::Null => {
                let selector = TpmAlgId::Null as u16;
                let buf = marshal_u16(buf, selector)?;

                buf
            },
        };
        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_scheme) = match unmarshal_u16(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, r) = match unmarshalled_scheme {
            #[cfg(feature = "rsaes")]
            value if value == TpmAlgId::Rsaes as u16 => {
                let (buf, unmarshalled_details) = match TpmsEmpty::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Rsaes(unmarshalled_details))
            },
            #[cfg(feature = "oaep")]
            value if value == TpmAlgId::Oaep as u16 => {
                let (buf, unmarshalled_details) = match TpmsEmpty::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Oaep(unmarshalled_details))
            },
            value if value == TpmAlgId::Null as u16 => {
                (buf, Self::Null)
            },
            _ => {
                return Err(TpmErr::Rc(TpmRc::VALUE));
            },
        };

        Ok((buf, r))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

#[cfg(feature = "rsa")]
const fn tpmt_rsa_decrypt_wcv_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiAlgRsaDecryptWCV::marshalled_size();
    size += TpmuAsymScheme::marshalled_max_size();

    size
}

#[cfg(feature = "rsa")]
impl convert::From<&TpmtRsaDecryptWCV> for TpmiAlgRsaDecryptWCV {
    fn from(value: &TpmtRsaDecryptWCV) -> Self {
        match value {
            #[cfg(feature = "rsaes")]
            TpmtRsaDecryptWCV::Rsaes(_) => Self::Rsaes,
            #[cfg(feature = "oaep")]
            TpmtRsaDecryptWCV::Oaep(_) => Self::Oaep,
            TpmtRsaDecryptWCV::Null => Self::Null,
        }
    }
}

#[cfg(feature = "rsa")]
impl convert::From<TpmtRsaDecrypt> for TpmtRsaDecryptWCV {
    fn from(value: TpmtRsaDecrypt) -> Self {
        match value {
            #[cfg(feature = "rsaes")]
            TpmtRsaDecrypt::Rsaes(details) => Self::Rsaes(details),
            #[cfg(feature = "oaep")]
            TpmtRsaDecrypt::Oaep(details) => Self::Oaep(details),
            #[cfg(not(any(feature = "oaep", feature = "rsaes")))]
            _ => unreachable!(),
        }
    }
}

#[cfg(feature = "rsa")]
impl convert::TryFrom<TpmtRsaDecryptWCV> for TpmtRsaDecrypt {
    type Error = TpmErr;

    fn try_from(value: TpmtRsaDecryptWCV) -> Result<Self, TpmErr> {
        let result = match value {
            #[cfg(feature = "rsaes")]
            TpmtRsaDecryptWCV::Rsaes(details) => Self::Rsaes(details),
            #[cfg(feature = "oaep")]
            TpmtRsaDecryptWCV::Oaep(details) => Self::Oaep(details),
            _ => {
                return Err(TpmErr::Rc(TpmRc::VALUE));
            },
        };

        Ok(result)
    }
}

#[cfg(feature = "rsa")]
impl cmp::PartialEq<TpmtRsaDecrypt> for TpmtRsaDecryptWCV {
    fn eq(&self, other: &TpmtRsaDecrypt) -> bool {
        match self {
            #[cfg(feature = "rsaes")]
            Self::Rsaes(self_details) => {
                if let TpmtRsaDecrypt::Rsaes(other_details) = other {
                    self_details == other_details
                } else {
                    false
                }
            },
            #[cfg(feature = "oaep")]
            Self::Oaep(self_details) => {
                if let TpmtRsaDecrypt::Oaep(other_details) = other {
                    self_details == other_details
                } else {
                    false
                }
            },
            _ => false,
        }
    }
}

#[cfg(feature = "rsa")]
impl cmp::PartialEq<TpmtRsaDecryptWCV> for TpmtRsaDecrypt {
    fn eq(&self, other: &TpmtRsaDecryptWCV) -> bool {
        other.eq(self)
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 174, table 193, TPM2B_PUBLIC_KEY_RSA structure
#[cfg(feature = "rsa")]
#[derive(Debug, PartialEq)]
pub struct Tpm2bPublicKeyRsa<'a> {
    pub buffer: TpmBuffer<'a>,
}

#[cfg(feature = "rsa")]
impl<'a> Tpm2bPublicKeyRsa<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2b_public_key_rsa_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let size_size = mem::size_of::<u16>();
        size = match size.checked_add(size_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let buffer_size = self.buffer.len();
        size = match size.checked_add(buffer_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let marshalled_size = match u16::try_from(self.buffer.len()) {
            Ok(marshalled_size) => marshalled_size,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::SIZE));
            },
        };
        let buf = marshal_u16(buf, marshalled_size)?;

        let buf = marshal_bytes(buf, &self.buffer)?;

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_size) = match unmarshal_u16(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let buffer_size: u16 = unmarshalled_size;
        if buffer_size > limits.max_rsa_key_bytes {
            return Err(TpmErr::Rc(TpmRc::SIZE));
        }
        let buffer_size = match usize::try_from(buffer_size) {
            Ok(buffer_size) => buffer_size,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::INSUFFICIENT));
            },
        };
        let (unmarshalled_buffer, buf) = match split_slice_at(buf, buffer_size) {
            Ok((unmarshalled_buffer, buf)) => (unmarshalled_buffer, buf),
            Err(e) => {
                return Err(e);
            },
        };
        let unmarshalled_buffer = TpmBuffer::from(unmarshalled_buffer);

        Ok((buf, Self{buffer: unmarshalled_buffer}))
    }

    pub fn unmarshal(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2bPublicKeyRsa<'static>, TpmErr> {
        let buffer = copy_vec_from_slice(&self.buffer)?;
        let buffer = TpmBuffer::Owned(buffer);

        Ok(Tpm2bPublicKeyRsa {
            buffer,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2bPublicKeyRsa<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2bPublicKeyRsa<'static>, TpmErr> {
        let Self {
            buffer,
        } = self;

        let buffer = buffer.into_owned()?;

        Ok(Tpm2bPublicKeyRsa {
            buffer,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2bPublicKeyRsa<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

#[cfg(feature = "rsa")]
fn tpm2b_public_key_rsa_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    size += mem::size_of::<u16>() as u32;

    let buffer_size = limits.max_rsa_key_bytes as u32;
    size = size.checked_add(buffer_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 174, table 194, TPMI_RSA_KEY_BITS type
#[cfg(feature = "rsa")]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[cfg_attr(any(feature = "rsa1024", feature = "rsa16384", feature = "rsa2048", feature = "rsa3072", feature = "rsa4096", feature = "rsa8192"), repr(u16))]
pub enum TpmiRsaKeyBits {
    #[cfg(feature = "rsa1024")]
    Bits1024 = RsaKeyBits::Bits1024 as u16,
    #[cfg(feature = "rsa2048")]
    Bits2048 = RsaKeyBits::Bits2048 as u16,
    #[cfg(feature = "rsa3072")]
    Bits3072 = RsaKeyBits::Bits3072 as u16,
    #[cfg(feature = "rsa4096")]
    Bits4096 = RsaKeyBits::Bits4096 as u16,
    #[cfg(feature = "rsa8192")]
    Bits8192 = RsaKeyBits::Bits8192 as u16,
    #[cfg(feature = "rsa16384")]
    Bits16384 = RsaKeyBits::Bits16384 as u16,
}

#[cfg(feature = "rsa")]
impl TpmiRsaKeyBits {
    pub const fn marshalled_size() -> u16 {
        mem::size_of::<u16>() as u16
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u16(buf, *self as u16)
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u16(buf)?;
        let result = Self::try_from(value)?;
        Ok((buf, result))
    }
}

#[cfg(feature = "rsa")]
impl convert::TryFrom<u16> for TpmiRsaKeyBits {
    type Error = TpmErr;

    fn try_from(value: u16) -> Result<Self, TpmErr> {
        let result = match value {
            #[cfg(feature = "rsa1024")]
            value if value == Self::Bits1024 as u16 => Self::Bits1024,
            #[cfg(feature = "rsa2048")]
            value if value == Self::Bits2048 as u16 => Self::Bits2048,
            #[cfg(feature = "rsa3072")]
            value if value == Self::Bits3072 as u16 => Self::Bits3072,
            #[cfg(feature = "rsa4096")]
            value if value == Self::Bits4096 as u16 => Self::Bits4096,
            #[cfg(feature = "rsa8192")]
            value if value == Self::Bits8192 as u16 => Self::Bits8192,
            #[cfg(feature = "rsa16384")]
            value if value == Self::Bits16384 as u16 => Self::Bits16384,
            _ => {
                return Err(TpmErr::Rc(TpmRc::VALUE));
            },
        };

        Ok(result)
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 175, table 195, TPM2B_PRIVATE_KEY_RSA structure
#[cfg(feature = "rsa")]
#[derive(Debug, PartialEq)]
pub struct Tpm2bPrivateKeyRsa<'a> {
    pub buffer: TpmBuffer<'a>,
}

#[cfg(feature = "rsa")]
impl<'a> Tpm2bPrivateKeyRsa<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2b_private_key_rsa_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let size_size = mem::size_of::<u16>();
        size = match size.checked_add(size_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let buffer_size = self.buffer.len();
        size = match size.checked_add(buffer_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let marshalled_size = match u16::try_from(self.buffer.len()) {
            Ok(marshalled_size) => marshalled_size,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::SIZE));
            },
        };
        let buf = marshal_u16(buf, marshalled_size)?;

        let buf = marshal_bytes(buf, &self.buffer)?;

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_size) = match unmarshal_u16(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let buffer_size: u16 = unmarshalled_size;
        if buffer_size > limits.rsa_private_size {
            return Err(TpmErr::Rc(TpmRc::SIZE));
        }
        let buffer_size = match usize::try_from(buffer_size) {
            Ok(buffer_size) => buffer_size,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::INSUFFICIENT));
            },
        };
        let (unmarshalled_buffer, buf) = match split_slice_at(buf, buffer_size) {
            Ok((unmarshalled_buffer, buf)) => (unmarshalled_buffer, buf),
            Err(e) => {
                return Err(e);
            },
        };
        let unmarshalled_buffer = TpmBuffer::from(unmarshalled_buffer);

        Ok((buf, Self{buffer: unmarshalled_buffer}))
    }

    pub fn unmarshal(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2bPrivateKeyRsa<'static>, TpmErr> {
        let buffer = copy_vec_from_slice(&self.buffer)?;
        let buffer = TpmBuffer::Owned(buffer);

        Ok(Tpm2bPrivateKeyRsa {
            buffer,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2bPrivateKeyRsa<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2bPrivateKeyRsa<'static>, TpmErr> {
        let Self {
            buffer,
        } = self;

        let buffer = buffer.into_owned()?;

        Ok(Tpm2bPrivateKeyRsa {
            buffer,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2bPrivateKeyRsa<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

#[cfg(feature = "rsa")]
fn tpm2b_private_key_rsa_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    size += mem::size_of::<u16>() as u32;

    let buffer_size = limits.rsa_private_size as u32;
    size = size.checked_add(buffer_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 175, table 196, TPM2B_ECC_PARAMETER structure
#[cfg(feature = "ecc")]
#[derive(Debug, PartialEq)]
pub struct Tpm2bEccParameter<'a> {
    pub buffer: TpmBuffer<'a>,
}

#[cfg(feature = "ecc")]
impl<'a> Tpm2bEccParameter<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2b_ecc_parameter_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let size_size = mem::size_of::<u16>();
        size = match size.checked_add(size_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let buffer_size = self.buffer.len();
        size = match size.checked_add(buffer_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let marshalled_size = match u16::try_from(self.buffer.len()) {
            Ok(marshalled_size) => marshalled_size,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::SIZE));
            },
        };
        let buf = marshal_u16(buf, marshalled_size)?;

        let buf = marshal_bytes(buf, &self.buffer)?;

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_size) = match unmarshal_u16(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let buffer_size: u16 = unmarshalled_size;
        let v0 = match limits.max_ecc_key_bytes() {
            Ok(v) => v,
            Err(_) => {
                debug_assert!(false, "Unexpected runtime constant evaluation failure");
                return Err(TpmErr::InternalErr);
            },
        };
        if buffer_size > v0 {
            return Err(TpmErr::Rc(TpmRc::SIZE));
        }
        let buffer_size = match usize::try_from(buffer_size) {
            Ok(buffer_size) => buffer_size,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::INSUFFICIENT));
            },
        };
        let (unmarshalled_buffer, buf) = match split_slice_at(buf, buffer_size) {
            Ok((unmarshalled_buffer, buf)) => (unmarshalled_buffer, buf),
            Err(e) => {
                return Err(e);
            },
        };
        let unmarshalled_buffer = TpmBuffer::from(unmarshalled_buffer);

        Ok((buf, Self{buffer: unmarshalled_buffer}))
    }

    pub fn unmarshal(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2bEccParameter<'static>, TpmErr> {
        let buffer = copy_vec_from_slice(&self.buffer)?;
        let buffer = TpmBuffer::Owned(buffer);

        Ok(Tpm2bEccParameter {
            buffer,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2bEccParameter<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2bEccParameter<'static>, TpmErr> {
        let Self {
            buffer,
        } = self;

        let buffer = buffer.into_owned()?;

        Ok(Tpm2bEccParameter {
            buffer,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2bEccParameter<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

#[cfg(feature = "ecc")]
fn tpm2b_ecc_parameter_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    size += mem::size_of::<u16>() as u32;

    let v0 = match limits.max_ecc_key_bytes() {
        Ok(v) => v,
        Err(_) => {
            debug_assert!(false, "Unexpected runtime constant evaluation failure");
            return Err(());
        },
    };
    let buffer_size = v0 as u32;
    size = size.checked_add(buffer_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 175, table 197, TPMS_ECC_POINT structure
#[cfg(feature = "ecc")]
#[derive(Debug, PartialEq)]
pub struct TpmsEccPoint<'a> {
    pub x: Tpm2bEccParameter<'a>,
    pub y: Tpm2bEccParameter<'a>,
}

#[cfg(feature = "ecc")]
impl<'a> TpmsEccPoint<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpms_ecc_point_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let x_size = match self.x.marshalled_size() {
            Ok(x_size) => x_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(x_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let y_size = match self.y.marshalled_size() {
            Ok(y_size) => y_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(y_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.x.marshal(buf)?;

        let buf = self.y.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_x) = match Tpm2bEccParameter::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_y) = match Tpm2bEccParameter::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{x: unmarshalled_x, y: unmarshalled_y}))
    }

    pub fn unmarshal(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<TpmsEccPoint<'static>, TpmErr> {
        Ok(TpmsEccPoint {
            x: self.x.try_clone_intern()?,
            y: self.y.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<TpmsEccPoint<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<TpmsEccPoint<'static>, TpmErr> {
        let Self {
            x,
            y,
        } = self;

        let x = x.into_bufs_owner_intern()?;
        let y = y.into_bufs_owner_intern()?;

        Ok(TpmsEccPoint {
            x,
            y,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<TpmsEccPoint<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

#[cfg(feature = "ecc")]
fn tpms_ecc_point_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    let x_size = match tpm2b_ecc_parameter_marshalled_max_size(limits) {
        Ok(x_size) => x_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(x_size).ok_or(())?;

    let y_size = match tpm2b_ecc_parameter_marshalled_max_size(limits) {
        Ok(y_size) => y_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(y_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 175, table 198, TPM2B_ECC_POINT structure
#[cfg(feature = "ecc")]
#[derive(Debug, PartialEq)]
pub struct Tpm2bEccPoint<'a> {
    pub point: TpmsEccPoint<'a>,
}

#[cfg(feature = "ecc")]
impl<'a> Tpm2bEccPoint<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2b_ecc_point_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let size_size = mem::size_of::<u16>();
        size = match size.checked_add(size_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let point_size = match self.point.marshalled_size() {
            Ok(point_size) => point_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(point_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let mut marshalled_size: usize = 0;

        let point_size = match self.point.marshalled_size() {
            Ok(point_size) => point_size,
            Err(_) => {
                return Err(TpmErr::InternalErr);
            },
        };
        marshalled_size = match marshalled_size.checked_add(point_size) {
            Some(marshalled_size) => marshalled_size,
            None => {
                return Err(TpmErr::InternalErr);
            },
        };

        let marshalled_size = match u16::try_from(marshalled_size) {
            Ok(marshalled_size) => marshalled_size,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::SIZE));
            },
        };
        let buf = marshal_u16(buf, marshalled_size)?;

        let buf = self.point.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_size) = match unmarshal_u16(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let unmarshalled_size = match usize::try_from(unmarshalled_size) {
            Ok(unmarshalled_size) => unmarshalled_size,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::SIZE));
            },
        };
        if unmarshalled_size == 0usize {
            return Err(TpmErr::Rc(TpmRc::SIZE));
        }
        let buf_len_at_size = buf.len();

        let (buf, unmarshalled_point) = match TpmsEccPoint::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        if unmarshalled_size != buf_len_at_size - buf.len() {
            return Err(TpmErr::Rc(TpmRc::SIZE));
        }

        Ok((buf, Self{point: unmarshalled_point}))
    }

    pub fn unmarshal(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2bEccPoint<'static>, TpmErr> {
        Ok(Tpm2bEccPoint {
            point: self.point.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2bEccPoint<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2bEccPoint<'static>, TpmErr> {
        let Self {
            point,
        } = self;

        let point = point.into_bufs_owner_intern()?;

        Ok(Tpm2bEccPoint {
            point,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2bEccPoint<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

#[cfg(feature = "ecc")]
fn tpm2b_ecc_point_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    size += mem::size_of::<u16>() as u32;

    let point_size = match tpms_ecc_point_marshalled_max_size(limits) {
        Ok(point_size) => point_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(point_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 176, table 199, TPMI_ALG_ECC_SCHEME type (without conditional values)
#[cfg(feature = "ecc")]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[cfg_attr(any(feature = "ecdaa", feature = "ecdh", feature = "ecdsa", feature = "ecmqv", feature = "ecschnorr", feature = "eddsa", feature = "eddsa_ph", feature = "sm2"), repr(u16))]
pub enum TpmiAlgEccScheme {
    #[cfg(feature = "ecdsa")]
    Ecdsa = TpmAlgId::Ecdsa as u16,
    #[cfg(feature = "ecdaa")]
    Ecdaa = TpmAlgId::Ecdaa as u16,
    #[cfg(feature = "sm2")]
    Sm2 = TpmAlgId::Sm2 as u16,
    #[cfg(feature = "ecschnorr")]
    Ecschnorr = TpmAlgId::Ecschnorr as u16,
    #[cfg(feature = "eddsa")]
    Eddsa = TpmAlgId::Eddsa as u16,
    #[cfg(feature = "eddsa_ph")]
    EddsaPh = TpmAlgId::EddsaPh as u16,
    #[cfg(feature = "ecdh")]
    Ecdh = TpmAlgId::Ecdh as u16,
    #[cfg(feature = "ecmqv")]
    Ecmqv = TpmAlgId::Ecmqv as u16,
}

#[cfg(feature = "ecc")]
impl TpmiAlgEccScheme {
    pub const fn marshalled_size() -> u16 {
        mem::size_of::<u16>() as u16
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u16(buf, *self as u16)
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u16(buf)?;
        let result = Self::try_from(value)?;
        Ok((buf, result))
    }
}

#[cfg(feature = "ecc")]
impl convert::TryFrom<u16> for TpmiAlgEccScheme {
    type Error = TpmErr;

    fn try_from(value: u16) -> Result<Self, TpmErr> {
        let result = match value {
            #[cfg(feature = "ecdsa")]
            value if value == Self::Ecdsa as u16 => Self::Ecdsa,
            #[cfg(feature = "ecdaa")]
            value if value == Self::Ecdaa as u16 => Self::Ecdaa,
            #[cfg(feature = "sm2")]
            value if value == Self::Sm2 as u16 => Self::Sm2,
            #[cfg(feature = "ecschnorr")]
            value if value == Self::Ecschnorr as u16 => Self::Ecschnorr,
            #[cfg(feature = "eddsa")]
            value if value == Self::Eddsa as u16 => Self::Eddsa,
            #[cfg(feature = "eddsa_ph")]
            value if value == Self::EddsaPh as u16 => Self::EddsaPh,
            #[cfg(feature = "ecdh")]
            value if value == Self::Ecdh as u16 => Self::Ecdh,
            #[cfg(feature = "ecmqv")]
            value if value == Self::Ecmqv as u16 => Self::Ecmqv,
            _ => {
                return Err(TpmErr::Rc(TpmRc::SCHEME));
            },
        };

        Ok(result)
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 176, table 199, TPMI_ALG_ECC_SCHEME type (with conditional values)
#[cfg(feature = "ecc")]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u16)]
pub enum TpmiAlgEccSchemeWCV {
    #[cfg(feature = "ecdsa")]
    Ecdsa = TpmAlgId::Ecdsa as u16,
    #[cfg(feature = "ecdaa")]
    Ecdaa = TpmAlgId::Ecdaa as u16,
    #[cfg(feature = "sm2")]
    Sm2 = TpmAlgId::Sm2 as u16,
    #[cfg(feature = "ecschnorr")]
    Ecschnorr = TpmAlgId::Ecschnorr as u16,
    #[cfg(feature = "eddsa")]
    Eddsa = TpmAlgId::Eddsa as u16,
    #[cfg(feature = "eddsa_ph")]
    EddsaPh = TpmAlgId::EddsaPh as u16,
    #[cfg(feature = "ecdh")]
    Ecdh = TpmAlgId::Ecdh as u16,
    #[cfg(feature = "ecmqv")]
    Ecmqv = TpmAlgId::Ecmqv as u16,
    Null = TpmAlgId::Null as u16,
}

#[cfg(feature = "ecc")]
impl TpmiAlgEccSchemeWCV {
    pub const fn marshalled_size() -> u16 {
        mem::size_of::<u16>() as u16
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u16(buf, *self as u16)
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u16(buf)?;
        let result = Self::try_from(value)?;
        Ok((buf, result))
    }
}

#[cfg(feature = "ecc")]
impl convert::TryFrom<u16> for TpmiAlgEccSchemeWCV {
    type Error = TpmErr;

    fn try_from(value: u16) -> Result<Self, TpmErr> {
        let result = match value {
            #[cfg(feature = "ecdsa")]
            value if value == Self::Ecdsa as u16 => Self::Ecdsa,
            #[cfg(feature = "ecdaa")]
            value if value == Self::Ecdaa as u16 => Self::Ecdaa,
            #[cfg(feature = "sm2")]
            value if value == Self::Sm2 as u16 => Self::Sm2,
            #[cfg(feature = "ecschnorr")]
            value if value == Self::Ecschnorr as u16 => Self::Ecschnorr,
            #[cfg(feature = "eddsa")]
            value if value == Self::Eddsa as u16 => Self::Eddsa,
            #[cfg(feature = "eddsa_ph")]
            value if value == Self::EddsaPh as u16 => Self::EddsaPh,
            #[cfg(feature = "ecdh")]
            value if value == Self::Ecdh as u16 => Self::Ecdh,
            #[cfg(feature = "ecmqv")]
            value if value == Self::Ecmqv as u16 => Self::Ecmqv,
            value if value == Self::Null as u16 => Self::Null,
            _ => {
                return Err(TpmErr::Rc(TpmRc::SCHEME));
            },
        };

        Ok(result)
    }
}

#[cfg(feature = "ecc")]
impl convert::From<TpmiAlgEccScheme> for TpmiAlgEccSchemeWCV {
    fn from(value: TpmiAlgEccScheme) -> Self {
        match value {
            #[cfg(feature = "ecdsa")]
            TpmiAlgEccScheme::Ecdsa => Self::Ecdsa,
            #[cfg(feature = "ecdaa")]
            TpmiAlgEccScheme::Ecdaa => Self::Ecdaa,
            #[cfg(feature = "sm2")]
            TpmiAlgEccScheme::Sm2 => Self::Sm2,
            #[cfg(feature = "ecschnorr")]
            TpmiAlgEccScheme::Ecschnorr => Self::Ecschnorr,
            #[cfg(feature = "eddsa")]
            TpmiAlgEccScheme::Eddsa => Self::Eddsa,
            #[cfg(feature = "eddsa_ph")]
            TpmiAlgEccScheme::EddsaPh => Self::EddsaPh,
            #[cfg(feature = "ecdh")]
            TpmiAlgEccScheme::Ecdh => Self::Ecdh,
            #[cfg(feature = "ecmqv")]
            TpmiAlgEccScheme::Ecmqv => Self::Ecmqv,
        }
    }
}

#[cfg(feature = "ecc")]
impl convert::TryFrom<TpmiAlgEccSchemeWCV> for TpmiAlgEccScheme {
    type Error = TpmErr;

    fn try_from(value: TpmiAlgEccSchemeWCV) -> Result<Self, TpmErr> {
        let result = match value {
            #[cfg(feature = "ecdsa")]
            TpmiAlgEccSchemeWCV::Ecdsa => Self::Ecdsa,
            #[cfg(feature = "ecdaa")]
            TpmiAlgEccSchemeWCV::Ecdaa => Self::Ecdaa,
            #[cfg(feature = "sm2")]
            TpmiAlgEccSchemeWCV::Sm2 => Self::Sm2,
            #[cfg(feature = "ecschnorr")]
            TpmiAlgEccSchemeWCV::Ecschnorr => Self::Ecschnorr,
            #[cfg(feature = "eddsa")]
            TpmiAlgEccSchemeWCV::Eddsa => Self::Eddsa,
            #[cfg(feature = "eddsa_ph")]
            TpmiAlgEccSchemeWCV::EddsaPh => Self::EddsaPh,
            #[cfg(feature = "ecdh")]
            TpmiAlgEccSchemeWCV::Ecdh => Self::Ecdh,
            #[cfg(feature = "ecmqv")]
            TpmiAlgEccSchemeWCV::Ecmqv => Self::Ecmqv,
            TpmiAlgEccSchemeWCV::Null => {
                return Err(TpmErr::Rc(TpmRc::SCHEME));
            },
        };
        Ok(result)
    }
}

#[cfg(feature = "ecc")]
impl cmp::PartialEq<TpmiAlgEccScheme> for TpmiAlgEccSchemeWCV {
    fn eq(&self, other: &TpmiAlgEccScheme) -> bool {
        *self as u16 == *other as u16
    }
}

#[cfg(feature = "ecc")]
impl cmp::PartialEq<TpmiAlgEccSchemeWCV> for TpmiAlgEccScheme {
    fn eq(&self, other: &TpmiAlgEccSchemeWCV) -> bool {
        other.eq(self)
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 176, table 200, TPMI_ECC_CURVE type (without conditional values)
#[cfg(feature = "ecc")]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[cfg_attr(any(feature = "ecc_bn_p256", feature = "ecc_bn_p638", feature = "ecc_bp_p256_r1", feature = "ecc_bp_p384_r1", feature = "ecc_bp_p512_r1", feature = "ecc_curve_25519", feature = "ecc_curve_448", feature = "ecc_nist_p192", feature = "ecc_nist_p224", feature = "ecc_nist_p256", feature = "ecc_nist_p384", feature = "ecc_nist_p521", feature = "ecc_sm2_p256"), repr(u16))]
pub enum TpmiEccCurve {
    #[cfg(feature = "ecc_nist_p192")]
    NistP192 = TpmEccCurve::NistP192 as u16,
    #[cfg(feature = "ecc_nist_p224")]
    NistP224 = TpmEccCurve::NistP224 as u16,
    #[cfg(feature = "ecc_nist_p256")]
    NistP256 = TpmEccCurve::NistP256 as u16,
    #[cfg(feature = "ecc_nist_p384")]
    NistP384 = TpmEccCurve::NistP384 as u16,
    #[cfg(feature = "ecc_nist_p521")]
    NistP521 = TpmEccCurve::NistP521 as u16,
    #[cfg(feature = "ecc_bn_p256")]
    BnP256 = TpmEccCurve::BnP256 as u16,
    #[cfg(feature = "ecc_bn_p638")]
    BnP638 = TpmEccCurve::BnP638 as u16,
    #[cfg(feature = "ecc_sm2_p256")]
    Sm2P256 = TpmEccCurve::Sm2P256 as u16,
    #[cfg(feature = "ecc_bp_p256_r1")]
    BpP256R1 = TpmEccCurve::BpP256R1 as u16,
    #[cfg(feature = "ecc_bp_p384_r1")]
    BpP384R1 = TpmEccCurve::BpP384R1 as u16,
    #[cfg(feature = "ecc_bp_p512_r1")]
    BpP512R1 = TpmEccCurve::BpP512R1 as u16,
    #[cfg(feature = "ecc_curve_25519")]
    Curve25519 = TpmEccCurve::Curve25519 as u16,
    #[cfg(feature = "ecc_curve_448")]
    Curve448 = TpmEccCurve::Curve448 as u16,
}

#[cfg(feature = "ecc")]
impl TpmiEccCurve {
    pub const fn marshalled_size() -> u16 {
        mem::size_of::<u16>() as u16
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u16(buf, *self as u16)
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u16(buf)?;
        let result = Self::try_from(value)?;
        Ok((buf, result))
    }
}

#[cfg(feature = "ecc")]
impl convert::TryFrom<u16> for TpmiEccCurve {
    type Error = TpmErr;

    fn try_from(value: u16) -> Result<Self, TpmErr> {
        let result = match value {
            #[cfg(feature = "ecc_nist_p192")]
            value if value == Self::NistP192 as u16 => Self::NistP192,
            #[cfg(feature = "ecc_nist_p224")]
            value if value == Self::NistP224 as u16 => Self::NistP224,
            #[cfg(feature = "ecc_nist_p256")]
            value if value == Self::NistP256 as u16 => Self::NistP256,
            #[cfg(feature = "ecc_nist_p384")]
            value if value == Self::NistP384 as u16 => Self::NistP384,
            #[cfg(feature = "ecc_nist_p521")]
            value if value == Self::NistP521 as u16 => Self::NistP521,
            #[cfg(feature = "ecc_bn_p256")]
            value if value == Self::BnP256 as u16 => Self::BnP256,
            #[cfg(feature = "ecc_bn_p638")]
            value if value == Self::BnP638 as u16 => Self::BnP638,
            #[cfg(feature = "ecc_sm2_p256")]
            value if value == Self::Sm2P256 as u16 => Self::Sm2P256,
            #[cfg(feature = "ecc_bp_p256_r1")]
            value if value == Self::BpP256R1 as u16 => Self::BpP256R1,
            #[cfg(feature = "ecc_bp_p384_r1")]
            value if value == Self::BpP384R1 as u16 => Self::BpP384R1,
            #[cfg(feature = "ecc_bp_p512_r1")]
            value if value == Self::BpP512R1 as u16 => Self::BpP512R1,
            #[cfg(feature = "ecc_curve_25519")]
            value if value == Self::Curve25519 as u16 => Self::Curve25519,
            #[cfg(feature = "ecc_curve_448")]
            value if value == Self::Curve448 as u16 => Self::Curve448,
            _ => {
                return Err(TpmErr::Rc(TpmRc::CURVE));
            },
        };

        Ok(result)
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 176, table 200, TPMI_ECC_CURVE type (with conditional values)
#[cfg(feature = "ecc")]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u16)]
pub enum TpmiEccCurveWCV {
    #[cfg(feature = "ecc_nist_p192")]
    NistP192 = TpmEccCurve::NistP192 as u16,
    #[cfg(feature = "ecc_nist_p224")]
    NistP224 = TpmEccCurve::NistP224 as u16,
    #[cfg(feature = "ecc_nist_p256")]
    NistP256 = TpmEccCurve::NistP256 as u16,
    #[cfg(feature = "ecc_nist_p384")]
    NistP384 = TpmEccCurve::NistP384 as u16,
    #[cfg(feature = "ecc_nist_p521")]
    NistP521 = TpmEccCurve::NistP521 as u16,
    #[cfg(feature = "ecc_bn_p256")]
    BnP256 = TpmEccCurve::BnP256 as u16,
    #[cfg(feature = "ecc_bn_p638")]
    BnP638 = TpmEccCurve::BnP638 as u16,
    #[cfg(feature = "ecc_sm2_p256")]
    Sm2P256 = TpmEccCurve::Sm2P256 as u16,
    #[cfg(feature = "ecc_bp_p256_r1")]
    BpP256R1 = TpmEccCurve::BpP256R1 as u16,
    #[cfg(feature = "ecc_bp_p384_r1")]
    BpP384R1 = TpmEccCurve::BpP384R1 as u16,
    #[cfg(feature = "ecc_bp_p512_r1")]
    BpP512R1 = TpmEccCurve::BpP512R1 as u16,
    #[cfg(feature = "ecc_curve_25519")]
    Curve25519 = TpmEccCurve::Curve25519 as u16,
    #[cfg(feature = "ecc_curve_448")]
    Curve448 = TpmEccCurve::Curve448 as u16,
    None = TpmEccCurve::None as u16,
}

#[cfg(feature = "ecc")]
impl TpmiEccCurveWCV {
    pub const fn marshalled_size() -> u16 {
        mem::size_of::<u16>() as u16
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u16(buf, *self as u16)
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u16(buf)?;
        let result = Self::try_from(value)?;
        Ok((buf, result))
    }
}

#[cfg(feature = "ecc")]
impl convert::TryFrom<u16> for TpmiEccCurveWCV {
    type Error = TpmErr;

    fn try_from(value: u16) -> Result<Self, TpmErr> {
        let result = match value {
            #[cfg(feature = "ecc_nist_p192")]
            value if value == Self::NistP192 as u16 => Self::NistP192,
            #[cfg(feature = "ecc_nist_p224")]
            value if value == Self::NistP224 as u16 => Self::NistP224,
            #[cfg(feature = "ecc_nist_p256")]
            value if value == Self::NistP256 as u16 => Self::NistP256,
            #[cfg(feature = "ecc_nist_p384")]
            value if value == Self::NistP384 as u16 => Self::NistP384,
            #[cfg(feature = "ecc_nist_p521")]
            value if value == Self::NistP521 as u16 => Self::NistP521,
            #[cfg(feature = "ecc_bn_p256")]
            value if value == Self::BnP256 as u16 => Self::BnP256,
            #[cfg(feature = "ecc_bn_p638")]
            value if value == Self::BnP638 as u16 => Self::BnP638,
            #[cfg(feature = "ecc_sm2_p256")]
            value if value == Self::Sm2P256 as u16 => Self::Sm2P256,
            #[cfg(feature = "ecc_bp_p256_r1")]
            value if value == Self::BpP256R1 as u16 => Self::BpP256R1,
            #[cfg(feature = "ecc_bp_p384_r1")]
            value if value == Self::BpP384R1 as u16 => Self::BpP384R1,
            #[cfg(feature = "ecc_bp_p512_r1")]
            value if value == Self::BpP512R1 as u16 => Self::BpP512R1,
            #[cfg(feature = "ecc_curve_25519")]
            value if value == Self::Curve25519 as u16 => Self::Curve25519,
            #[cfg(feature = "ecc_curve_448")]
            value if value == Self::Curve448 as u16 => Self::Curve448,
            value if value == Self::None as u16 => Self::None,
            _ => {
                return Err(TpmErr::Rc(TpmRc::CURVE));
            },
        };

        Ok(result)
    }
}

#[cfg(feature = "ecc")]
impl convert::From<TpmiEccCurve> for TpmiEccCurveWCV {
    fn from(value: TpmiEccCurve) -> Self {
        match value {
            #[cfg(feature = "ecc_nist_p192")]
            TpmiEccCurve::NistP192 => Self::NistP192,
            #[cfg(feature = "ecc_nist_p224")]
            TpmiEccCurve::NistP224 => Self::NistP224,
            #[cfg(feature = "ecc_nist_p256")]
            TpmiEccCurve::NistP256 => Self::NistP256,
            #[cfg(feature = "ecc_nist_p384")]
            TpmiEccCurve::NistP384 => Self::NistP384,
            #[cfg(feature = "ecc_nist_p521")]
            TpmiEccCurve::NistP521 => Self::NistP521,
            #[cfg(feature = "ecc_bn_p256")]
            TpmiEccCurve::BnP256 => Self::BnP256,
            #[cfg(feature = "ecc_bn_p638")]
            TpmiEccCurve::BnP638 => Self::BnP638,
            #[cfg(feature = "ecc_sm2_p256")]
            TpmiEccCurve::Sm2P256 => Self::Sm2P256,
            #[cfg(feature = "ecc_bp_p256_r1")]
            TpmiEccCurve::BpP256R1 => Self::BpP256R1,
            #[cfg(feature = "ecc_bp_p384_r1")]
            TpmiEccCurve::BpP384R1 => Self::BpP384R1,
            #[cfg(feature = "ecc_bp_p512_r1")]
            TpmiEccCurve::BpP512R1 => Self::BpP512R1,
            #[cfg(feature = "ecc_curve_25519")]
            TpmiEccCurve::Curve25519 => Self::Curve25519,
            #[cfg(feature = "ecc_curve_448")]
            TpmiEccCurve::Curve448 => Self::Curve448,
        }
    }
}

#[cfg(feature = "ecc")]
impl convert::TryFrom<TpmiEccCurveWCV> for TpmiEccCurve {
    type Error = TpmErr;

    fn try_from(value: TpmiEccCurveWCV) -> Result<Self, TpmErr> {
        let result = match value {
            #[cfg(feature = "ecc_nist_p192")]
            TpmiEccCurveWCV::NistP192 => Self::NistP192,
            #[cfg(feature = "ecc_nist_p224")]
            TpmiEccCurveWCV::NistP224 => Self::NistP224,
            #[cfg(feature = "ecc_nist_p256")]
            TpmiEccCurveWCV::NistP256 => Self::NistP256,
            #[cfg(feature = "ecc_nist_p384")]
            TpmiEccCurveWCV::NistP384 => Self::NistP384,
            #[cfg(feature = "ecc_nist_p521")]
            TpmiEccCurveWCV::NistP521 => Self::NistP521,
            #[cfg(feature = "ecc_bn_p256")]
            TpmiEccCurveWCV::BnP256 => Self::BnP256,
            #[cfg(feature = "ecc_bn_p638")]
            TpmiEccCurveWCV::BnP638 => Self::BnP638,
            #[cfg(feature = "ecc_sm2_p256")]
            TpmiEccCurveWCV::Sm2P256 => Self::Sm2P256,
            #[cfg(feature = "ecc_bp_p256_r1")]
            TpmiEccCurveWCV::BpP256R1 => Self::BpP256R1,
            #[cfg(feature = "ecc_bp_p384_r1")]
            TpmiEccCurveWCV::BpP384R1 => Self::BpP384R1,
            #[cfg(feature = "ecc_bp_p512_r1")]
            TpmiEccCurveWCV::BpP512R1 => Self::BpP512R1,
            #[cfg(feature = "ecc_curve_25519")]
            TpmiEccCurveWCV::Curve25519 => Self::Curve25519,
            #[cfg(feature = "ecc_curve_448")]
            TpmiEccCurveWCV::Curve448 => Self::Curve448,
            TpmiEccCurveWCV::None => {
                return Err(TpmErr::Rc(TpmRc::CURVE));
            },
        };
        Ok(result)
    }
}

#[cfg(feature = "ecc")]
impl cmp::PartialEq<TpmiEccCurve> for TpmiEccCurveWCV {
    fn eq(&self, other: &TpmiEccCurve) -> bool {
        *self as u16 == *other as u16
    }
}

#[cfg(feature = "ecc")]
impl cmp::PartialEq<TpmiEccCurveWCV> for TpmiEccCurve {
    fn eq(&self, other: &TpmiEccCurveWCV) -> bool {
        other.eq(self)
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 176, table 201, TPMT_ECC_SCHEME structure (without conditional values)
#[cfg(feature = "ecc")]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[cfg_attr(any(feature = "ecdaa", feature = "ecdh", feature = "ecdsa", feature = "ecmqv", feature = "ecschnorr", feature = "eddsa", feature = "eddsa_ph", feature = "sm2"), repr(u16))]
pub enum TpmtEccScheme {
    #[cfg(feature = "ecdsa")]
    Ecdsa(TpmsSchemeHash) = TpmAlgId::Ecdsa as u16,
    #[cfg(feature = "ecdaa")]
    Ecdaa(TpmsSchemeEcdaa) = TpmAlgId::Ecdaa as u16,
    #[cfg(feature = "sm2")]
    Sm2(TpmsSchemeHash) = TpmAlgId::Sm2 as u16,
    #[cfg(feature = "ecschnorr")]
    Ecschnorr(TpmsSchemeHash) = TpmAlgId::Ecschnorr as u16,
    #[cfg(feature = "eddsa")]
    Eddsa(TpmsSchemeHash) = TpmAlgId::Eddsa as u16,
    #[cfg(feature = "eddsa_ph")]
    EddsaPh(TpmsSchemeHash) = TpmAlgId::EddsaPh as u16,
    #[cfg(feature = "ecdh")]
    Ecdh(TpmsSchemeHash) = TpmAlgId::Ecdh as u16,
    #[cfg(feature = "ecmqv")]
    Ecmqv(TpmsSchemeHash) = TpmAlgId::Ecmqv as u16,
}

#[cfg(feature = "ecc")]
impl TpmtEccScheme {
    pub const fn marshalled_max_size() -> u16 {
        tpmt_ecc_scheme_marshalled_max_size()
    }

    const fn marshalled_selector_size() -> u16 {
        TpmiAlgEccScheme::marshalled_size()
    }

    fn marshalled_data_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;
        match self {
            #[cfg(feature = "ecdsa")]
            Self::Ecdsa(_) => {
                let details_size = match usize::try_from(tpms_scheme_hash_marshalled_size()) {
                    Ok(details_size) => details_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(details_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(feature = "ecdaa")]
            Self::Ecdaa(_) => {
                let details_size = match usize::try_from(tpms_scheme_ecdaa_marshalled_size()) {
                    Ok(details_size) => details_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(details_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(feature = "sm2")]
            Self::Sm2(_) => {
                let details_size = match usize::try_from(tpms_scheme_hash_marshalled_size()) {
                    Ok(details_size) => details_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(details_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(feature = "ecschnorr")]
            Self::Ecschnorr(_) => {
                let details_size = match usize::try_from(tpms_scheme_hash_marshalled_size()) {
                    Ok(details_size) => details_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(details_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(feature = "eddsa")]
            Self::Eddsa(_) => {
                let details_size = match usize::try_from(tpms_scheme_hash_marshalled_size()) {
                    Ok(details_size) => details_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(details_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(feature = "eddsa_ph")]
            Self::EddsaPh(_) => {
                let details_size = match usize::try_from(tpms_scheme_hash_marshalled_size()) {
                    Ok(details_size) => details_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(details_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(feature = "ecdh")]
            Self::Ecdh(_) => {
                let details_size = match usize::try_from(tpms_scheme_hash_marshalled_size()) {
                    Ok(details_size) => details_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(details_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(feature = "ecmqv")]
            Self::Ecmqv(_) => {
                let details_size = match usize::try_from(tpms_scheme_hash_marshalled_size()) {
                    Ok(details_size) => details_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(details_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(not(any(feature = "ecdaa", feature = "ecdh", feature = "ecdsa", feature = "ecmqv", feature = "ecschnorr", feature = "eddsa", feature = "eddsa_ph", feature = "sm2")))]
            _ => unreachable!(),
        };

        Ok(size)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let selector_size = match usize::try_from(Self::marshalled_selector_size()) {
            Ok(selector_size) => selector_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(selector_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let data_size = match self.marshalled_data_size() {
            Ok(data_size) => data_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(data_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = match self {
            #[cfg(feature = "ecdsa")]
            Self::Ecdsa(details) => {
                let selector = TpmAlgId::Ecdsa as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = details.marshal(buf)?;

                buf
            },
            #[cfg(feature = "ecdaa")]
            Self::Ecdaa(details) => {
                let selector = TpmAlgId::Ecdaa as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = details.marshal(buf)?;

                buf
            },
            #[cfg(feature = "sm2")]
            Self::Sm2(details) => {
                let selector = TpmAlgId::Sm2 as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = details.marshal(buf)?;

                buf
            },
            #[cfg(feature = "ecschnorr")]
            Self::Ecschnorr(details) => {
                let selector = TpmAlgId::Ecschnorr as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = details.marshal(buf)?;

                buf
            },
            #[cfg(feature = "eddsa")]
            Self::Eddsa(details) => {
                let selector = TpmAlgId::Eddsa as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = details.marshal(buf)?;

                buf
            },
            #[cfg(feature = "eddsa_ph")]
            Self::EddsaPh(details) => {
                let selector = TpmAlgId::EddsaPh as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = details.marshal(buf)?;

                buf
            },
            #[cfg(feature = "ecdh")]
            Self::Ecdh(details) => {
                let selector = TpmAlgId::Ecdh as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = details.marshal(buf)?;

                buf
            },
            #[cfg(feature = "ecmqv")]
            Self::Ecmqv(details) => {
                let selector = TpmAlgId::Ecmqv as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = details.marshal(buf)?;

                buf
            },
            #[cfg(not(any(feature = "ecdaa", feature = "ecdh", feature = "ecdsa", feature = "ecmqv", feature = "ecschnorr", feature = "eddsa", feature = "eddsa_ph", feature = "sm2")))]
            _ => unreachable!(),
        };
        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_scheme) = match unmarshal_u16(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, r) = match unmarshalled_scheme {
            #[cfg(feature = "ecdsa")]
            value if value == TpmAlgId::Ecdsa as u16 => {
                let (buf, unmarshalled_details) = match TpmsSchemeHash::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Ecdsa(unmarshalled_details))
            },
            #[cfg(feature = "ecdaa")]
            value if value == TpmAlgId::Ecdaa as u16 => {
                let (buf, unmarshalled_details) = match TpmsSchemeEcdaa::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Ecdaa(unmarshalled_details))
            },
            #[cfg(feature = "sm2")]
            value if value == TpmAlgId::Sm2 as u16 => {
                let (buf, unmarshalled_details) = match TpmsSchemeHash::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Sm2(unmarshalled_details))
            },
            #[cfg(feature = "ecschnorr")]
            value if value == TpmAlgId::Ecschnorr as u16 => {
                let (buf, unmarshalled_details) = match TpmsSchemeHash::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Ecschnorr(unmarshalled_details))
            },
            #[cfg(feature = "eddsa")]
            value if value == TpmAlgId::Eddsa as u16 => {
                let (buf, unmarshalled_details) = match TpmsSchemeHash::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Eddsa(unmarshalled_details))
            },
            #[cfg(feature = "eddsa_ph")]
            value if value == TpmAlgId::EddsaPh as u16 => {
                let (buf, unmarshalled_details) = match TpmsSchemeHash::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::EddsaPh(unmarshalled_details))
            },
            #[cfg(feature = "ecdh")]
            value if value == TpmAlgId::Ecdh as u16 => {
                let (buf, unmarshalled_details) = match TpmsSchemeHash::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Ecdh(unmarshalled_details))
            },
            #[cfg(feature = "ecmqv")]
            value if value == TpmAlgId::Ecmqv as u16 => {
                let (buf, unmarshalled_details) = match TpmsSchemeHash::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Ecmqv(unmarshalled_details))
            },
            _ => {
                return Err(TpmErr::Rc(TpmRc::SCHEME));
            },
        };

        Ok((buf, r))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

#[cfg(feature = "ecc")]
const fn tpmt_ecc_scheme_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiAlgEccScheme::marshalled_size();
    size += TpmuAsymScheme::marshalled_max_size();

    size
}

#[cfg(feature = "ecc")]
impl convert::From<&TpmtEccScheme> for TpmiAlgEccScheme {
    fn from(value: &TpmtEccScheme) -> Self {
        match value {
            #[cfg(feature = "ecdsa")]
            TpmtEccScheme::Ecdsa(_) => Self::Ecdsa,
            #[cfg(feature = "ecdaa")]
            TpmtEccScheme::Ecdaa(_) => Self::Ecdaa,
            #[cfg(feature = "sm2")]
            TpmtEccScheme::Sm2(_) => Self::Sm2,
            #[cfg(feature = "ecschnorr")]
            TpmtEccScheme::Ecschnorr(_) => Self::Ecschnorr,
            #[cfg(feature = "eddsa")]
            TpmtEccScheme::Eddsa(_) => Self::Eddsa,
            #[cfg(feature = "eddsa_ph")]
            TpmtEccScheme::EddsaPh(_) => Self::EddsaPh,
            #[cfg(feature = "ecdh")]
            TpmtEccScheme::Ecdh(_) => Self::Ecdh,
            #[cfg(feature = "ecmqv")]
            TpmtEccScheme::Ecmqv(_) => Self::Ecmqv,
            #[cfg(not(any(feature = "ecdaa", feature = "ecdh", feature = "ecdsa", feature = "ecmqv", feature = "ecschnorr", feature = "eddsa", feature = "eddsa_ph", feature = "sm2")))]
            _ => unreachable!(),
        }
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 176, table 201, TPMT_ECC_SCHEME structure (with conditional values)
#[cfg(feature = "ecc")]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u16)]
pub enum TpmtEccSchemeWCV {
    #[cfg(feature = "ecdsa")]
    Ecdsa(TpmsSchemeHash) = TpmAlgId::Ecdsa as u16,
    #[cfg(feature = "ecdaa")]
    Ecdaa(TpmsSchemeEcdaa) = TpmAlgId::Ecdaa as u16,
    #[cfg(feature = "sm2")]
    Sm2(TpmsSchemeHash) = TpmAlgId::Sm2 as u16,
    #[cfg(feature = "ecschnorr")]
    Ecschnorr(TpmsSchemeHash) = TpmAlgId::Ecschnorr as u16,
    #[cfg(feature = "eddsa")]
    Eddsa(TpmsSchemeHash) = TpmAlgId::Eddsa as u16,
    #[cfg(feature = "eddsa_ph")]
    EddsaPh(TpmsSchemeHash) = TpmAlgId::EddsaPh as u16,
    #[cfg(feature = "ecdh")]
    Ecdh(TpmsSchemeHash) = TpmAlgId::Ecdh as u16,
    #[cfg(feature = "ecmqv")]
    Ecmqv(TpmsSchemeHash) = TpmAlgId::Ecmqv as u16,
    Null = TpmAlgId::Null as u16,
}

#[cfg(feature = "ecc")]
impl TpmtEccSchemeWCV {
    pub const fn marshalled_max_size() -> u16 {
        tpmt_ecc_scheme_wcv_marshalled_max_size()
    }

    const fn marshalled_selector_size() -> u16 {
        TpmiAlgEccSchemeWCV::marshalled_size()
    }

    fn marshalled_data_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;
        match self {
            #[cfg(feature = "ecdsa")]
            Self::Ecdsa(_) => {
                let details_size = match usize::try_from(tpms_scheme_hash_marshalled_size()) {
                    Ok(details_size) => details_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(details_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(feature = "ecdaa")]
            Self::Ecdaa(_) => {
                let details_size = match usize::try_from(tpms_scheme_ecdaa_marshalled_size()) {
                    Ok(details_size) => details_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(details_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(feature = "sm2")]
            Self::Sm2(_) => {
                let details_size = match usize::try_from(tpms_scheme_hash_marshalled_size()) {
                    Ok(details_size) => details_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(details_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(feature = "ecschnorr")]
            Self::Ecschnorr(_) => {
                let details_size = match usize::try_from(tpms_scheme_hash_marshalled_size()) {
                    Ok(details_size) => details_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(details_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(feature = "eddsa")]
            Self::Eddsa(_) => {
                let details_size = match usize::try_from(tpms_scheme_hash_marshalled_size()) {
                    Ok(details_size) => details_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(details_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(feature = "eddsa_ph")]
            Self::EddsaPh(_) => {
                let details_size = match usize::try_from(tpms_scheme_hash_marshalled_size()) {
                    Ok(details_size) => details_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(details_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(feature = "ecdh")]
            Self::Ecdh(_) => {
                let details_size = match usize::try_from(tpms_scheme_hash_marshalled_size()) {
                    Ok(details_size) => details_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(details_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(feature = "ecmqv")]
            Self::Ecmqv(_) => {
                let details_size = match usize::try_from(tpms_scheme_hash_marshalled_size()) {
                    Ok(details_size) => details_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(details_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            Self::Null => (),
        };

        Ok(size)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let selector_size = match usize::try_from(Self::marshalled_selector_size()) {
            Ok(selector_size) => selector_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(selector_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let data_size = match self.marshalled_data_size() {
            Ok(data_size) => data_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(data_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = match self {
            #[cfg(feature = "ecdsa")]
            Self::Ecdsa(details) => {
                let selector = TpmAlgId::Ecdsa as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = details.marshal(buf)?;

                buf
            },
            #[cfg(feature = "ecdaa")]
            Self::Ecdaa(details) => {
                let selector = TpmAlgId::Ecdaa as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = details.marshal(buf)?;

                buf
            },
            #[cfg(feature = "sm2")]
            Self::Sm2(details) => {
                let selector = TpmAlgId::Sm2 as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = details.marshal(buf)?;

                buf
            },
            #[cfg(feature = "ecschnorr")]
            Self::Ecschnorr(details) => {
                let selector = TpmAlgId::Ecschnorr as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = details.marshal(buf)?;

                buf
            },
            #[cfg(feature = "eddsa")]
            Self::Eddsa(details) => {
                let selector = TpmAlgId::Eddsa as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = details.marshal(buf)?;

                buf
            },
            #[cfg(feature = "eddsa_ph")]
            Self::EddsaPh(details) => {
                let selector = TpmAlgId::EddsaPh as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = details.marshal(buf)?;

                buf
            },
            #[cfg(feature = "ecdh")]
            Self::Ecdh(details) => {
                let selector = TpmAlgId::Ecdh as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = details.marshal(buf)?;

                buf
            },
            #[cfg(feature = "ecmqv")]
            Self::Ecmqv(details) => {
                let selector = TpmAlgId::Ecmqv as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = details.marshal(buf)?;

                buf
            },
            Self::Null => {
                let selector = TpmAlgId::Null as u16;
                let buf = marshal_u16(buf, selector)?;

                buf
            },
        };
        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_scheme) = match unmarshal_u16(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, r) = match unmarshalled_scheme {
            #[cfg(feature = "ecdsa")]
            value if value == TpmAlgId::Ecdsa as u16 => {
                let (buf, unmarshalled_details) = match TpmsSchemeHash::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Ecdsa(unmarshalled_details))
            },
            #[cfg(feature = "ecdaa")]
            value if value == TpmAlgId::Ecdaa as u16 => {
                let (buf, unmarshalled_details) = match TpmsSchemeEcdaa::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Ecdaa(unmarshalled_details))
            },
            #[cfg(feature = "sm2")]
            value if value == TpmAlgId::Sm2 as u16 => {
                let (buf, unmarshalled_details) = match TpmsSchemeHash::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Sm2(unmarshalled_details))
            },
            #[cfg(feature = "ecschnorr")]
            value if value == TpmAlgId::Ecschnorr as u16 => {
                let (buf, unmarshalled_details) = match TpmsSchemeHash::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Ecschnorr(unmarshalled_details))
            },
            #[cfg(feature = "eddsa")]
            value if value == TpmAlgId::Eddsa as u16 => {
                let (buf, unmarshalled_details) = match TpmsSchemeHash::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Eddsa(unmarshalled_details))
            },
            #[cfg(feature = "eddsa_ph")]
            value if value == TpmAlgId::EddsaPh as u16 => {
                let (buf, unmarshalled_details) = match TpmsSchemeHash::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::EddsaPh(unmarshalled_details))
            },
            #[cfg(feature = "ecdh")]
            value if value == TpmAlgId::Ecdh as u16 => {
                let (buf, unmarshalled_details) = match TpmsSchemeHash::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Ecdh(unmarshalled_details))
            },
            #[cfg(feature = "ecmqv")]
            value if value == TpmAlgId::Ecmqv as u16 => {
                let (buf, unmarshalled_details) = match TpmsSchemeHash::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Ecmqv(unmarshalled_details))
            },
            value if value == TpmAlgId::Null as u16 => {
                (buf, Self::Null)
            },
            _ => {
                return Err(TpmErr::Rc(TpmRc::SCHEME));
            },
        };

        Ok((buf, r))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

#[cfg(feature = "ecc")]
const fn tpmt_ecc_scheme_wcv_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiAlgEccSchemeWCV::marshalled_size();
    size += TpmuAsymScheme::marshalled_max_size();

    size
}

#[cfg(feature = "ecc")]
impl convert::From<&TpmtEccSchemeWCV> for TpmiAlgEccSchemeWCV {
    fn from(value: &TpmtEccSchemeWCV) -> Self {
        match value {
            #[cfg(feature = "ecdsa")]
            TpmtEccSchemeWCV::Ecdsa(_) => Self::Ecdsa,
            #[cfg(feature = "ecdaa")]
            TpmtEccSchemeWCV::Ecdaa(_) => Self::Ecdaa,
            #[cfg(feature = "sm2")]
            TpmtEccSchemeWCV::Sm2(_) => Self::Sm2,
            #[cfg(feature = "ecschnorr")]
            TpmtEccSchemeWCV::Ecschnorr(_) => Self::Ecschnorr,
            #[cfg(feature = "eddsa")]
            TpmtEccSchemeWCV::Eddsa(_) => Self::Eddsa,
            #[cfg(feature = "eddsa_ph")]
            TpmtEccSchemeWCV::EddsaPh(_) => Self::EddsaPh,
            #[cfg(feature = "ecdh")]
            TpmtEccSchemeWCV::Ecdh(_) => Self::Ecdh,
            #[cfg(feature = "ecmqv")]
            TpmtEccSchemeWCV::Ecmqv(_) => Self::Ecmqv,
            TpmtEccSchemeWCV::Null => Self::Null,
        }
    }
}

#[cfg(feature = "ecc")]
impl convert::From<TpmtEccScheme> for TpmtEccSchemeWCV {
    fn from(value: TpmtEccScheme) -> Self {
        match value {
            #[cfg(feature = "ecdsa")]
            TpmtEccScheme::Ecdsa(details) => Self::Ecdsa(details),
            #[cfg(feature = "ecdaa")]
            TpmtEccScheme::Ecdaa(details) => Self::Ecdaa(details),
            #[cfg(feature = "sm2")]
            TpmtEccScheme::Sm2(details) => Self::Sm2(details),
            #[cfg(feature = "ecschnorr")]
            TpmtEccScheme::Ecschnorr(details) => Self::Ecschnorr(details),
            #[cfg(feature = "eddsa")]
            TpmtEccScheme::Eddsa(details) => Self::Eddsa(details),
            #[cfg(feature = "eddsa_ph")]
            TpmtEccScheme::EddsaPh(details) => Self::EddsaPh(details),
            #[cfg(feature = "ecdh")]
            TpmtEccScheme::Ecdh(details) => Self::Ecdh(details),
            #[cfg(feature = "ecmqv")]
            TpmtEccScheme::Ecmqv(details) => Self::Ecmqv(details),
            #[cfg(not(any(feature = "ecdaa", feature = "ecdh", feature = "ecdsa", feature = "ecmqv", feature = "ecschnorr", feature = "eddsa", feature = "eddsa_ph", feature = "sm2")))]
            _ => unreachable!(),
        }
    }
}

#[cfg(feature = "ecc")]
impl convert::TryFrom<TpmtEccSchemeWCV> for TpmtEccScheme {
    type Error = TpmErr;

    fn try_from(value: TpmtEccSchemeWCV) -> Result<Self, TpmErr> {
        let result = match value {
            #[cfg(feature = "ecdsa")]
            TpmtEccSchemeWCV::Ecdsa(details) => Self::Ecdsa(details),
            #[cfg(feature = "ecdaa")]
            TpmtEccSchemeWCV::Ecdaa(details) => Self::Ecdaa(details),
            #[cfg(feature = "sm2")]
            TpmtEccSchemeWCV::Sm2(details) => Self::Sm2(details),
            #[cfg(feature = "ecschnorr")]
            TpmtEccSchemeWCV::Ecschnorr(details) => Self::Ecschnorr(details),
            #[cfg(feature = "eddsa")]
            TpmtEccSchemeWCV::Eddsa(details) => Self::Eddsa(details),
            #[cfg(feature = "eddsa_ph")]
            TpmtEccSchemeWCV::EddsaPh(details) => Self::EddsaPh(details),
            #[cfg(feature = "ecdh")]
            TpmtEccSchemeWCV::Ecdh(details) => Self::Ecdh(details),
            #[cfg(feature = "ecmqv")]
            TpmtEccSchemeWCV::Ecmqv(details) => Self::Ecmqv(details),
            _ => {
                return Err(TpmErr::Rc(TpmRc::SCHEME));
            },
        };

        Ok(result)
    }
}

#[cfg(feature = "ecc")]
impl cmp::PartialEq<TpmtEccScheme> for TpmtEccSchemeWCV {
    fn eq(&self, other: &TpmtEccScheme) -> bool {
        match self {
            #[cfg(feature = "ecdsa")]
            Self::Ecdsa(self_details) => {
                if let TpmtEccScheme::Ecdsa(other_details) = other {
                    self_details == other_details
                } else {
                    false
                }
            },
            #[cfg(feature = "ecdaa")]
            Self::Ecdaa(self_details) => {
                if let TpmtEccScheme::Ecdaa(other_details) = other {
                    self_details == other_details
                } else {
                    false
                }
            },
            #[cfg(feature = "sm2")]
            Self::Sm2(self_details) => {
                if let TpmtEccScheme::Sm2(other_details) = other {
                    self_details == other_details
                } else {
                    false
                }
            },
            #[cfg(feature = "ecschnorr")]
            Self::Ecschnorr(self_details) => {
                if let TpmtEccScheme::Ecschnorr(other_details) = other {
                    self_details == other_details
                } else {
                    false
                }
            },
            #[cfg(feature = "eddsa")]
            Self::Eddsa(self_details) => {
                if let TpmtEccScheme::Eddsa(other_details) = other {
                    self_details == other_details
                } else {
                    false
                }
            },
            #[cfg(feature = "eddsa_ph")]
            Self::EddsaPh(self_details) => {
                if let TpmtEccScheme::EddsaPh(other_details) = other {
                    self_details == other_details
                } else {
                    false
                }
            },
            #[cfg(feature = "ecdh")]
            Self::Ecdh(self_details) => {
                if let TpmtEccScheme::Ecdh(other_details) = other {
                    self_details == other_details
                } else {
                    false
                }
            },
            #[cfg(feature = "ecmqv")]
            Self::Ecmqv(self_details) => {
                if let TpmtEccScheme::Ecmqv(other_details) = other {
                    self_details == other_details
                } else {
                    false
                }
            },
            _ => false,
        }
    }
}

#[cfg(feature = "ecc")]
impl cmp::PartialEq<TpmtEccSchemeWCV> for TpmtEccScheme {
    fn eq(&self, other: &TpmtEccSchemeWCV) -> bool {
        other.eq(self)
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 177, table 202, TPMS_ALGORITHM_DETAIL_ECC structure
#[cfg(feature = "ecc")]
#[derive(Debug, PartialEq)]
pub struct TpmsAlgorithmDetailEcc<'a> {
    pub curve_id: TpmEccCurve,
    pub key_size: u16,
    pub kdf: TpmtKdfSchemeWCV,
    pub sign: TpmtEccSchemeWCV,
    pub p: Tpm2bEccParameter<'a>,
    pub a: Tpm2bEccParameter<'a>,
    pub b: Tpm2bEccParameter<'a>,
    pub g_x: Tpm2bEccParameter<'a>,
    pub g_y: Tpm2bEccParameter<'a>,
    pub n: Tpm2bEccParameter<'a>,
    pub h: Tpm2bEccParameter<'a>,
}

#[cfg(feature = "ecc")]
impl<'a> TpmsAlgorithmDetailEcc<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpms_algorithm_detail_ecc_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let curve_id_size = match usize::try_from(TpmEccCurve::marshalled_size()) {
            Ok(curve_id_size) => curve_id_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(curve_id_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let key_size_size = mem::size_of::<u16>();
        size = match size.checked_add(key_size_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let kdf_size = match self.kdf.marshalled_size() {
            Ok(kdf_size) => kdf_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(kdf_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let sign_size = match self.sign.marshalled_size() {
            Ok(sign_size) => sign_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(sign_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let p_size = match self.p.marshalled_size() {
            Ok(p_size) => p_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(p_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let a_size = match self.a.marshalled_size() {
            Ok(a_size) => a_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(a_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let b_size = match self.b.marshalled_size() {
            Ok(b_size) => b_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(b_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let g_x_size = match self.g_x.marshalled_size() {
            Ok(g_x_size) => g_x_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(g_x_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let g_y_size = match self.g_y.marshalled_size() {
            Ok(g_y_size) => g_y_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(g_y_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let n_size = match self.n.marshalled_size() {
            Ok(n_size) => n_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(n_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let h_size = match self.h.marshalled_size() {
            Ok(h_size) => h_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(h_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.curve_id.marshal(buf)?;

        let buf = marshal_u16(buf, self.key_size)?;

        let buf = self.kdf.marshal(buf)?;

        let buf = self.sign.marshal(buf)?;

        let buf = self.p.marshal(buf)?;

        let buf = self.a.marshal(buf)?;

        let buf = self.b.marshal(buf)?;

        let buf = self.g_x.marshal(buf)?;

        let buf = self.g_y.marshal(buf)?;

        let buf = self.n.marshal(buf)?;

        let buf = self.h.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_curve_id) = match TpmEccCurve::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_key_size) = match unmarshal_u16(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_kdf) = match TpmtKdfSchemeWCV::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_sign) = match TpmtEccSchemeWCV::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_p) = match Tpm2bEccParameter::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_a) = match Tpm2bEccParameter::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_b) = match Tpm2bEccParameter::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_g_x) = match Tpm2bEccParameter::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_g_y) = match Tpm2bEccParameter::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_n) = match Tpm2bEccParameter::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_h) = match Tpm2bEccParameter::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{curve_id: unmarshalled_curve_id, key_size: unmarshalled_key_size, kdf: unmarshalled_kdf, sign: unmarshalled_sign, p: unmarshalled_p, a: unmarshalled_a, b: unmarshalled_b, g_x: unmarshalled_g_x, g_y: unmarshalled_g_y, n: unmarshalled_n, h: unmarshalled_h}))
    }

    pub fn unmarshal(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<TpmsAlgorithmDetailEcc<'static>, TpmErr> {
        Ok(TpmsAlgorithmDetailEcc {
            curve_id: self.curve_id,
            key_size: self.key_size,
            kdf: self.kdf,
            sign: self.sign,
            p: self.p.try_clone_intern()?,
            a: self.a.try_clone_intern()?,
            b: self.b.try_clone_intern()?,
            g_x: self.g_x.try_clone_intern()?,
            g_y: self.g_y.try_clone_intern()?,
            n: self.n.try_clone_intern()?,
            h: self.h.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<TpmsAlgorithmDetailEcc<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<TpmsAlgorithmDetailEcc<'static>, TpmErr> {
        let Self {
            curve_id,
            key_size,
            kdf,
            sign,
            p,
            a,
            b,
            g_x,
            g_y,
            n,
            h,
        } = self;

        let p = p.into_bufs_owner_intern()?;
        let a = a.into_bufs_owner_intern()?;
        let b = b.into_bufs_owner_intern()?;
        let g_x = g_x.into_bufs_owner_intern()?;
        let g_y = g_y.into_bufs_owner_intern()?;
        let n = n.into_bufs_owner_intern()?;
        let h = h.into_bufs_owner_intern()?;

        Ok(TpmsAlgorithmDetailEcc {
            curve_id,
            key_size,
            kdf,
            sign,
            p,
            a,
            b,
            g_x,
            g_y,
            n,
            h,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<TpmsAlgorithmDetailEcc<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

#[cfg(feature = "ecc")]
fn tpms_algorithm_detail_ecc_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    size += TpmEccCurve::marshalled_size() as u32;
    size += mem::size_of::<u16>() as u32;
    size += tpmt_kdf_scheme_wcv_marshalled_max_size() as u32;
    size += tpmt_ecc_scheme_wcv_marshalled_max_size() as u32;

    let p_size = match tpm2b_ecc_parameter_marshalled_max_size(limits) {
        Ok(p_size) => p_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(p_size).ok_or(())?;

    let a_size = match tpm2b_ecc_parameter_marshalled_max_size(limits) {
        Ok(a_size) => a_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(a_size).ok_or(())?;

    let b_size = match tpm2b_ecc_parameter_marshalled_max_size(limits) {
        Ok(b_size) => b_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(b_size).ok_or(())?;

    let g_x_size = match tpm2b_ecc_parameter_marshalled_max_size(limits) {
        Ok(g_x_size) => g_x_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(g_x_size).ok_or(())?;

    let g_y_size = match tpm2b_ecc_parameter_marshalled_max_size(limits) {
        Ok(g_y_size) => g_y_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(g_y_size).ok_or(())?;

    let n_size = match tpm2b_ecc_parameter_marshalled_max_size(limits) {
        Ok(n_size) => n_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(n_size).ok_or(())?;

    let h_size = match tpm2b_ecc_parameter_marshalled_max_size(limits) {
        Ok(h_size) => h_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(h_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 177, table 203, TPMS_SIGNATURE_RSA structure
#[cfg(feature = "rsa")]
#[derive(Debug, PartialEq)]
pub struct TpmsSignatureRsa<'a> {
    pub hash: TpmiAlgHash,
    pub sig: Tpm2bPublicKeyRsa<'a>,
}

#[cfg(feature = "rsa")]
impl<'a> TpmsSignatureRsa<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpms_signature_rsa_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let hash_size = match usize::try_from(TpmiAlgHash::marshalled_size()) {
            Ok(hash_size) => hash_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(hash_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let sig_size = match self.sig.marshalled_size() {
            Ok(sig_size) => sig_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(sig_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.hash.marshal(buf)?;

        let buf = self.sig.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_hash) = match TpmiAlgHash::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_sig) = match Tpm2bPublicKeyRsa::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{hash: unmarshalled_hash, sig: unmarshalled_sig}))
    }

    pub fn unmarshal(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<TpmsSignatureRsa<'static>, TpmErr> {
        Ok(TpmsSignatureRsa {
            hash: self.hash,
            sig: self.sig.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<TpmsSignatureRsa<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<TpmsSignatureRsa<'static>, TpmErr> {
        let Self {
            hash,
            sig,
        } = self;

        let sig = sig.into_bufs_owner_intern()?;

        Ok(TpmsSignatureRsa {
            hash,
            sig,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<TpmsSignatureRsa<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

#[cfg(feature = "rsa")]
fn tpms_signature_rsa_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    size += TpmiAlgHash::marshalled_size() as u32;

    let sig_size = match tpm2b_public_key_rsa_marshalled_max_size(limits) {
        Ok(sig_size) => sig_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(sig_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 177, table 205, TPMS_SIGNATURE_ECC structure
#[cfg(feature = "ecc")]
#[derive(Debug, PartialEq)]
pub struct TpmsSignatureEcc<'a> {
    pub hash: TpmiAlgHash,
    pub signature_r: Tpm2bEccParameter<'a>,
    pub signature_s: Tpm2bEccParameter<'a>,
}

#[cfg(feature = "ecc")]
impl<'a> TpmsSignatureEcc<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpms_signature_ecc_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let hash_size = match usize::try_from(TpmiAlgHash::marshalled_size()) {
            Ok(hash_size) => hash_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(hash_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let signature_r_size = match self.signature_r.marshalled_size() {
            Ok(signature_r_size) => signature_r_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(signature_r_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let signature_s_size = match self.signature_s.marshalled_size() {
            Ok(signature_s_size) => signature_s_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(signature_s_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.hash.marshal(buf)?;

        let buf = self.signature_r.marshal(buf)?;

        let buf = self.signature_s.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_hash) = match TpmiAlgHash::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_signature_r) = match Tpm2bEccParameter::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_signature_s) = match Tpm2bEccParameter::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{hash: unmarshalled_hash, signature_r: unmarshalled_signature_r, signature_s: unmarshalled_signature_s}))
    }

    pub fn unmarshal(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<TpmsSignatureEcc<'static>, TpmErr> {
        Ok(TpmsSignatureEcc {
            hash: self.hash,
            signature_r: self.signature_r.try_clone_intern()?,
            signature_s: self.signature_s.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<TpmsSignatureEcc<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<TpmsSignatureEcc<'static>, TpmErr> {
        let Self {
            hash,
            signature_r,
            signature_s,
        } = self;

        let signature_r = signature_r.into_bufs_owner_intern()?;
        let signature_s = signature_s.into_bufs_owner_intern()?;

        Ok(TpmsSignatureEcc {
            hash,
            signature_r,
            signature_s,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<TpmsSignatureEcc<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

#[cfg(feature = "ecc")]
fn tpms_signature_ecc_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    size += TpmiAlgHash::marshalled_size() as u32;

    let signature_r_size = match tpm2b_ecc_parameter_marshalled_max_size(limits) {
        Ok(signature_r_size) => signature_r_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(signature_r_size).ok_or(())?;

    let signature_s_size = match tpm2b_ecc_parameter_marshalled_max_size(limits) {
        Ok(signature_s_size) => signature_s_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(signature_s_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 178, table 207, TPMU_SIGNATURE union
struct TpmuSignature {}

impl TpmuSignature {
    fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        let mut size: u32 = 0;

        #[cfg(feature = "hmac")]
        {
            let hmac_size = tpmt_ha_marshalled_max_size() as u32;
            if hmac_size > size {
                size = hmac_size;
            }
        }

        let any_size = tpms_scheme_hash_marshalled_size() as u32;
        if any_size > size {
            size = any_size;
        }

        #[cfg(all(feature = "rsa", feature = "rsassa"))]
        {
            let rsassa_size = match tpms_signature_rsa_marshalled_max_size(limits) {
                Ok(rsassa_size) => rsassa_size,
                Err(_) => {
                    return Err(());
                },
            };
            if rsassa_size > size {
                size = rsassa_size;
            }
        }

        #[cfg(all(feature = "rsa", feature = "rsapss"))]
        {
            let rsapss_size = match tpms_signature_rsa_marshalled_max_size(limits) {
                Ok(rsapss_size) => rsapss_size,
                Err(_) => {
                    return Err(());
                },
            };
            if rsapss_size > size {
                size = rsapss_size;
            }
        }

        #[cfg(all(feature = "ecc", feature = "ecdsa"))]
        {
            let ecdsa_size = match tpms_signature_ecc_marshalled_max_size(limits) {
                Ok(ecdsa_size) => ecdsa_size,
                Err(_) => {
                    return Err(());
                },
            };
            if ecdsa_size > size {
                size = ecdsa_size;
            }
        }

        #[cfg(all(feature = "ecc", feature = "ecdaa"))]
        {
            let ecdaa_size = match tpms_signature_ecc_marshalled_max_size(limits) {
                Ok(ecdaa_size) => ecdaa_size,
                Err(_) => {
                    return Err(());
                },
            };
            if ecdaa_size > size {
                size = ecdaa_size;
            }
        }

        #[cfg(all(feature = "ecc", feature = "sm2"))]
        {
            let sm2_size = match tpms_signature_ecc_marshalled_max_size(limits) {
                Ok(sm2_size) => sm2_size,
                Err(_) => {
                    return Err(());
                },
            };
            if sm2_size > size {
                size = sm2_size;
            }
        }

        #[cfg(all(feature = "ecc", feature = "ecschnorr"))]
        {
            let ecschnorr_size = match tpms_signature_ecc_marshalled_max_size(limits) {
                Ok(ecschnorr_size) => ecschnorr_size,
                Err(_) => {
                    return Err(());
                },
            };
            if ecschnorr_size > size {
                size = ecschnorr_size;
            }
        }

        #[cfg(all(feature = "ecc", feature = "eddsa"))]
        {
            let eddsa_size = match tpms_signature_ecc_marshalled_max_size(limits) {
                Ok(eddsa_size) => eddsa_size,
                Err(_) => {
                    return Err(());
                },
            };
            if eddsa_size > size {
                size = eddsa_size;
            }
        }

        #[cfg(all(feature = "ecc", feature = "eddsa_ph"))]
        {
            let eddsa_ph_size = match tpms_signature_ecc_marshalled_max_size(limits) {
                Ok(eddsa_ph_size) => eddsa_ph_size,
                Err(_) => {
                    return Err(());
                },
            };
            if eddsa_ph_size > size {
                size = eddsa_ph_size;
            }
        }

        Ok(size)
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 179, table 208, TPMT_SIGNATURE structure (without conditional values)
#[derive(Debug, PartialEq)]
#[cfg_attr(any(feature = "hmac", all(feature = "ecc", feature = "ecdaa"), all(feature = "ecc", feature = "ecdsa"), all(feature = "ecc", feature = "ecschnorr"), all(feature = "ecc", feature = "eddsa"), all(feature = "ecc", feature = "eddsa_ph"), all(feature = "ecc", feature = "sm2"), all(feature = "rsa", feature = "rsapss"), all(feature = "rsa", feature = "rsassa")), repr(u16))]
pub enum TpmtSignature<'a> {
    #[cfg(all(feature = "rsa", feature = "rsassa"))]
    Rsassa(TpmsSignatureRsa<'a>) = TpmAlgId::Rsassa as u16,
    #[cfg(all(feature = "rsa", feature = "rsapss"))]
    Rsapss(TpmsSignatureRsa<'a>) = TpmAlgId::Rsapss as u16,
    #[cfg(all(feature = "ecc", feature = "ecdsa"))]
    Ecdsa(TpmsSignatureEcc<'a>) = TpmAlgId::Ecdsa as u16,
    #[cfg(all(feature = "ecc", feature = "ecdaa"))]
    Ecdaa(TpmsSignatureEcc<'a>) = TpmAlgId::Ecdaa as u16,
    #[cfg(all(feature = "ecc", feature = "sm2"))]
    Sm2(TpmsSignatureEcc<'a>) = TpmAlgId::Sm2 as u16,
    #[cfg(all(feature = "ecc", feature = "ecschnorr"))]
    Ecschnorr(TpmsSignatureEcc<'a>) = TpmAlgId::Ecschnorr as u16,
    #[cfg(all(feature = "ecc", feature = "eddsa"))]
    Eddsa(TpmsSignatureEcc<'a>) = TpmAlgId::Eddsa as u16,
    #[cfg(all(feature = "ecc", feature = "eddsa_ph"))]
    EddsaPh(TpmsSignatureEcc<'a>) = TpmAlgId::EddsaPh as u16,
    #[cfg(feature = "hmac")]
    Hmac(TpmtHa<'a>) = TpmAlgId::Hmac as u16,
}

impl<'a> TpmtSignature<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpmt_signature_marshalled_max_size(limits)
    }

    const fn marshalled_selector_size() -> u16 {
        TpmiAlgSigScheme::marshalled_size()
    }

    fn marshalled_data_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;
        match self {
            #[cfg(all(feature = "rsa", feature = "rsassa"))]
            Self::Rsassa(signature) => {
                let signature_size = match signature.marshalled_size() {
                    Ok(signature_size) => signature_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(signature_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(all(feature = "rsa", feature = "rsapss"))]
            Self::Rsapss(signature) => {
                let signature_size = match signature.marshalled_size() {
                    Ok(signature_size) => signature_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(signature_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(all(feature = "ecc", feature = "ecdsa"))]
            Self::Ecdsa(signature) => {
                let signature_size = match signature.marshalled_size() {
                    Ok(signature_size) => signature_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(signature_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(all(feature = "ecc", feature = "ecdaa"))]
            Self::Ecdaa(signature) => {
                let signature_size = match signature.marshalled_size() {
                    Ok(signature_size) => signature_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(signature_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(all(feature = "ecc", feature = "sm2"))]
            Self::Sm2(signature) => {
                let signature_size = match signature.marshalled_size() {
                    Ok(signature_size) => signature_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(signature_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(all(feature = "ecc", feature = "ecschnorr"))]
            Self::Ecschnorr(signature) => {
                let signature_size = match signature.marshalled_size() {
                    Ok(signature_size) => signature_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(signature_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(all(feature = "ecc", feature = "eddsa"))]
            Self::Eddsa(signature) => {
                let signature_size = match signature.marshalled_size() {
                    Ok(signature_size) => signature_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(signature_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(all(feature = "ecc", feature = "eddsa_ph"))]
            Self::EddsaPh(signature) => {
                let signature_size = match signature.marshalled_size() {
                    Ok(signature_size) => signature_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(signature_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(feature = "hmac")]
            Self::Hmac(signature) => {
                let signature_size = match signature.marshalled_size() {
                    Ok(signature_size) => signature_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(signature_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(not(any(feature = "hmac", all(feature = "ecc", feature = "ecdaa"), all(feature = "ecc", feature = "ecdsa"), all(feature = "ecc", feature = "ecschnorr"), all(feature = "ecc", feature = "eddsa"), all(feature = "ecc", feature = "eddsa_ph"), all(feature = "ecc", feature = "sm2"), all(feature = "rsa", feature = "rsapss"), all(feature = "rsa", feature = "rsassa"))))]
            _ => unreachable!(),
        };

        Ok(size)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let selector_size = match usize::try_from(Self::marshalled_selector_size()) {
            Ok(selector_size) => selector_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(selector_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let data_size = match self.marshalled_data_size() {
            Ok(data_size) => data_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(data_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = match self {
            #[cfg(all(feature = "rsa", feature = "rsassa"))]
            Self::Rsassa(signature) => {
                let selector = TpmAlgId::Rsassa as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = signature.marshal(buf)?;

                buf
            },
            #[cfg(all(feature = "rsa", feature = "rsapss"))]
            Self::Rsapss(signature) => {
                let selector = TpmAlgId::Rsapss as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = signature.marshal(buf)?;

                buf
            },
            #[cfg(all(feature = "ecc", feature = "ecdsa"))]
            Self::Ecdsa(signature) => {
                let selector = TpmAlgId::Ecdsa as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = signature.marshal(buf)?;

                buf
            },
            #[cfg(all(feature = "ecc", feature = "ecdaa"))]
            Self::Ecdaa(signature) => {
                let selector = TpmAlgId::Ecdaa as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = signature.marshal(buf)?;

                buf
            },
            #[cfg(all(feature = "ecc", feature = "sm2"))]
            Self::Sm2(signature) => {
                let selector = TpmAlgId::Sm2 as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = signature.marshal(buf)?;

                buf
            },
            #[cfg(all(feature = "ecc", feature = "ecschnorr"))]
            Self::Ecschnorr(signature) => {
                let selector = TpmAlgId::Ecschnorr as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = signature.marshal(buf)?;

                buf
            },
            #[cfg(all(feature = "ecc", feature = "eddsa"))]
            Self::Eddsa(signature) => {
                let selector = TpmAlgId::Eddsa as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = signature.marshal(buf)?;

                buf
            },
            #[cfg(all(feature = "ecc", feature = "eddsa_ph"))]
            Self::EddsaPh(signature) => {
                let selector = TpmAlgId::EddsaPh as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = signature.marshal(buf)?;

                buf
            },
            #[cfg(feature = "hmac")]
            Self::Hmac(signature) => {
                let selector = TpmAlgId::Hmac as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = signature.marshal(buf)?;

                buf
            },
            #[cfg(not(any(feature = "hmac", all(feature = "ecc", feature = "ecdaa"), all(feature = "ecc", feature = "ecdsa"), all(feature = "ecc", feature = "ecschnorr"), all(feature = "ecc", feature = "eddsa"), all(feature = "ecc", feature = "eddsa_ph"), all(feature = "ecc", feature = "sm2"), all(feature = "rsa", feature = "rsapss"), all(feature = "rsa", feature = "rsassa"))))]
            _ => unreachable!(),
        };
        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_sig_alg) = match unmarshal_u16(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, r) = match unmarshalled_sig_alg {
            #[cfg(all(feature = "rsa", feature = "rsassa"))]
            value if value == TpmAlgId::Rsassa as u16 => {
                let (buf, unmarshalled_signature) = match TpmsSignatureRsa::unmarshal_intern(buf, limits) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Rsassa(unmarshalled_signature))
            },
            #[cfg(all(feature = "rsa", feature = "rsapss"))]
            value if value == TpmAlgId::Rsapss as u16 => {
                let (buf, unmarshalled_signature) = match TpmsSignatureRsa::unmarshal_intern(buf, limits) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Rsapss(unmarshalled_signature))
            },
            #[cfg(all(feature = "ecc", feature = "ecdsa"))]
            value if value == TpmAlgId::Ecdsa as u16 => {
                let (buf, unmarshalled_signature) = match TpmsSignatureEcc::unmarshal_intern(buf, limits) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Ecdsa(unmarshalled_signature))
            },
            #[cfg(all(feature = "ecc", feature = "ecdaa"))]
            value if value == TpmAlgId::Ecdaa as u16 => {
                let (buf, unmarshalled_signature) = match TpmsSignatureEcc::unmarshal_intern(buf, limits) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Ecdaa(unmarshalled_signature))
            },
            #[cfg(all(feature = "ecc", feature = "sm2"))]
            value if value == TpmAlgId::Sm2 as u16 => {
                let (buf, unmarshalled_signature) = match TpmsSignatureEcc::unmarshal_intern(buf, limits) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Sm2(unmarshalled_signature))
            },
            #[cfg(all(feature = "ecc", feature = "ecschnorr"))]
            value if value == TpmAlgId::Ecschnorr as u16 => {
                let (buf, unmarshalled_signature) = match TpmsSignatureEcc::unmarshal_intern(buf, limits) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Ecschnorr(unmarshalled_signature))
            },
            #[cfg(all(feature = "ecc", feature = "eddsa"))]
            value if value == TpmAlgId::Eddsa as u16 => {
                let (buf, unmarshalled_signature) = match TpmsSignatureEcc::unmarshal_intern(buf, limits) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Eddsa(unmarshalled_signature))
            },
            #[cfg(all(feature = "ecc", feature = "eddsa_ph"))]
            value if value == TpmAlgId::EddsaPh as u16 => {
                let (buf, unmarshalled_signature) = match TpmsSignatureEcc::unmarshal_intern(buf, limits) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::EddsaPh(unmarshalled_signature))
            },
            #[cfg(feature = "hmac")]
            value if value == TpmAlgId::Hmac as u16 => {
                let (buf, unmarshalled_signature) = match TpmtHa::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Hmac(unmarshalled_signature))
            },
            _ => {
                return Err(TpmErr::Rc(TpmRc::SCHEME));
            },
        };

        Ok((buf, r))
    }

    pub fn unmarshal(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<TpmtSignature<'static>, TpmErr> {
        match self {
            #[cfg(all(feature = "rsa", feature = "rsassa"))]
            Self::Rsassa(signature) => {
                Ok(TpmtSignature::Rsassa(
                    signature.try_clone_intern()?,
                ))
            },
            #[cfg(all(feature = "rsa", feature = "rsapss"))]
            Self::Rsapss(signature) => {
                Ok(TpmtSignature::Rsapss(
                    signature.try_clone_intern()?,
                ))
            },
            #[cfg(all(feature = "ecc", feature = "ecdsa"))]
            Self::Ecdsa(signature) => {
                Ok(TpmtSignature::Ecdsa(
                    signature.try_clone_intern()?,
                ))
            },
            #[cfg(all(feature = "ecc", feature = "ecdaa"))]
            Self::Ecdaa(signature) => {
                Ok(TpmtSignature::Ecdaa(
                    signature.try_clone_intern()?,
                ))
            },
            #[cfg(all(feature = "ecc", feature = "sm2"))]
            Self::Sm2(signature) => {
                Ok(TpmtSignature::Sm2(
                    signature.try_clone_intern()?,
                ))
            },
            #[cfg(all(feature = "ecc", feature = "ecschnorr"))]
            Self::Ecschnorr(signature) => {
                Ok(TpmtSignature::Ecschnorr(
                    signature.try_clone_intern()?,
                ))
            },
            #[cfg(all(feature = "ecc", feature = "eddsa"))]
            Self::Eddsa(signature) => {
                Ok(TpmtSignature::Eddsa(
                    signature.try_clone_intern()?,
                ))
            },
            #[cfg(all(feature = "ecc", feature = "eddsa_ph"))]
            Self::EddsaPh(signature) => {
                Ok(TpmtSignature::EddsaPh(
                    signature.try_clone_intern()?,
                ))
            },
            #[cfg(feature = "hmac")]
            Self::Hmac(signature) => {
                Ok(TpmtSignature::Hmac(
                    signature.try_clone_intern()?,
                ))
            },
            #[cfg(not(any(feature = "hmac", all(feature = "ecc", feature = "ecdaa"), all(feature = "ecc", feature = "ecdsa"), all(feature = "ecc", feature = "ecschnorr"), all(feature = "ecc", feature = "eddsa"), all(feature = "ecc", feature = "eddsa_ph"), all(feature = "ecc", feature = "sm2"), all(feature = "rsa", feature = "rsapss"), all(feature = "rsa", feature = "rsassa"))))]
            _ => unreachable!(),
        }
    }

    pub fn try_clone(&self) -> Result<Box<TpmtSignature<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<TpmtSignature<'static>, TpmErr> {
        match self {
            #[cfg(all(feature = "rsa", feature = "rsassa"))]
            Self::Rsassa(signature) => {
                let signature = signature.into_bufs_owner_intern()?;
                Ok(TpmtSignature::Rsassa(signature))
            },
            #[cfg(all(feature = "rsa", feature = "rsapss"))]
            Self::Rsapss(signature) => {
                let signature = signature.into_bufs_owner_intern()?;
                Ok(TpmtSignature::Rsapss(signature))
            },
            #[cfg(all(feature = "ecc", feature = "ecdsa"))]
            Self::Ecdsa(signature) => {
                let signature = signature.into_bufs_owner_intern()?;
                Ok(TpmtSignature::Ecdsa(signature))
            },
            #[cfg(all(feature = "ecc", feature = "ecdaa"))]
            Self::Ecdaa(signature) => {
                let signature = signature.into_bufs_owner_intern()?;
                Ok(TpmtSignature::Ecdaa(signature))
            },
            #[cfg(all(feature = "ecc", feature = "sm2"))]
            Self::Sm2(signature) => {
                let signature = signature.into_bufs_owner_intern()?;
                Ok(TpmtSignature::Sm2(signature))
            },
            #[cfg(all(feature = "ecc", feature = "ecschnorr"))]
            Self::Ecschnorr(signature) => {
                let signature = signature.into_bufs_owner_intern()?;
                Ok(TpmtSignature::Ecschnorr(signature))
            },
            #[cfg(all(feature = "ecc", feature = "eddsa"))]
            Self::Eddsa(signature) => {
                let signature = signature.into_bufs_owner_intern()?;
                Ok(TpmtSignature::Eddsa(signature))
            },
            #[cfg(all(feature = "ecc", feature = "eddsa_ph"))]
            Self::EddsaPh(signature) => {
                let signature = signature.into_bufs_owner_intern()?;
                Ok(TpmtSignature::EddsaPh(signature))
            },
            #[cfg(feature = "hmac")]
            Self::Hmac(signature) => {
                let signature = signature.into_bufs_owner_intern()?;
                Ok(TpmtSignature::Hmac(signature))
            },
            #[cfg(not(any(feature = "hmac", all(feature = "ecc", feature = "ecdaa"), all(feature = "ecc", feature = "ecdsa"), all(feature = "ecc", feature = "ecschnorr"), all(feature = "ecc", feature = "eddsa"), all(feature = "ecc", feature = "eddsa_ph"), all(feature = "ecc", feature = "sm2"), all(feature = "rsa", feature = "rsapss"), all(feature = "rsa", feature = "rsassa"))))]
            _ => unreachable!(),
        }
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<TpmtSignature<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpmt_signature_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    size += TpmiAlgSigScheme::marshalled_size() as u32;

    let signature_size = match TpmuSignature::marshalled_max_size(limits) {
        Ok(signature_size) => signature_size,
        Err(_) => return Err(()),
    };
    size = size.checked_add(signature_size).ok_or(())?;

    Ok(size)
}

impl<'a> convert::From<&TpmtSignature<'a>> for TpmiAlgSigScheme {
    fn from(value: &TpmtSignature<'a>) -> Self {
        match value {
            #[cfg(all(feature = "rsa", feature = "rsassa"))]
            TpmtSignature::Rsassa(_) => Self::Rsassa,
            #[cfg(all(feature = "rsa", feature = "rsapss"))]
            TpmtSignature::Rsapss(_) => Self::Rsapss,
            #[cfg(all(feature = "ecc", feature = "ecdsa"))]
            TpmtSignature::Ecdsa(_) => Self::Ecdsa,
            #[cfg(all(feature = "ecc", feature = "ecdaa"))]
            TpmtSignature::Ecdaa(_) => Self::Ecdaa,
            #[cfg(all(feature = "ecc", feature = "sm2"))]
            TpmtSignature::Sm2(_) => Self::Sm2,
            #[cfg(all(feature = "ecc", feature = "ecschnorr"))]
            TpmtSignature::Ecschnorr(_) => Self::Ecschnorr,
            #[cfg(all(feature = "ecc", feature = "eddsa"))]
            TpmtSignature::Eddsa(_) => Self::Eddsa,
            #[cfg(all(feature = "ecc", feature = "eddsa_ph"))]
            TpmtSignature::EddsaPh(_) => Self::EddsaPh,
            #[cfg(feature = "hmac")]
            TpmtSignature::Hmac(_) => Self::Hmac,
            #[cfg(not(any(feature = "hmac", all(feature = "ecc", feature = "ecdaa"), all(feature = "ecc", feature = "ecdsa"), all(feature = "ecc", feature = "ecschnorr"), all(feature = "ecc", feature = "eddsa"), all(feature = "ecc", feature = "eddsa_ph"), all(feature = "ecc", feature = "sm2"), all(feature = "rsa", feature = "rsapss"), all(feature = "rsa", feature = "rsassa"))))]
            _ => unreachable!(),
        }
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 179, table 208, TPMT_SIGNATURE structure (with conditional values)
#[derive(Debug, PartialEq)]
#[repr(u16)]
pub enum TpmtSignatureWCV<'a> {
    #[cfg(all(feature = "rsa", feature = "rsassa"))]
    Rsassa(TpmsSignatureRsa<'a>) = TpmAlgId::Rsassa as u16,
    #[cfg(all(feature = "rsa", feature = "rsapss"))]
    Rsapss(TpmsSignatureRsa<'a>) = TpmAlgId::Rsapss as u16,
    #[cfg(all(feature = "ecc", feature = "ecdsa"))]
    Ecdsa(TpmsSignatureEcc<'a>) = TpmAlgId::Ecdsa as u16,
    #[cfg(all(feature = "ecc", feature = "ecdaa"))]
    Ecdaa(TpmsSignatureEcc<'a>) = TpmAlgId::Ecdaa as u16,
    #[cfg(all(feature = "ecc", feature = "sm2"))]
    Sm2(TpmsSignatureEcc<'a>) = TpmAlgId::Sm2 as u16,
    #[cfg(all(feature = "ecc", feature = "ecschnorr"))]
    Ecschnorr(TpmsSignatureEcc<'a>) = TpmAlgId::Ecschnorr as u16,
    #[cfg(all(feature = "ecc", feature = "eddsa"))]
    Eddsa(TpmsSignatureEcc<'a>) = TpmAlgId::Eddsa as u16,
    #[cfg(all(feature = "ecc", feature = "eddsa_ph"))]
    EddsaPh(TpmsSignatureEcc<'a>) = TpmAlgId::EddsaPh as u16,
    #[cfg(feature = "hmac")]
    Hmac(TpmtHa<'a>) = TpmAlgId::Hmac as u16,
    Null = TpmAlgId::Null as u16,
}

impl<'a> TpmtSignatureWCV<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpmt_signature_wcv_marshalled_max_size(limits)
    }

    const fn marshalled_selector_size() -> u16 {
        TpmiAlgSigSchemeWCV::marshalled_size()
    }

    fn marshalled_data_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;
        match self {
            #[cfg(all(feature = "rsa", feature = "rsassa"))]
            Self::Rsassa(signature) => {
                let signature_size = match signature.marshalled_size() {
                    Ok(signature_size) => signature_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(signature_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(all(feature = "rsa", feature = "rsapss"))]
            Self::Rsapss(signature) => {
                let signature_size = match signature.marshalled_size() {
                    Ok(signature_size) => signature_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(signature_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(all(feature = "ecc", feature = "ecdsa"))]
            Self::Ecdsa(signature) => {
                let signature_size = match signature.marshalled_size() {
                    Ok(signature_size) => signature_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(signature_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(all(feature = "ecc", feature = "ecdaa"))]
            Self::Ecdaa(signature) => {
                let signature_size = match signature.marshalled_size() {
                    Ok(signature_size) => signature_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(signature_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(all(feature = "ecc", feature = "sm2"))]
            Self::Sm2(signature) => {
                let signature_size = match signature.marshalled_size() {
                    Ok(signature_size) => signature_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(signature_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(all(feature = "ecc", feature = "ecschnorr"))]
            Self::Ecschnorr(signature) => {
                let signature_size = match signature.marshalled_size() {
                    Ok(signature_size) => signature_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(signature_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(all(feature = "ecc", feature = "eddsa"))]
            Self::Eddsa(signature) => {
                let signature_size = match signature.marshalled_size() {
                    Ok(signature_size) => signature_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(signature_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(all(feature = "ecc", feature = "eddsa_ph"))]
            Self::EddsaPh(signature) => {
                let signature_size = match signature.marshalled_size() {
                    Ok(signature_size) => signature_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(signature_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(feature = "hmac")]
            Self::Hmac(signature) => {
                let signature_size = match signature.marshalled_size() {
                    Ok(signature_size) => signature_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(signature_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            Self::Null => (),
        };

        Ok(size)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let selector_size = match usize::try_from(Self::marshalled_selector_size()) {
            Ok(selector_size) => selector_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(selector_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let data_size = match self.marshalled_data_size() {
            Ok(data_size) => data_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(data_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = match self {
            #[cfg(all(feature = "rsa", feature = "rsassa"))]
            Self::Rsassa(signature) => {
                let selector = TpmAlgId::Rsassa as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = signature.marshal(buf)?;

                buf
            },
            #[cfg(all(feature = "rsa", feature = "rsapss"))]
            Self::Rsapss(signature) => {
                let selector = TpmAlgId::Rsapss as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = signature.marshal(buf)?;

                buf
            },
            #[cfg(all(feature = "ecc", feature = "ecdsa"))]
            Self::Ecdsa(signature) => {
                let selector = TpmAlgId::Ecdsa as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = signature.marshal(buf)?;

                buf
            },
            #[cfg(all(feature = "ecc", feature = "ecdaa"))]
            Self::Ecdaa(signature) => {
                let selector = TpmAlgId::Ecdaa as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = signature.marshal(buf)?;

                buf
            },
            #[cfg(all(feature = "ecc", feature = "sm2"))]
            Self::Sm2(signature) => {
                let selector = TpmAlgId::Sm2 as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = signature.marshal(buf)?;

                buf
            },
            #[cfg(all(feature = "ecc", feature = "ecschnorr"))]
            Self::Ecschnorr(signature) => {
                let selector = TpmAlgId::Ecschnorr as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = signature.marshal(buf)?;

                buf
            },
            #[cfg(all(feature = "ecc", feature = "eddsa"))]
            Self::Eddsa(signature) => {
                let selector = TpmAlgId::Eddsa as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = signature.marshal(buf)?;

                buf
            },
            #[cfg(all(feature = "ecc", feature = "eddsa_ph"))]
            Self::EddsaPh(signature) => {
                let selector = TpmAlgId::EddsaPh as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = signature.marshal(buf)?;

                buf
            },
            #[cfg(feature = "hmac")]
            Self::Hmac(signature) => {
                let selector = TpmAlgId::Hmac as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = signature.marshal(buf)?;

                buf
            },
            Self::Null => {
                let selector = TpmAlgId::Null as u16;
                let buf = marshal_u16(buf, selector)?;

                buf
            },
        };
        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_sig_alg) = match unmarshal_u16(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, r) = match unmarshalled_sig_alg {
            #[cfg(all(feature = "rsa", feature = "rsassa"))]
            value if value == TpmAlgId::Rsassa as u16 => {
                let (buf, unmarshalled_signature) = match TpmsSignatureRsa::unmarshal_intern(buf, limits) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Rsassa(unmarshalled_signature))
            },
            #[cfg(all(feature = "rsa", feature = "rsapss"))]
            value if value == TpmAlgId::Rsapss as u16 => {
                let (buf, unmarshalled_signature) = match TpmsSignatureRsa::unmarshal_intern(buf, limits) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Rsapss(unmarshalled_signature))
            },
            #[cfg(all(feature = "ecc", feature = "ecdsa"))]
            value if value == TpmAlgId::Ecdsa as u16 => {
                let (buf, unmarshalled_signature) = match TpmsSignatureEcc::unmarshal_intern(buf, limits) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Ecdsa(unmarshalled_signature))
            },
            #[cfg(all(feature = "ecc", feature = "ecdaa"))]
            value if value == TpmAlgId::Ecdaa as u16 => {
                let (buf, unmarshalled_signature) = match TpmsSignatureEcc::unmarshal_intern(buf, limits) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Ecdaa(unmarshalled_signature))
            },
            #[cfg(all(feature = "ecc", feature = "sm2"))]
            value if value == TpmAlgId::Sm2 as u16 => {
                let (buf, unmarshalled_signature) = match TpmsSignatureEcc::unmarshal_intern(buf, limits) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Sm2(unmarshalled_signature))
            },
            #[cfg(all(feature = "ecc", feature = "ecschnorr"))]
            value if value == TpmAlgId::Ecschnorr as u16 => {
                let (buf, unmarshalled_signature) = match TpmsSignatureEcc::unmarshal_intern(buf, limits) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Ecschnorr(unmarshalled_signature))
            },
            #[cfg(all(feature = "ecc", feature = "eddsa"))]
            value if value == TpmAlgId::Eddsa as u16 => {
                let (buf, unmarshalled_signature) = match TpmsSignatureEcc::unmarshal_intern(buf, limits) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Eddsa(unmarshalled_signature))
            },
            #[cfg(all(feature = "ecc", feature = "eddsa_ph"))]
            value if value == TpmAlgId::EddsaPh as u16 => {
                let (buf, unmarshalled_signature) = match TpmsSignatureEcc::unmarshal_intern(buf, limits) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::EddsaPh(unmarshalled_signature))
            },
            #[cfg(feature = "hmac")]
            value if value == TpmAlgId::Hmac as u16 => {
                let (buf, unmarshalled_signature) = match TpmtHa::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Hmac(unmarshalled_signature))
            },
            value if value == TpmAlgId::Null as u16 => {
                (buf, Self::Null)
            },
            _ => {
                return Err(TpmErr::Rc(TpmRc::SCHEME));
            },
        };

        Ok((buf, r))
    }

    pub fn unmarshal(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<TpmtSignatureWCV<'static>, TpmErr> {
        match self {
            #[cfg(all(feature = "rsa", feature = "rsassa"))]
            Self::Rsassa(signature) => {
                Ok(TpmtSignatureWCV::Rsassa(
                    signature.try_clone_intern()?,
                ))
            },
            #[cfg(all(feature = "rsa", feature = "rsapss"))]
            Self::Rsapss(signature) => {
                Ok(TpmtSignatureWCV::Rsapss(
                    signature.try_clone_intern()?,
                ))
            },
            #[cfg(all(feature = "ecc", feature = "ecdsa"))]
            Self::Ecdsa(signature) => {
                Ok(TpmtSignatureWCV::Ecdsa(
                    signature.try_clone_intern()?,
                ))
            },
            #[cfg(all(feature = "ecc", feature = "ecdaa"))]
            Self::Ecdaa(signature) => {
                Ok(TpmtSignatureWCV::Ecdaa(
                    signature.try_clone_intern()?,
                ))
            },
            #[cfg(all(feature = "ecc", feature = "sm2"))]
            Self::Sm2(signature) => {
                Ok(TpmtSignatureWCV::Sm2(
                    signature.try_clone_intern()?,
                ))
            },
            #[cfg(all(feature = "ecc", feature = "ecschnorr"))]
            Self::Ecschnorr(signature) => {
                Ok(TpmtSignatureWCV::Ecschnorr(
                    signature.try_clone_intern()?,
                ))
            },
            #[cfg(all(feature = "ecc", feature = "eddsa"))]
            Self::Eddsa(signature) => {
                Ok(TpmtSignatureWCV::Eddsa(
                    signature.try_clone_intern()?,
                ))
            },
            #[cfg(all(feature = "ecc", feature = "eddsa_ph"))]
            Self::EddsaPh(signature) => {
                Ok(TpmtSignatureWCV::EddsaPh(
                    signature.try_clone_intern()?,
                ))
            },
            #[cfg(feature = "hmac")]
            Self::Hmac(signature) => {
                Ok(TpmtSignatureWCV::Hmac(
                    signature.try_clone_intern()?,
                ))
            },
            Self::Null => Ok(TpmtSignatureWCV::Null),
        }
    }

    pub fn try_clone(&self) -> Result<Box<TpmtSignatureWCV<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<TpmtSignatureWCV<'static>, TpmErr> {
        match self {
            #[cfg(all(feature = "rsa", feature = "rsassa"))]
            Self::Rsassa(signature) => {
                let signature = signature.into_bufs_owner_intern()?;
                Ok(TpmtSignatureWCV::Rsassa(signature))
            },
            #[cfg(all(feature = "rsa", feature = "rsapss"))]
            Self::Rsapss(signature) => {
                let signature = signature.into_bufs_owner_intern()?;
                Ok(TpmtSignatureWCV::Rsapss(signature))
            },
            #[cfg(all(feature = "ecc", feature = "ecdsa"))]
            Self::Ecdsa(signature) => {
                let signature = signature.into_bufs_owner_intern()?;
                Ok(TpmtSignatureWCV::Ecdsa(signature))
            },
            #[cfg(all(feature = "ecc", feature = "ecdaa"))]
            Self::Ecdaa(signature) => {
                let signature = signature.into_bufs_owner_intern()?;
                Ok(TpmtSignatureWCV::Ecdaa(signature))
            },
            #[cfg(all(feature = "ecc", feature = "sm2"))]
            Self::Sm2(signature) => {
                let signature = signature.into_bufs_owner_intern()?;
                Ok(TpmtSignatureWCV::Sm2(signature))
            },
            #[cfg(all(feature = "ecc", feature = "ecschnorr"))]
            Self::Ecschnorr(signature) => {
                let signature = signature.into_bufs_owner_intern()?;
                Ok(TpmtSignatureWCV::Ecschnorr(signature))
            },
            #[cfg(all(feature = "ecc", feature = "eddsa"))]
            Self::Eddsa(signature) => {
                let signature = signature.into_bufs_owner_intern()?;
                Ok(TpmtSignatureWCV::Eddsa(signature))
            },
            #[cfg(all(feature = "ecc", feature = "eddsa_ph"))]
            Self::EddsaPh(signature) => {
                let signature = signature.into_bufs_owner_intern()?;
                Ok(TpmtSignatureWCV::EddsaPh(signature))
            },
            #[cfg(feature = "hmac")]
            Self::Hmac(signature) => {
                let signature = signature.into_bufs_owner_intern()?;
                Ok(TpmtSignatureWCV::Hmac(signature))
            },
            Self::Null => Ok(TpmtSignatureWCV::Null),
        }
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<TpmtSignatureWCV<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpmt_signature_wcv_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    size += TpmiAlgSigSchemeWCV::marshalled_size() as u32;

    let signature_size = match TpmuSignature::marshalled_max_size(limits) {
        Ok(signature_size) => signature_size,
        Err(_) => return Err(()),
    };
    size = size.checked_add(signature_size).ok_or(())?;

    Ok(size)
}

impl<'a> convert::From<&TpmtSignatureWCV<'a>> for TpmiAlgSigSchemeWCV {
    fn from(value: &TpmtSignatureWCV<'a>) -> Self {
        match value {
            #[cfg(all(feature = "rsa", feature = "rsassa"))]
            TpmtSignatureWCV::Rsassa(_) => Self::Rsassa,
            #[cfg(all(feature = "rsa", feature = "rsapss"))]
            TpmtSignatureWCV::Rsapss(_) => Self::Rsapss,
            #[cfg(all(feature = "ecc", feature = "ecdsa"))]
            TpmtSignatureWCV::Ecdsa(_) => Self::Ecdsa,
            #[cfg(all(feature = "ecc", feature = "ecdaa"))]
            TpmtSignatureWCV::Ecdaa(_) => Self::Ecdaa,
            #[cfg(all(feature = "ecc", feature = "sm2"))]
            TpmtSignatureWCV::Sm2(_) => Self::Sm2,
            #[cfg(all(feature = "ecc", feature = "ecschnorr"))]
            TpmtSignatureWCV::Ecschnorr(_) => Self::Ecschnorr,
            #[cfg(all(feature = "ecc", feature = "eddsa"))]
            TpmtSignatureWCV::Eddsa(_) => Self::Eddsa,
            #[cfg(all(feature = "ecc", feature = "eddsa_ph"))]
            TpmtSignatureWCV::EddsaPh(_) => Self::EddsaPh,
            #[cfg(feature = "hmac")]
            TpmtSignatureWCV::Hmac(_) => Self::Hmac,
            TpmtSignatureWCV::Null => Self::Null,
        }
    }
}

impl<'a> convert::From<TpmtSignature<'a>> for TpmtSignatureWCV<'a> {
    fn from(value: TpmtSignature<'a>) -> Self {
        match value {
            #[cfg(all(feature = "rsa", feature = "rsassa"))]
            TpmtSignature::Rsassa(signature) => Self::Rsassa(signature),
            #[cfg(all(feature = "rsa", feature = "rsapss"))]
            TpmtSignature::Rsapss(signature) => Self::Rsapss(signature),
            #[cfg(all(feature = "ecc", feature = "ecdsa"))]
            TpmtSignature::Ecdsa(signature) => Self::Ecdsa(signature),
            #[cfg(all(feature = "ecc", feature = "ecdaa"))]
            TpmtSignature::Ecdaa(signature) => Self::Ecdaa(signature),
            #[cfg(all(feature = "ecc", feature = "sm2"))]
            TpmtSignature::Sm2(signature) => Self::Sm2(signature),
            #[cfg(all(feature = "ecc", feature = "ecschnorr"))]
            TpmtSignature::Ecschnorr(signature) => Self::Ecschnorr(signature),
            #[cfg(all(feature = "ecc", feature = "eddsa"))]
            TpmtSignature::Eddsa(signature) => Self::Eddsa(signature),
            #[cfg(all(feature = "ecc", feature = "eddsa_ph"))]
            TpmtSignature::EddsaPh(signature) => Self::EddsaPh(signature),
            #[cfg(feature = "hmac")]
            TpmtSignature::Hmac(signature) => Self::Hmac(signature),
            #[cfg(not(any(feature = "hmac", all(feature = "ecc", feature = "ecdaa"), all(feature = "ecc", feature = "ecdsa"), all(feature = "ecc", feature = "ecschnorr"), all(feature = "ecc", feature = "eddsa"), all(feature = "ecc", feature = "eddsa_ph"), all(feature = "ecc", feature = "sm2"), all(feature = "rsa", feature = "rsapss"), all(feature = "rsa", feature = "rsassa"))))]
            _ => unreachable!(),
        }
    }
}

impl<'a> convert::TryFrom<TpmtSignatureWCV<'a>> for TpmtSignature<'a> {
    type Error = TpmErr;

    fn try_from(value: TpmtSignatureWCV<'a>) -> Result<Self, TpmErr> {
        let result = match value {
            #[cfg(all(feature = "rsa", feature = "rsassa"))]
            TpmtSignatureWCV::Rsassa(signature) => Self::Rsassa(signature),
            #[cfg(all(feature = "rsa", feature = "rsapss"))]
            TpmtSignatureWCV::Rsapss(signature) => Self::Rsapss(signature),
            #[cfg(all(feature = "ecc", feature = "ecdsa"))]
            TpmtSignatureWCV::Ecdsa(signature) => Self::Ecdsa(signature),
            #[cfg(all(feature = "ecc", feature = "ecdaa"))]
            TpmtSignatureWCV::Ecdaa(signature) => Self::Ecdaa(signature),
            #[cfg(all(feature = "ecc", feature = "sm2"))]
            TpmtSignatureWCV::Sm2(signature) => Self::Sm2(signature),
            #[cfg(all(feature = "ecc", feature = "ecschnorr"))]
            TpmtSignatureWCV::Ecschnorr(signature) => Self::Ecschnorr(signature),
            #[cfg(all(feature = "ecc", feature = "eddsa"))]
            TpmtSignatureWCV::Eddsa(signature) => Self::Eddsa(signature),
            #[cfg(all(feature = "ecc", feature = "eddsa_ph"))]
            TpmtSignatureWCV::EddsaPh(signature) => Self::EddsaPh(signature),
            #[cfg(feature = "hmac")]
            TpmtSignatureWCV::Hmac(signature) => Self::Hmac(signature),
            _ => {
                return Err(TpmErr::Rc(TpmRc::SCHEME));
            },
        };

        Ok(result)
    }
}

impl<'a> cmp::PartialEq<TpmtSignature<'a>> for TpmtSignatureWCV<'a> {
    fn eq(&self, other: &TpmtSignature<'a>) -> bool {
        match self {
            #[cfg(all(feature = "rsa", feature = "rsassa"))]
            Self::Rsassa(self_signature) => {
                if let TpmtSignature::Rsassa(other_signature) = other {
                    self_signature == other_signature
                } else {
                    false
                }
            },
            #[cfg(all(feature = "rsa", feature = "rsapss"))]
            Self::Rsapss(self_signature) => {
                if let TpmtSignature::Rsapss(other_signature) = other {
                    self_signature == other_signature
                } else {
                    false
                }
            },
            #[cfg(all(feature = "ecc", feature = "ecdsa"))]
            Self::Ecdsa(self_signature) => {
                if let TpmtSignature::Ecdsa(other_signature) = other {
                    self_signature == other_signature
                } else {
                    false
                }
            },
            #[cfg(all(feature = "ecc", feature = "ecdaa"))]
            Self::Ecdaa(self_signature) => {
                if let TpmtSignature::Ecdaa(other_signature) = other {
                    self_signature == other_signature
                } else {
                    false
                }
            },
            #[cfg(all(feature = "ecc", feature = "sm2"))]
            Self::Sm2(self_signature) => {
                if let TpmtSignature::Sm2(other_signature) = other {
                    self_signature == other_signature
                } else {
                    false
                }
            },
            #[cfg(all(feature = "ecc", feature = "ecschnorr"))]
            Self::Ecschnorr(self_signature) => {
                if let TpmtSignature::Ecschnorr(other_signature) = other {
                    self_signature == other_signature
                } else {
                    false
                }
            },
            #[cfg(all(feature = "ecc", feature = "eddsa"))]
            Self::Eddsa(self_signature) => {
                if let TpmtSignature::Eddsa(other_signature) = other {
                    self_signature == other_signature
                } else {
                    false
                }
            },
            #[cfg(all(feature = "ecc", feature = "eddsa_ph"))]
            Self::EddsaPh(self_signature) => {
                if let TpmtSignature::EddsaPh(other_signature) = other {
                    self_signature == other_signature
                } else {
                    false
                }
            },
            #[cfg(feature = "hmac")]
            Self::Hmac(self_signature) => {
                if let TpmtSignature::Hmac(other_signature) = other {
                    self_signature == other_signature
                } else {
                    false
                }
            },
            _ => false,
        }
    }
}

impl<'a> cmp::PartialEq<TpmtSignatureWCV<'a>> for TpmtSignature<'a> {
    fn eq(&self, other: &TpmtSignatureWCV<'a>) -> bool {
        other.eq(self)
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 179, table 209, TPMU_ENCRYPTED_SECRET union
struct TpmuEncryptedSecret {}

impl TpmuEncryptedSecret {
    fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        let mut size: u32 = 0;

        let symmetric_size = tpm2b_digest_marshalled_max_size() as u32;
        if symmetric_size > size {
            size = symmetric_size;
        }

        let keyed_hash_size = tpm2b_digest_marshalled_max_size() as u32;
        if keyed_hash_size > size {
            size = keyed_hash_size;
        }

        #[cfg(feature = "ecc")]
        {
            let v0 = match tpms_ecc_point_marshalled_max_size(limits) {
                Ok(v) => v,
                Err(_) => {
                    debug_assert!(false, "Unexpected sizeof() evaluation failure");
                    return Err(());
                },
            };
            let ecc_size = v0;
            if ecc_size > size {
                size = ecc_size;
            }
        }

        #[cfg(feature = "rsa")]
        {
            let rsa_size = limits.max_rsa_key_bytes as u32;
            if rsa_size > size {
                size = rsa_size;
            }
        }

        Ok(size)
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 180, table 210, TPM2B_ENCRYPTED_SECRET structure
#[derive(Debug, PartialEq)]
pub struct Tpm2bEncryptedSecret<'a> {
    pub secret: TpmBuffer<'a>,
}

impl<'a> Tpm2bEncryptedSecret<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2b_encrypted_secret_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let size_size = mem::size_of::<u16>();
        size = match size.checked_add(size_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let secret_size = self.secret.len();
        size = match size.checked_add(secret_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let marshalled_size = match u16::try_from(self.secret.len()) {
            Ok(marshalled_size) => marshalled_size,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::SIZE));
            },
        };
        let buf = marshal_u16(buf, marshalled_size)?;

        let buf = marshal_bytes(buf, &self.secret)?;

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_size) = match unmarshal_u16(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let secret_size: u16 = unmarshalled_size;
        let v0 = match TpmuEncryptedSecret::marshalled_max_size(limits) {
            Ok(v) => v,
            Err(_) => {
                debug_assert!(false, "Unexpected sizeof() evaluation failure");
                return Err(TpmErr::InternalErr);
            },
        };
        if secret_size as u32 > v0 {
            return Err(TpmErr::Rc(TpmRc::SIZE));
        }
        let secret_size = match usize::try_from(secret_size) {
            Ok(secret_size) => secret_size,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::INSUFFICIENT));
            },
        };
        let (unmarshalled_secret, buf) = match split_slice_at(buf, secret_size) {
            Ok((unmarshalled_secret, buf)) => (unmarshalled_secret, buf),
            Err(e) => {
                return Err(e);
            },
        };
        let unmarshalled_secret = TpmBuffer::from(unmarshalled_secret);

        Ok((buf, Self{secret: unmarshalled_secret}))
    }

    pub fn unmarshal(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2bEncryptedSecret<'static>, TpmErr> {
        let secret = copy_vec_from_slice(&self.secret)?;
        let secret = TpmBuffer::Owned(secret);

        Ok(Tpm2bEncryptedSecret {
            secret,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2bEncryptedSecret<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2bEncryptedSecret<'static>, TpmErr> {
        let Self {
            secret,
        } = self;

        let secret = secret.into_owned()?;

        Ok(Tpm2bEncryptedSecret {
            secret,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2bEncryptedSecret<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpm2b_encrypted_secret_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    size += mem::size_of::<u16>() as u32;

    let v0 = match TpmuEncryptedSecret::marshalled_max_size(limits) {
        Ok(v) => v,
        Err(_) => {
            debug_assert!(false, "Unexpected sizeof() evaluation failure");
            return Err(());
        },
    };
    let secret_size = v0;
    size = size.checked_add(secret_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 181, table 211, TPMI_ALG_PUBLIC type
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u16)]
pub enum TpmiAlgPublic {
    #[cfg(feature = "rsa")]
    Rsa = TpmAlgId::Rsa as u16,
    Keyedhash = TpmAlgId::Keyedhash as u16,
    #[cfg(feature = "ecc")]
    Ecc = TpmAlgId::Ecc as u16,
    Symcipher = TpmAlgId::Symcipher as u16,
}

impl TpmiAlgPublic {
    pub const fn marshalled_size() -> u16 {
        mem::size_of::<u16>() as u16
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u16(buf, *self as u16)
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u16(buf)?;
        let result = Self::try_from(value)?;
        Ok((buf, result))
    }
}

impl convert::TryFrom<u16> for TpmiAlgPublic {
    type Error = TpmErr;

    fn try_from(value: u16) -> Result<Self, TpmErr> {
        let result = match value {
            #[cfg(feature = "rsa")]
            value if value == Self::Rsa as u16 => Self::Rsa,
            value if value == Self::Keyedhash as u16 => Self::Keyedhash,
            #[cfg(feature = "ecc")]
            value if value == Self::Ecc as u16 => Self::Ecc,
            value if value == Self::Symcipher as u16 => Self::Symcipher,
            _ => {
                return Err(TpmErr::Rc(TpmRc::TYPE));
            },
        };

        Ok(result)
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 182, table 212, TPMU_PUBLIC_ID union
struct TpmuPublicId {}

impl TpmuPublicId {
    fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        let mut size: u32 = 0;

        let keyed_hash_size = tpm2b_digest_marshalled_max_size() as u32;
        if keyed_hash_size > size {
            size = keyed_hash_size;
        }

        let sym_size = tpm2b_digest_marshalled_max_size() as u32;
        if sym_size > size {
            size = sym_size;
        }

        #[cfg(feature = "rsa")]
        {
            let rsa_size = match tpm2b_public_key_rsa_marshalled_max_size(limits) {
                Ok(rsa_size) => rsa_size,
                Err(_) => {
                    return Err(());
                },
            };
            if rsa_size > size {
                size = rsa_size;
            }
        }

        #[cfg(feature = "ecc")]
        {
            let ecc_size = match tpms_ecc_point_marshalled_max_size(limits) {
                Ok(ecc_size) => ecc_size,
                Err(_) => {
                    return Err(());
                },
            };
            if ecc_size > size {
                size = ecc_size;
            }
        }

        let derive_size = match tpms_derive_marshalled_max_size(limits) {
            Ok(derive_size) => derive_size,
            Err(_) => {
                return Err(());
            },
        };
        if derive_size > size {
            size = derive_size;
        }

        Ok(size)
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 182, table 213, TPMS_KEYEDHASH_PARMS structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct TpmsKeyedhashParms {
    pub scheme: TpmtKeyedhashSchemeWCV,
}

impl TpmsKeyedhashParms {
    pub const fn marshalled_max_size() -> u16 {
        tpms_keyedhash_parms_marshalled_max_size()
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let scheme_size = match self.scheme.marshalled_size() {
            Ok(scheme_size) => scheme_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(scheme_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.scheme.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_scheme) = match TpmtKeyedhashSchemeWCV::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{scheme: unmarshalled_scheme}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpms_keyedhash_parms_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += tpmt_keyedhash_scheme_wcv_marshalled_max_size();

    size
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 183, table 214, TPMS_ASYM_PARMS structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct TpmsAsymParms {
    pub symmetric: TpmtSymDefObjectWCV,
    pub scheme: TpmtAsymSchemeWCV,
}

impl TpmsAsymParms {
    pub const fn marshalled_max_size() -> u16 {
        tpms_asym_parms_marshalled_max_size()
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let symmetric_size = match self.symmetric.marshalled_size() {
            Ok(symmetric_size) => symmetric_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(symmetric_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let scheme_size = match self.scheme.marshalled_size() {
            Ok(scheme_size) => scheme_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(scheme_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.symmetric.marshal(buf)?;

        let buf = self.scheme.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_symmetric) = match TpmtSymDefObjectWCV::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_scheme) = match TpmtAsymSchemeWCV::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{symmetric: unmarshalled_symmetric, scheme: unmarshalled_scheme}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpms_asym_parms_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += tpmt_sym_def_object_wcv_marshalled_max_size();
    size += tpmt_asym_scheme_wcv_marshalled_max_size();

    size
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 183, table 215, TPMS_RSA_PARMS structure
#[cfg(feature = "rsa")]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct TpmsRsaParms {
    pub symmetric: TpmtSymDefObjectWCV,
    pub scheme: TpmtRsaSchemeWCV,
    pub key_bits: TpmiRsaKeyBits,
    pub exponent: u32,
}

#[cfg(feature = "rsa")]
impl TpmsRsaParms {
    pub const fn marshalled_max_size() -> u16 {
        tpms_rsa_parms_marshalled_max_size()
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let key_bits_size = match usize::try_from(TpmiRsaKeyBits::marshalled_size()) {
            Ok(key_bits_size) => key_bits_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(key_bits_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let exponent_size = mem::size_of::<u32>();
        size = match size.checked_add(exponent_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let symmetric_size = match self.symmetric.marshalled_size() {
            Ok(symmetric_size) => symmetric_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(symmetric_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let scheme_size = match self.scheme.marshalled_size() {
            Ok(scheme_size) => scheme_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(scheme_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.symmetric.marshal(buf)?;

        let buf = self.scheme.marshal(buf)?;

        let buf = self.key_bits.marshal(buf)?;

        let buf = marshal_u32(buf, self.exponent)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_symmetric) = match TpmtSymDefObjectWCV::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_scheme) = match TpmtRsaSchemeWCV::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_key_bits) = match TpmiRsaKeyBits::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_exponent) = match unmarshal_u32(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{symmetric: unmarshalled_symmetric, scheme: unmarshalled_scheme, key_bits: unmarshalled_key_bits, exponent: unmarshalled_exponent}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

#[cfg(feature = "rsa")]
const fn tpms_rsa_parms_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += tpmt_sym_def_object_wcv_marshalled_max_size();
    size += tpmt_rsa_scheme_wcv_marshalled_max_size();
    size += TpmiRsaKeyBits::marshalled_size();
    size += mem::size_of::<u32>() as u16;

    size
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 184, table 216, TPMS_ECC_PARMS structure
#[cfg(feature = "ecc")]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct TpmsEccParms {
    pub symmetric: TpmtSymDefObjectWCV,
    pub scheme: TpmtEccSchemeWCV,
    pub curve_id: TpmiEccCurve,
    pub kdf: TpmtKdfSchemeWCV,
}

#[cfg(feature = "ecc")]
impl TpmsEccParms {
    pub const fn marshalled_max_size() -> u16 {
        tpms_ecc_parms_marshalled_max_size()
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let curve_id_size = match usize::try_from(TpmiEccCurve::marshalled_size()) {
            Ok(curve_id_size) => curve_id_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(curve_id_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let symmetric_size = match self.symmetric.marshalled_size() {
            Ok(symmetric_size) => symmetric_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(symmetric_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let scheme_size = match self.scheme.marshalled_size() {
            Ok(scheme_size) => scheme_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(scheme_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let kdf_size = match self.kdf.marshalled_size() {
            Ok(kdf_size) => kdf_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(kdf_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.symmetric.marshal(buf)?;

        let buf = self.scheme.marshal(buf)?;

        let buf = self.curve_id.marshal(buf)?;

        let buf = self.kdf.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_symmetric) = match TpmtSymDefObjectWCV::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_scheme) = match TpmtEccSchemeWCV::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_curve_id) = match TpmiEccCurve::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_kdf) = match TpmtKdfSchemeWCV::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{symmetric: unmarshalled_symmetric, scheme: unmarshalled_scheme, curve_id: unmarshalled_curve_id, kdf: unmarshalled_kdf}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

#[cfg(feature = "ecc")]
const fn tpms_ecc_parms_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += tpmt_sym_def_object_wcv_marshalled_max_size();
    size += tpmt_ecc_scheme_wcv_marshalled_max_size();
    size += TpmiEccCurve::marshalled_size();
    size += tpmt_kdf_scheme_wcv_marshalled_max_size();

    size
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 185, table 217, TPMU_PUBLIC_PARMS union
struct TpmuPublicParms {}

impl TpmuPublicParms {
    const fn marshalled_max_size() -> u16 {
        let mut size: u16 = 0;

        let keyed_hash_detail_size = tpms_keyedhash_parms_marshalled_max_size();
        if keyed_hash_detail_size > size {
            size = keyed_hash_detail_size;
        }

        let sym_detail_size = tpms_symcipher_parms_marshalled_max_size();
        if sym_detail_size > size {
            size = sym_detail_size;
        }

        #[cfg(feature = "rsa")]
        {
            let rsa_detail_size = tpms_rsa_parms_marshalled_max_size();
            if rsa_detail_size > size {
                size = rsa_detail_size;
            }
        }

        #[cfg(feature = "ecc")]
        {
            let ecc_detail_size = tpms_ecc_parms_marshalled_max_size();
            if ecc_detail_size > size {
                size = ecc_detail_size;
            }
        }

        let asym_detail_size = tpms_asym_parms_marshalled_max_size();
        if asym_detail_size > size {
            size = asym_detail_size;
        }

        size
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 185, table 218, TPMT_PUBLIC_PARMS structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u16)]
pub enum TpmtPublicParms {
    #[cfg(feature = "rsa")]
    Rsa(TpmsRsaParms) = TpmAlgId::Rsa as u16,
    Keyedhash(TpmsKeyedhashParms) = TpmAlgId::Keyedhash as u16,
    #[cfg(feature = "ecc")]
    Ecc(TpmsEccParms) = TpmAlgId::Ecc as u16,
    Symcipher(TpmsSymcipherParms) = TpmAlgId::Symcipher as u16,
}

impl TpmtPublicParms {
    pub const fn marshalled_max_size() -> u16 {
        tpmt_public_parms_marshalled_max_size()
    }

    const fn marshalled_selector_size() -> u16 {
        TpmiAlgPublic::marshalled_size()
    }

    fn marshalled_data_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;
        match self {
            #[cfg(feature = "rsa")]
            Self::Rsa(parameters) => {
                let parameters_size = match parameters.marshalled_size() {
                    Ok(parameters_size) => parameters_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(parameters_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            Self::Keyedhash(parameters) => {
                let parameters_size = match parameters.marshalled_size() {
                    Ok(parameters_size) => parameters_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(parameters_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(feature = "ecc")]
            Self::Ecc(parameters) => {
                let parameters_size = match parameters.marshalled_size() {
                    Ok(parameters_size) => parameters_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(parameters_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            Self::Symcipher(parameters) => {
                let parameters_size = match parameters.marshalled_size() {
                    Ok(parameters_size) => parameters_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(parameters_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
        };

        Ok(size)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let selector_size = match usize::try_from(Self::marshalled_selector_size()) {
            Ok(selector_size) => selector_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(selector_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let data_size = match self.marshalled_data_size() {
            Ok(data_size) => data_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(data_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = match self {
            #[cfg(feature = "rsa")]
            Self::Rsa(parameters) => {
                let selector = TpmAlgId::Rsa as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = parameters.marshal(buf)?;

                buf
            },
            Self::Keyedhash(parameters) => {
                let selector = TpmAlgId::Keyedhash as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = parameters.marshal(buf)?;

                buf
            },
            #[cfg(feature = "ecc")]
            Self::Ecc(parameters) => {
                let selector = TpmAlgId::Ecc as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = parameters.marshal(buf)?;

                buf
            },
            Self::Symcipher(parameters) => {
                let selector = TpmAlgId::Symcipher as u16;
                let buf = marshal_u16(buf, selector)?;

                let buf = parameters.marshal(buf)?;

                buf
            },
        };
        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_typ) = match unmarshal_u16(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, r) = match unmarshalled_typ {
            #[cfg(feature = "rsa")]
            value if value == TpmAlgId::Rsa as u16 => {
                let (buf, unmarshalled_parameters) = match TpmsRsaParms::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Rsa(unmarshalled_parameters))
            },
            value if value == TpmAlgId::Keyedhash as u16 => {
                let (buf, unmarshalled_parameters) = match TpmsKeyedhashParms::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Keyedhash(unmarshalled_parameters))
            },
            #[cfg(feature = "ecc")]
            value if value == TpmAlgId::Ecc as u16 => {
                let (buf, unmarshalled_parameters) = match TpmsEccParms::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Ecc(unmarshalled_parameters))
            },
            value if value == TpmAlgId::Symcipher as u16 => {
                let (buf, unmarshalled_parameters) = match TpmsSymcipherParms::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Symcipher(unmarshalled_parameters))
            },
            _ => {
                return Err(TpmErr::Rc(TpmRc::TYPE));
            },
        };

        Ok((buf, r))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpmt_public_parms_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiAlgPublic::marshalled_size();
    size += TpmuPublicParms::marshalled_max_size();

    size
}

impl convert::From<&TpmtPublicParms> for TpmiAlgPublic {
    fn from(value: &TpmtPublicParms) -> Self {
        match value {
            #[cfg(feature = "rsa")]
            TpmtPublicParms::Rsa(_) => Self::Rsa,
            TpmtPublicParms::Keyedhash(_) => Self::Keyedhash,
            #[cfg(feature = "ecc")]
            TpmtPublicParms::Ecc(_) => Self::Ecc,
            TpmtPublicParms::Symcipher(_) => Self::Symcipher,
        }
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 186, table 219, TPMT_PUBLIC structure (without conditional values)
#[derive(Debug, PartialEq)]
pub struct TpmtPublic<'a> {
    pub name_alg: TpmiAlgHash,
    pub object_attributes: TpmaObject,
    pub auth_policy: Tpm2bDigest<'a>,
    pub typ: TpmtPublicMemberTyp<'a>,
}

impl<'a> TpmtPublic<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpmt_public_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let typ_selector_size = match usize::try_from(TpmtPublicMemberTyp::marshalled_selector_size()) {
            Ok(typ_selector_size) => typ_selector_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(typ_selector_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let name_alg_size = match usize::try_from(TpmiAlgHash::marshalled_size()) {
            Ok(name_alg_size) => name_alg_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(name_alg_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let object_attributes_size = match usize::try_from(TpmaObject::marshalled_size()) {
            Ok(object_attributes_size) => object_attributes_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(object_attributes_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let auth_policy_size = match self.auth_policy.marshalled_size() {
            Ok(auth_policy_size) => auth_policy_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(auth_policy_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let typ_data_size = match self.typ.marshalled_data_size() {
            Ok(typ_data_size) => typ_data_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(typ_data_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.typ.marshal_intern_selector(buf)?;

        let buf = self.name_alg.marshal(buf)?;

        let buf = self.object_attributes.marshal(buf)?;

        let buf = self.auth_policy.marshal(buf)?;

        let buf = self.typ.marshal_intern_data(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_typ_selector) = match TpmtPublicMemberTyp::unmarshal_intern_selector(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_name_alg) = match TpmiAlgHash::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_object_attributes) = match TpmaObject::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_auth_policy) = match Tpm2bDigest::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_typ) = match TpmtPublicMemberTyp::<'_>::unmarshal_intern(unmarshalled_typ_selector, buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };


        Ok((buf, Self{name_alg: unmarshalled_name_alg, object_attributes: unmarshalled_object_attributes, auth_policy: unmarshalled_auth_policy, typ: unmarshalled_typ}))
    }

    pub fn unmarshal(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<TpmtPublic<'static>, TpmErr> {
        Ok(TpmtPublic {
            name_alg: self.name_alg,
            object_attributes: self.object_attributes,
            auth_policy: self.auth_policy.try_clone_intern()?,
            typ: self.typ.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<TpmtPublic<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<TpmtPublic<'static>, TpmErr> {
        let Self {
            name_alg,
            object_attributes,
            auth_policy,
            typ,
        } = self;

        let auth_policy = auth_policy.into_bufs_owner_intern()?;
        let typ = typ.into_bufs_owner_intern()?;

        Ok(TpmtPublic {
            name_alg,
            object_attributes,
            auth_policy,
            typ,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<TpmtPublic<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpmt_public_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    size += TpmiAlgPublic::marshalled_size() as u32;
    size += TpmiAlgHash::marshalled_size() as u32;
    size += TpmaObject::marshalled_size() as u32;
    size += tpm2b_digest_marshalled_max_size() as u32;
    size += TpmuPublicParms::marshalled_max_size() as u32;

    let unique_size = match TpmuPublicId::marshalled_max_size(limits) {
        Ok(unique_size) => unique_size,
        Err(_) => return Err(()),
    };
    size = size.checked_add(unique_size).ok_or(())?;

    Ok(size)
}

#[derive(Debug, PartialEq)]
#[repr(u16)]
pub enum TpmtPublicMemberTyp<'a> {
    #[cfg(feature = "rsa")]
    Rsa{
        parameters: TpmsRsaParms,
        unique: Tpm2bPublicKeyRsa<'a>,
    } = TpmAlgId::Rsa as u16,
    Keyedhash{
        parameters: TpmsKeyedhashParms,
        unique: Tpm2bDigest<'a>,
    } = TpmAlgId::Keyedhash as u16,
    #[cfg(feature = "ecc")]
    Ecc{
        parameters: TpmsEccParms,
        unique: TpmsEccPoint<'a>,
    } = TpmAlgId::Ecc as u16,
    Symcipher{
        parameters: TpmsSymcipherParms,
        unique: Tpm2bDigest<'a>,
    } = TpmAlgId::Symcipher as u16,
}

impl<'a> TpmtPublicMemberTyp<'a> {
    const fn marshalled_selector_size() -> u16 {
        TpmiAlgPublic::marshalled_size()
    }

    fn marshalled_data_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;
        match self {
            #[cfg(feature = "rsa")]
            Self::Rsa{parameters, unique} => {
                let parameters_size = match parameters.marshalled_size() {
                    Ok(parameters_size) => parameters_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(parameters_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };

                let unique_size = match unique.marshalled_size() {
                    Ok(unique_size) => unique_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(unique_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            Self::Keyedhash{parameters, unique} => {
                let parameters_size = match parameters.marshalled_size() {
                    Ok(parameters_size) => parameters_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(parameters_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };

                let unique_size = match unique.marshalled_size() {
                    Ok(unique_size) => unique_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(unique_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(feature = "ecc")]
            Self::Ecc{parameters, unique} => {
                let parameters_size = match parameters.marshalled_size() {
                    Ok(parameters_size) => parameters_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(parameters_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };

                let unique_size = match unique.marshalled_size() {
                    Ok(unique_size) => unique_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(unique_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            Self::Symcipher{parameters, unique} => {
                let parameters_size = match parameters.marshalled_size() {
                    Ok(parameters_size) => parameters_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(parameters_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };

                let unique_size = match unique.marshalled_size() {
                    Ok(unique_size) => unique_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(unique_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
        };

        Ok(size)
    }


    fn marshal_intern_selector<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let selector = match self {
            #[cfg(feature = "rsa")]
            Self::Rsa{parameters: _, unique: _} => TpmAlgId::Rsa as u16,
            Self::Keyedhash{parameters: _, unique: _} => TpmAlgId::Keyedhash as u16,
            #[cfg(feature = "ecc")]
            Self::Ecc{parameters: _, unique: _} => TpmAlgId::Ecc as u16,
            Self::Symcipher{parameters: _, unique: _} => TpmAlgId::Symcipher as u16,
        };

        marshal_u16(buf, selector)
    }

    fn marshal_intern_data<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = match self {
            #[cfg(feature = "rsa")]
            Self::Rsa{parameters, unique} => {
                let buf = parameters.marshal(buf)?;

                let buf = unique.marshal(buf)?;

                buf
            },
            Self::Keyedhash{parameters, unique} => {
                let buf = parameters.marshal(buf)?;

                let buf = unique.marshal(buf)?;

                buf
            },
            #[cfg(feature = "ecc")]
            Self::Ecc{parameters, unique} => {
                let buf = parameters.marshal(buf)?;

                let buf = unique.marshal(buf)?;

                buf
            },
            Self::Symcipher{parameters, unique} => {
                let buf = parameters.marshal(buf)?;

                let buf = unique.marshal(buf)?;

                buf
            },
        };
        Ok(buf)
    }

    fn unmarshal_intern_selector(buf: &'a [u8]) -> Result<(&'a [u8], u16), TpmErr> {
        let (buf, unmarshalled_typ_selector) = match unmarshal_u16(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        Ok((buf, unmarshalled_typ_selector))
    }

    fn unmarshal_intern(selector: u16, buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, r) = match selector {
            #[cfg(feature = "rsa")]
            value if value == TpmAlgId::Rsa as u16 => {
                let (buf, unmarshalled_parameters) = match TpmsRsaParms::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                let (buf, unmarshalled_unique) = match Tpm2bPublicKeyRsa::unmarshal_intern(buf, limits) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Rsa{parameters: unmarshalled_parameters, unique: unmarshalled_unique})
            },
            value if value == TpmAlgId::Keyedhash as u16 => {
                let (buf, unmarshalled_parameters) = match TpmsKeyedhashParms::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                let (buf, unmarshalled_unique) = match Tpm2bDigest::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Keyedhash{parameters: unmarshalled_parameters, unique: unmarshalled_unique})
            },
            #[cfg(feature = "ecc")]
            value if value == TpmAlgId::Ecc as u16 => {
                let (buf, unmarshalled_parameters) = match TpmsEccParms::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                let (buf, unmarshalled_unique) = match TpmsEccPoint::unmarshal_intern(buf, limits) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Ecc{parameters: unmarshalled_parameters, unique: unmarshalled_unique})
            },
            value if value == TpmAlgId::Symcipher as u16 => {
                let (buf, unmarshalled_parameters) = match TpmsSymcipherParms::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                let (buf, unmarshalled_unique) = match Tpm2bDigest::unmarshal_intern(buf) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Symcipher{parameters: unmarshalled_parameters, unique: unmarshalled_unique})
            },
            _ => {
                return Err(TpmErr::Rc(TpmRc::TYPE));
            },
        };

        Ok((buf, r))
    }

    fn try_clone_intern(&self) -> Result<TpmtPublicMemberTyp<'static>, TpmErr> {
        match self {
            #[cfg(feature = "rsa")]
            Self::Rsa{parameters, unique} => {
                Ok(TpmtPublicMemberTyp::Rsa {
                    parameters: *parameters,
                    unique: unique.try_clone_intern()?,
                })
            },
            Self::Keyedhash{parameters, unique} => {
                Ok(TpmtPublicMemberTyp::Keyedhash {
                    parameters: *parameters,
                    unique: unique.try_clone_intern()?,
                })
            },
            #[cfg(feature = "ecc")]
            Self::Ecc{parameters, unique} => {
                Ok(TpmtPublicMemberTyp::Ecc {
                    parameters: *parameters,
                    unique: unique.try_clone_intern()?,
                })
            },
            Self::Symcipher{parameters, unique} => {
                Ok(TpmtPublicMemberTyp::Symcipher {
                    parameters: *parameters,
                    unique: unique.try_clone_intern()?,
                })
            },
        }
    }

    pub fn try_clone(&self) -> Result<Box<TpmtPublicMemberTyp<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<TpmtPublicMemberTyp<'static>, TpmErr> {
        match self {
            #[cfg(feature = "rsa")]
            Self::Rsa{parameters, unique} => {
                let unique = unique.into_bufs_owner_intern()?;

                Ok(TpmtPublicMemberTyp::Rsa{parameters, unique})
            },
            Self::Keyedhash{parameters, unique} => {
                let unique = unique.into_bufs_owner_intern()?;

                Ok(TpmtPublicMemberTyp::Keyedhash{parameters, unique})
            },
            #[cfg(feature = "ecc")]
            Self::Ecc{parameters, unique} => {
                let unique = unique.into_bufs_owner_intern()?;

                Ok(TpmtPublicMemberTyp::Ecc{parameters, unique})
            },
            Self::Symcipher{parameters, unique} => {
                let unique = unique.into_bufs_owner_intern()?;

                Ok(TpmtPublicMemberTyp::Symcipher{parameters, unique})
            },
        }
    }
}

impl<'a> convert::From<&TpmtPublicMemberTyp<'a>> for TpmiAlgPublic {
    fn from(value: &TpmtPublicMemberTyp<'a>) -> Self {
        match value {
            #[cfg(feature = "rsa")]
            TpmtPublicMemberTyp::Rsa{parameters: _, unique: _} => Self::Rsa,
            TpmtPublicMemberTyp::Keyedhash{parameters: _, unique: _} => Self::Keyedhash,
            #[cfg(feature = "ecc")]
            TpmtPublicMemberTyp::Ecc{parameters: _, unique: _} => Self::Ecc,
            TpmtPublicMemberTyp::Symcipher{parameters: _, unique: _} => Self::Symcipher,
        }
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 186, table 219, TPMT_PUBLIC structure (with conditional values)
#[derive(Debug, PartialEq)]
pub struct TpmtPublicWCV<'a> {
    pub name_alg: TpmiAlgHashWCV,
    pub object_attributes: TpmaObject,
    pub auth_policy: Tpm2bDigest<'a>,
    pub typ: TpmtPublicMemberTyp<'a>,
}

impl<'a> TpmtPublicWCV<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpmt_public_wcv_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let typ_selector_size = match usize::try_from(TpmtPublicMemberTyp::marshalled_selector_size()) {
            Ok(typ_selector_size) => typ_selector_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(typ_selector_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let name_alg_size = match usize::try_from(TpmiAlgHashWCV::marshalled_size()) {
            Ok(name_alg_size) => name_alg_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(name_alg_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let object_attributes_size = match usize::try_from(TpmaObject::marshalled_size()) {
            Ok(object_attributes_size) => object_attributes_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(object_attributes_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let auth_policy_size = match self.auth_policy.marshalled_size() {
            Ok(auth_policy_size) => auth_policy_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(auth_policy_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let typ_data_size = match self.typ.marshalled_data_size() {
            Ok(typ_data_size) => typ_data_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(typ_data_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.typ.marshal_intern_selector(buf)?;

        let buf = self.name_alg.marshal(buf)?;

        let buf = self.object_attributes.marshal(buf)?;

        let buf = self.auth_policy.marshal(buf)?;

        let buf = self.typ.marshal_intern_data(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_typ_selector) = match TpmtPublicMemberTyp::unmarshal_intern_selector(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_name_alg) = match TpmiAlgHashWCV::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_object_attributes) = match TpmaObject::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_auth_policy) = match Tpm2bDigest::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_typ) = match TpmtPublicMemberTyp::<'_>::unmarshal_intern(unmarshalled_typ_selector, buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };


        Ok((buf, Self{name_alg: unmarshalled_name_alg, object_attributes: unmarshalled_object_attributes, auth_policy: unmarshalled_auth_policy, typ: unmarshalled_typ}))
    }

    pub fn unmarshal(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<TpmtPublicWCV<'static>, TpmErr> {
        Ok(TpmtPublicWCV {
            name_alg: self.name_alg,
            object_attributes: self.object_attributes,
            auth_policy: self.auth_policy.try_clone_intern()?,
            typ: self.typ.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<TpmtPublicWCV<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<TpmtPublicWCV<'static>, TpmErr> {
        let Self {
            name_alg,
            object_attributes,
            auth_policy,
            typ,
        } = self;

        let auth_policy = auth_policy.into_bufs_owner_intern()?;
        let typ = typ.into_bufs_owner_intern()?;

        Ok(TpmtPublicWCV {
            name_alg,
            object_attributes,
            auth_policy,
            typ,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<TpmtPublicWCV<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpmt_public_wcv_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    size += TpmiAlgPublic::marshalled_size() as u32;
    size += TpmiAlgHashWCV::marshalled_size() as u32;
    size += TpmaObject::marshalled_size() as u32;
    size += tpm2b_digest_marshalled_max_size() as u32;
    size += TpmuPublicParms::marshalled_max_size() as u32;

    let unique_size = match TpmuPublicId::marshalled_max_size(limits) {
        Ok(unique_size) => unique_size,
        Err(_) => return Err(()),
    };
    size = size.checked_add(unique_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 186, table 220, TPM2B_PUBLIC structure (without conditional values)
#[derive(Debug, PartialEq)]
pub struct Tpm2bPublic<'a> {
    pub public_area: TpmtPublic<'a>,
}

impl<'a> Tpm2bPublic<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2b_public_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let size_size = mem::size_of::<u16>();
        size = match size.checked_add(size_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let public_area_size = match self.public_area.marshalled_size() {
            Ok(public_area_size) => public_area_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(public_area_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let mut marshalled_size: usize = 0;

        let public_area_size = match self.public_area.marshalled_size() {
            Ok(public_area_size) => public_area_size,
            Err(_) => {
                return Err(TpmErr::InternalErr);
            },
        };
        marshalled_size = match marshalled_size.checked_add(public_area_size) {
            Some(marshalled_size) => marshalled_size,
            None => {
                return Err(TpmErr::InternalErr);
            },
        };

        let marshalled_size = match u16::try_from(marshalled_size) {
            Ok(marshalled_size) => marshalled_size,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::SIZE));
            },
        };
        let buf = marshal_u16(buf, marshalled_size)?;

        let buf = self.public_area.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_size) = match unmarshal_u16(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let unmarshalled_size = match usize::try_from(unmarshalled_size) {
            Ok(unmarshalled_size) => unmarshalled_size,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::SIZE));
            },
        };
        if unmarshalled_size == 0usize {
            return Err(TpmErr::Rc(TpmRc::SIZE));
        }
        let buf_len_at_size = buf.len();

        let (buf, unmarshalled_public_area) = match TpmtPublic::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        if unmarshalled_size != buf_len_at_size - buf.len() {
            return Err(TpmErr::Rc(TpmRc::SIZE));
        }

        Ok((buf, Self{public_area: unmarshalled_public_area}))
    }

    pub fn unmarshal(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2bPublic<'static>, TpmErr> {
        Ok(Tpm2bPublic {
            public_area: self.public_area.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2bPublic<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2bPublic<'static>, TpmErr> {
        let Self {
            public_area,
        } = self;

        let public_area = public_area.into_bufs_owner_intern()?;

        Ok(Tpm2bPublic {
            public_area,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2bPublic<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpm2b_public_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    size += mem::size_of::<u16>() as u32;

    let public_area_size = match tpmt_public_marshalled_max_size(limits) {
        Ok(public_area_size) => public_area_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(public_area_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 186, table 220, TPM2B_PUBLIC structure (with conditional values)
#[derive(Debug, PartialEq)]
pub struct Tpm2bPublicWCV<'a> {
    pub public_area: TpmtPublicWCV<'a>,
}

impl<'a> Tpm2bPublicWCV<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2b_public_wcv_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let size_size = mem::size_of::<u16>();
        size = match size.checked_add(size_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let public_area_size = match self.public_area.marshalled_size() {
            Ok(public_area_size) => public_area_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(public_area_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let mut marshalled_size: usize = 0;

        let public_area_size = match self.public_area.marshalled_size() {
            Ok(public_area_size) => public_area_size,
            Err(_) => {
                return Err(TpmErr::InternalErr);
            },
        };
        marshalled_size = match marshalled_size.checked_add(public_area_size) {
            Some(marshalled_size) => marshalled_size,
            None => {
                return Err(TpmErr::InternalErr);
            },
        };

        let marshalled_size = match u16::try_from(marshalled_size) {
            Ok(marshalled_size) => marshalled_size,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::SIZE));
            },
        };
        let buf = marshal_u16(buf, marshalled_size)?;

        let buf = self.public_area.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_size) = match unmarshal_u16(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let unmarshalled_size = match usize::try_from(unmarshalled_size) {
            Ok(unmarshalled_size) => unmarshalled_size,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::SIZE));
            },
        };
        if unmarshalled_size == 0usize {
            return Err(TpmErr::Rc(TpmRc::SIZE));
        }
        let buf_len_at_size = buf.len();

        let (buf, unmarshalled_public_area) = match TpmtPublicWCV::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        if unmarshalled_size != buf_len_at_size - buf.len() {
            return Err(TpmErr::Rc(TpmRc::SIZE));
        }

        Ok((buf, Self{public_area: unmarshalled_public_area}))
    }

    pub fn unmarshal(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2bPublicWCV<'static>, TpmErr> {
        Ok(Tpm2bPublicWCV {
            public_area: self.public_area.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2bPublicWCV<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2bPublicWCV<'static>, TpmErr> {
        let Self {
            public_area,
        } = self;

        let public_area = public_area.into_bufs_owner_intern()?;

        Ok(Tpm2bPublicWCV {
            public_area,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2bPublicWCV<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpm2b_public_wcv_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    size += mem::size_of::<u16>() as u32;

    let public_area_size = match tpmt_public_wcv_marshalled_max_size(limits) {
        Ok(public_area_size) => public_area_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(public_area_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 187, table 221, TPM2B_TEMPLATE structure
#[derive(Debug, PartialEq)]
pub struct Tpm2bTemplate<'a> {
    pub buffer: TpmBuffer<'a>,
}

impl<'a> Tpm2bTemplate<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2b_template_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let size_size = mem::size_of::<u16>();
        size = match size.checked_add(size_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let buffer_size = self.buffer.len();
        size = match size.checked_add(buffer_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let marshalled_size = match u16::try_from(self.buffer.len()) {
            Ok(marshalled_size) => marshalled_size,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::SIZE));
            },
        };
        let buf = marshal_u16(buf, marshalled_size)?;

        let buf = marshal_bytes(buf, &self.buffer)?;

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_size) = match unmarshal_u16(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let buffer_size: u16 = unmarshalled_size;
        let v0 = match tpmt_public_marshalled_max_size(limits) {
            Ok(v) => v,
            Err(_) => {
                debug_assert!(false, "Unexpected sizeof() evaluation failure");
                return Err(TpmErr::InternalErr);
            },
        };
        if buffer_size as u32 > v0 {
            return Err(TpmErr::Rc(TpmRc::SIZE));
        }
        let buffer_size = match usize::try_from(buffer_size) {
            Ok(buffer_size) => buffer_size,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::INSUFFICIENT));
            },
        };
        let (unmarshalled_buffer, buf) = match split_slice_at(buf, buffer_size) {
            Ok((unmarshalled_buffer, buf)) => (unmarshalled_buffer, buf),
            Err(e) => {
                return Err(e);
            },
        };
        let unmarshalled_buffer = TpmBuffer::from(unmarshalled_buffer);

        Ok((buf, Self{buffer: unmarshalled_buffer}))
    }

    pub fn unmarshal(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2bTemplate<'static>, TpmErr> {
        let buffer = copy_vec_from_slice(&self.buffer)?;
        let buffer = TpmBuffer::Owned(buffer);

        Ok(Tpm2bTemplate {
            buffer,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2bTemplate<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2bTemplate<'static>, TpmErr> {
        let Self {
            buffer,
        } = self;

        let buffer = buffer.into_owned()?;

        Ok(Tpm2bTemplate {
            buffer,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2bTemplate<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpm2b_template_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    size += mem::size_of::<u16>() as u32;

    let v0 = match tpmt_public_marshalled_max_size(limits) {
        Ok(v) => v,
        Err(_) => {
            debug_assert!(false, "Unexpected sizeof() evaluation failure");
            return Err(());
        },
    };
    let buffer_size = v0;
    size = size.checked_add(buffer_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 188, table 222, TPM2B_PRIVATE_VENDOR_SPECIFIC structure
#[derive(Debug, PartialEq)]
pub struct Tpm2bPrivateVendorSpecific<'a> {
    pub buffer: TpmBuffer<'a>,
}

impl<'a> Tpm2bPrivateVendorSpecific<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2b_private_vendor_specific_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let size_size = mem::size_of::<u16>();
        size = match size.checked_add(size_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let buffer_size = self.buffer.len();
        size = match size.checked_add(buffer_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let marshalled_size = match u16::try_from(self.buffer.len()) {
            Ok(marshalled_size) => marshalled_size,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::SIZE));
            },
        };
        let buf = marshal_u16(buf, marshalled_size)?;

        let buf = marshal_bytes(buf, &self.buffer)?;

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_size) = match unmarshal_u16(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let buffer_size: u16 = unmarshalled_size;
        if buffer_size > limits.private_vendor_specific_bytes {
            return Err(TpmErr::Rc(TpmRc::SIZE));
        }
        let buffer_size = match usize::try_from(buffer_size) {
            Ok(buffer_size) => buffer_size,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::INSUFFICIENT));
            },
        };
        let (unmarshalled_buffer, buf) = match split_slice_at(buf, buffer_size) {
            Ok((unmarshalled_buffer, buf)) => (unmarshalled_buffer, buf),
            Err(e) => {
                return Err(e);
            },
        };
        let unmarshalled_buffer = TpmBuffer::from(unmarshalled_buffer);

        Ok((buf, Self{buffer: unmarshalled_buffer}))
    }

    pub fn unmarshal(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2bPrivateVendorSpecific<'static>, TpmErr> {
        let buffer = copy_vec_from_slice(&self.buffer)?;
        let buffer = TpmBuffer::Owned(buffer);

        Ok(Tpm2bPrivateVendorSpecific {
            buffer,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2bPrivateVendorSpecific<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2bPrivateVendorSpecific<'static>, TpmErr> {
        let Self {
            buffer,
        } = self;

        let buffer = buffer.into_owned()?;

        Ok(Tpm2bPrivateVendorSpecific {
            buffer,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2bPrivateVendorSpecific<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpm2b_private_vendor_specific_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    size += mem::size_of::<u16>() as u32;

    let buffer_size = limits.private_vendor_specific_bytes as u32;
    size = size.checked_add(buffer_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 188, table 223, TPMU_SENSITIVE_COMPOSITE union
struct TpmuSensitiveComposite {}

impl TpmuSensitiveComposite {
    fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        let mut size: u32 = 0;

        #[cfg(feature = "rsa")]
        {
            let rsa_size = match tpm2b_private_key_rsa_marshalled_max_size(limits) {
                Ok(rsa_size) => rsa_size,
                Err(_) => {
                    return Err(());
                },
            };
            if rsa_size > size {
                size = rsa_size;
            }
        }

        #[cfg(feature = "ecc")]
        {
            let ecc_size = match tpm2b_ecc_parameter_marshalled_max_size(limits) {
                Ok(ecc_size) => ecc_size,
                Err(_) => {
                    return Err(());
                },
            };
            if ecc_size > size {
                size = ecc_size;
            }
        }

        let bits_size = match tpm2b_sensitive_data_marshalled_max_size(limits) {
            Ok(bits_size) => bits_size,
            Err(_) => {
                return Err(());
            },
        };
        if bits_size > size {
            size = bits_size;
        }

        let sym_size = match tpm2b_sym_key_marshalled_max_size(limits) {
            Ok(sym_size) => sym_size,
            Err(_) => {
                return Err(());
            },
        };
        if sym_size > size {
            size = sym_size;
        }

        let any_size = match tpm2b_private_vendor_specific_marshalled_max_size(limits) {
            Ok(any_size) => any_size,
            Err(_) => {
                return Err(());
            },
        };
        if any_size > size {
            size = any_size;
        }

        Ok(size)
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 188, table 224, TPMT_SENSITIVE structure
#[derive(Debug, PartialEq)]
pub struct TpmtSensitive<'a> {
    pub auth_value: Tpm2bDigest<'a>,
    pub seed_value: Tpm2bDigest<'a>,
    pub sensitive_type: TpmtSensitiveMemberSensitiveType<'a>,
}

impl<'a> TpmtSensitive<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpmt_sensitive_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let sensitive_type_selector_size = match usize::try_from(TpmtSensitiveMemberSensitiveType::marshalled_selector_size()) {
            Ok(sensitive_type_selector_size) => sensitive_type_selector_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(sensitive_type_selector_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let auth_value_size = match self.auth_value.marshalled_size() {
            Ok(auth_value_size) => auth_value_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(auth_value_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let seed_value_size = match self.seed_value.marshalled_size() {
            Ok(seed_value_size) => seed_value_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(seed_value_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let sensitive_type_data_size = match self.sensitive_type.marshalled_data_size() {
            Ok(sensitive_type_data_size) => sensitive_type_data_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(sensitive_type_data_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.sensitive_type.marshal_intern_selector(buf)?;

        let buf = self.auth_value.marshal(buf)?;

        let buf = self.seed_value.marshal(buf)?;

        let buf = self.sensitive_type.marshal_intern_data(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_sensitive_type_selector) = match TpmtSensitiveMemberSensitiveType::unmarshal_intern_selector(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_auth_value) = match Tpm2bDigest::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_seed_value) = match Tpm2bDigest::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_sensitive_type) = match TpmtSensitiveMemberSensitiveType::<'_>::unmarshal_intern(unmarshalled_sensitive_type_selector, buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{auth_value: unmarshalled_auth_value, seed_value: unmarshalled_seed_value, sensitive_type: unmarshalled_sensitive_type}))
    }

    pub fn unmarshal(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<TpmtSensitive<'static>, TpmErr> {
        Ok(TpmtSensitive {
            auth_value: self.auth_value.try_clone_intern()?,
            seed_value: self.seed_value.try_clone_intern()?,
            sensitive_type: self.sensitive_type.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<TpmtSensitive<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<TpmtSensitive<'static>, TpmErr> {
        let Self {
            auth_value,
            seed_value,
            sensitive_type,
        } = self;

        let auth_value = auth_value.into_bufs_owner_intern()?;
        let seed_value = seed_value.into_bufs_owner_intern()?;
        let sensitive_type = sensitive_type.into_bufs_owner_intern()?;

        Ok(TpmtSensitive {
            auth_value,
            seed_value,
            sensitive_type,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<TpmtSensitive<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpmt_sensitive_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    size += TpmiAlgPublic::marshalled_size() as u32;
    size += tpm2b_digest_marshalled_max_size() as u32;
    size += tpm2b_digest_marshalled_max_size() as u32;

    let sensitive_size = match TpmuSensitiveComposite::marshalled_max_size(limits) {
        Ok(sensitive_size) => sensitive_size,
        Err(_) => return Err(()),
    };
    size = size.checked_add(sensitive_size).ok_or(())?;

    Ok(size)
}

#[derive(Debug, PartialEq)]
#[repr(u16)]
pub enum TpmtSensitiveMemberSensitiveType<'a> {
    #[cfg(feature = "rsa")]
    Rsa(Tpm2bPrivateKeyRsa<'a>) = TpmAlgId::Rsa as u16,
    Keyedhash(Tpm2bSensitiveData<'a>) = TpmAlgId::Keyedhash as u16,
    #[cfg(feature = "ecc")]
    Ecc(Tpm2bEccParameter<'a>) = TpmAlgId::Ecc as u16,
    Symcipher(Tpm2bSymKey<'a>) = TpmAlgId::Symcipher as u16,
}

impl<'a> TpmtSensitiveMemberSensitiveType<'a> {
    const fn marshalled_selector_size() -> u16 {
        TpmiAlgPublic::marshalled_size()
    }

    fn marshalled_data_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;
        match self {
            #[cfg(feature = "rsa")]
            Self::Rsa(sensitive) => {
                let sensitive_size = match sensitive.marshalled_size() {
                    Ok(sensitive_size) => sensitive_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(sensitive_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            Self::Keyedhash(sensitive) => {
                let sensitive_size = match sensitive.marshalled_size() {
                    Ok(sensitive_size) => sensitive_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(sensitive_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            #[cfg(feature = "ecc")]
            Self::Ecc(sensitive) => {
                let sensitive_size = match sensitive.marshalled_size() {
                    Ok(sensitive_size) => sensitive_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(sensitive_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            Self::Symcipher(sensitive) => {
                let sensitive_size = match sensitive.marshalled_size() {
                    Ok(sensitive_size) => sensitive_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(sensitive_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
        };

        Ok(size)
    }


    fn marshal_intern_selector<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let selector = match self {
            #[cfg(feature = "rsa")]
            Self::Rsa(_) => TpmAlgId::Rsa as u16,
            Self::Keyedhash(_) => TpmAlgId::Keyedhash as u16,
            #[cfg(feature = "ecc")]
            Self::Ecc(_) => TpmAlgId::Ecc as u16,
            Self::Symcipher(_) => TpmAlgId::Symcipher as u16,
        };

        marshal_u16(buf, selector)
    }

    fn marshal_intern_data<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = match self {
            #[cfg(feature = "rsa")]
            Self::Rsa(sensitive) => {
                let buf = sensitive.marshal(buf)?;

                buf
            },
            Self::Keyedhash(sensitive) => {
                let buf = sensitive.marshal(buf)?;

                buf
            },
            #[cfg(feature = "ecc")]
            Self::Ecc(sensitive) => {
                let buf = sensitive.marshal(buf)?;

                buf
            },
            Self::Symcipher(sensitive) => {
                let buf = sensitive.marshal(buf)?;

                buf
            },
        };
        Ok(buf)
    }

    fn unmarshal_intern_selector(buf: &'a [u8]) -> Result<(&'a [u8], u16), TpmErr> {
        let (buf, unmarshalled_sensitive_type_selector) = match unmarshal_u16(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        Ok((buf, unmarshalled_sensitive_type_selector))
    }

    fn unmarshal_intern(selector: u16, buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, r) = match selector {
            #[cfg(feature = "rsa")]
            value if value == TpmAlgId::Rsa as u16 => {
                let (buf, unmarshalled_sensitive) = match Tpm2bPrivateKeyRsa::unmarshal_intern(buf, limits) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Rsa(unmarshalled_sensitive))
            },
            value if value == TpmAlgId::Keyedhash as u16 => {
                let (buf, unmarshalled_sensitive) = match Tpm2bSensitiveData::unmarshal_intern(buf, limits) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Keyedhash(unmarshalled_sensitive))
            },
            #[cfg(feature = "ecc")]
            value if value == TpmAlgId::Ecc as u16 => {
                let (buf, unmarshalled_sensitive) = match Tpm2bEccParameter::unmarshal_intern(buf, limits) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Ecc(unmarshalled_sensitive))
            },
            value if value == TpmAlgId::Symcipher as u16 => {
                let (buf, unmarshalled_sensitive) = match Tpm2bSymKey::unmarshal_intern(buf, limits) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::Symcipher(unmarshalled_sensitive))
            },
            _ => {
                return Err(TpmErr::Rc(TpmRc::TYPE));
            },
        };

        Ok((buf, r))
    }

    fn try_clone_intern(&self) -> Result<TpmtSensitiveMemberSensitiveType<'static>, TpmErr> {
        match self {
            #[cfg(feature = "rsa")]
            Self::Rsa(sensitive) => {
                Ok(TpmtSensitiveMemberSensitiveType::Rsa(
                    sensitive.try_clone_intern()?,
                ))
            },
            Self::Keyedhash(sensitive) => {
                Ok(TpmtSensitiveMemberSensitiveType::Keyedhash(
                    sensitive.try_clone_intern()?,
                ))
            },
            #[cfg(feature = "ecc")]
            Self::Ecc(sensitive) => {
                Ok(TpmtSensitiveMemberSensitiveType::Ecc(
                    sensitive.try_clone_intern()?,
                ))
            },
            Self::Symcipher(sensitive) => {
                Ok(TpmtSensitiveMemberSensitiveType::Symcipher(
                    sensitive.try_clone_intern()?,
                ))
            },
        }
    }

    pub fn try_clone(&self) -> Result<Box<TpmtSensitiveMemberSensitiveType<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<TpmtSensitiveMemberSensitiveType<'static>, TpmErr> {
        match self {
            #[cfg(feature = "rsa")]
            Self::Rsa(sensitive) => {
                let sensitive = sensitive.into_bufs_owner_intern()?;
                Ok(TpmtSensitiveMemberSensitiveType::Rsa(sensitive))
            },
            Self::Keyedhash(sensitive) => {
                let sensitive = sensitive.into_bufs_owner_intern()?;
                Ok(TpmtSensitiveMemberSensitiveType::Keyedhash(sensitive))
            },
            #[cfg(feature = "ecc")]
            Self::Ecc(sensitive) => {
                let sensitive = sensitive.into_bufs_owner_intern()?;
                Ok(TpmtSensitiveMemberSensitiveType::Ecc(sensitive))
            },
            Self::Symcipher(sensitive) => {
                let sensitive = sensitive.into_bufs_owner_intern()?;
                Ok(TpmtSensitiveMemberSensitiveType::Symcipher(sensitive))
            },
        }
    }
}

impl<'a> convert::From<&TpmtSensitiveMemberSensitiveType<'a>> for TpmiAlgPublic {
    fn from(value: &TpmtSensitiveMemberSensitiveType<'a>) -> Self {
        match value {
            #[cfg(feature = "rsa")]
            TpmtSensitiveMemberSensitiveType::Rsa(_) => Self::Rsa,
            TpmtSensitiveMemberSensitiveType::Keyedhash(_) => Self::Keyedhash,
            #[cfg(feature = "ecc")]
            TpmtSensitiveMemberSensitiveType::Ecc(_) => Self::Ecc,
            TpmtSensitiveMemberSensitiveType::Symcipher(_) => Self::Symcipher,
        }
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 189, table 225, TPM2B_SENSITIVE structure
#[derive(Debug, PartialEq)]
pub struct Tpm2bSensitive<'a> {
    pub size: u16,
    pub sensitive_area: TpmtSensitive<'a>,
}

impl<'a> Tpm2bSensitive<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2b_sensitive_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let size_size = mem::size_of::<u16>();
        size = match size.checked_add(size_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let sensitive_area_size = match self.sensitive_area.marshalled_size() {
            Ok(sensitive_area_size) => sensitive_area_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(sensitive_area_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = marshal_u16(buf, self.size)?;

        let buf = self.sensitive_area.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_size) = match unmarshal_u16(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_sensitive_area) = match TpmtSensitive::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{size: unmarshalled_size, sensitive_area: unmarshalled_sensitive_area}))
    }

    pub fn unmarshal(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2bSensitive<'static>, TpmErr> {
        Ok(Tpm2bSensitive {
            size: self.size,
            sensitive_area: self.sensitive_area.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2bSensitive<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2bSensitive<'static>, TpmErr> {
        let Self {
            size,
            sensitive_area,
        } = self;

        let sensitive_area = sensitive_area.into_bufs_owner_intern()?;

        Ok(Tpm2bSensitive {
            size,
            sensitive_area,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2bSensitive<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpm2b_sensitive_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    size += mem::size_of::<u16>() as u32;

    let sensitive_area_size = match tpmt_sensitive_marshalled_max_size(limits) {
        Ok(sensitive_area_size) => sensitive_area_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(sensitive_area_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 190, table 226, _PRIVATE structure
#[allow(unused)]
#[derive(Debug, PartialEq, Eq)]
struct Private {
}

fn _private_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    size += tpm2b_digest_marshalled_max_size() as u32;
    size += tpm2b_digest_marshalled_max_size() as u32;

    let sensitive_size = match tpm2b_sensitive_marshalled_max_size(limits) {
        Ok(sensitive_size) => sensitive_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(sensitive_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 190, table 227, TPM2B_PRIVATE structure
#[derive(Debug, PartialEq)]
pub struct Tpm2bPrivate<'a> {
    pub buffer: TpmBuffer<'a>,
}

impl<'a> Tpm2bPrivate<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2b_private_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let size_size = mem::size_of::<u16>();
        size = match size.checked_add(size_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let buffer_size = self.buffer.len();
        size = match size.checked_add(buffer_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let marshalled_size = match u16::try_from(self.buffer.len()) {
            Ok(marshalled_size) => marshalled_size,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::SIZE));
            },
        };
        let buf = marshal_u16(buf, marshalled_size)?;

        let buf = marshal_bytes(buf, &self.buffer)?;

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_size) = match unmarshal_u16(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let buffer_size: u16 = unmarshalled_size;
        let v0 = match _private_marshalled_max_size(limits) {
            Ok(v) => v,
            Err(_) => {
                debug_assert!(false, "Unexpected sizeof() evaluation failure");
                return Err(TpmErr::InternalErr);
            },
        };
        if buffer_size as u32 > v0 {
            return Err(TpmErr::Rc(TpmRc::SIZE));
        }
        let buffer_size = match usize::try_from(buffer_size) {
            Ok(buffer_size) => buffer_size,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::INSUFFICIENT));
            },
        };
        let (unmarshalled_buffer, buf) = match split_slice_at(buf, buffer_size) {
            Ok((unmarshalled_buffer, buf)) => (unmarshalled_buffer, buf),
            Err(e) => {
                return Err(e);
            },
        };
        let unmarshalled_buffer = TpmBuffer::from(unmarshalled_buffer);

        Ok((buf, Self{buffer: unmarshalled_buffer}))
    }

    pub fn unmarshal(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2bPrivate<'static>, TpmErr> {
        let buffer = copy_vec_from_slice(&self.buffer)?;
        let buffer = TpmBuffer::Owned(buffer);

        Ok(Tpm2bPrivate {
            buffer,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2bPrivate<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2bPrivate<'static>, TpmErr> {
        let Self {
            buffer,
        } = self;

        let buffer = buffer.into_owned()?;

        Ok(Tpm2bPrivate {
            buffer,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2bPrivate<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpm2b_private_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    size += mem::size_of::<u16>() as u32;

    let v0 = match _private_marshalled_max_size(limits) {
        Ok(v) => v,
        Err(_) => {
            debug_assert!(false, "Unexpected sizeof() evaluation failure");
            return Err(());
        },
    };
    let buffer_size = v0;
    size = size.checked_add(buffer_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 190, table 228, TPMS_ID_OBJECT structure
#[derive(Debug, PartialEq)]
pub struct TpmsIdObject<'a> {
    pub integrity_hmac: Tpm2bDigest<'a>,
    pub enc_identity: Tpm2bDigest<'a>,
}

impl<'a> TpmsIdObject<'a> {
    pub const fn marshalled_max_size() -> u16 {
        tpms_id_object_marshalled_max_size()
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let integrity_hmac_size = match self.integrity_hmac.marshalled_size() {
            Ok(integrity_hmac_size) => integrity_hmac_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(integrity_hmac_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let enc_identity_size = match self.enc_identity.marshalled_size() {
            Ok(enc_identity_size) => enc_identity_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(enc_identity_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.integrity_hmac.marshal(buf)?;

        let buf = self.enc_identity.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_integrity_hmac) = match Tpm2bDigest::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_enc_identity) = match Tpm2bDigest::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{integrity_hmac: unmarshalled_integrity_hmac, enc_identity: unmarshalled_enc_identity}))
    }

    pub fn unmarshal(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<TpmsIdObject<'static>, TpmErr> {
        Ok(TpmsIdObject {
            integrity_hmac: self.integrity_hmac.try_clone_intern()?,
            enc_identity: self.enc_identity.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<TpmsIdObject<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<TpmsIdObject<'static>, TpmErr> {
        let Self {
            integrity_hmac,
            enc_identity,
        } = self;

        let integrity_hmac = integrity_hmac.into_bufs_owner_intern()?;
        let enc_identity = enc_identity.into_bufs_owner_intern()?;

        Ok(TpmsIdObject {
            integrity_hmac,
            enc_identity,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<TpmsIdObject<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

const fn tpms_id_object_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += tpm2b_digest_marshalled_max_size();
    size += tpm2b_digest_marshalled_max_size();

    size
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 191, table 229, TPM2B_ID_OBJECT structure
#[derive(Debug, PartialEq)]
pub struct Tpm2bIdObject<'a> {
    pub credential: TpmBuffer<'a>,
}

impl<'a> Tpm2bIdObject<'a> {
    pub const fn marshalled_max_size() -> u16 {
        tpm2b_id_object_marshalled_max_size()
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let size_size = mem::size_of::<u16>();
        size = match size.checked_add(size_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let credential_size = self.credential.len();
        size = match size.checked_add(credential_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let marshalled_size = match u16::try_from(self.credential.len()) {
            Ok(marshalled_size) => marshalled_size,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::SIZE));
            },
        };
        let buf = marshal_u16(buf, marshalled_size)?;

        let buf = marshal_bytes(buf, &self.credential)?;

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_size) = match unmarshal_u16(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let credential_size: u16 = unmarshalled_size;
        if credential_size > tpms_id_object_marshalled_max_size() {
            return Err(TpmErr::Rc(TpmRc::SIZE));
        }
        let credential_size = match usize::try_from(credential_size) {
            Ok(credential_size) => credential_size,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::INSUFFICIENT));
            },
        };
        let (unmarshalled_credential, buf) = match split_slice_at(buf, credential_size) {
            Ok((unmarshalled_credential, buf)) => (unmarshalled_credential, buf),
            Err(e) => {
                return Err(e);
            },
        };
        let unmarshalled_credential = TpmBuffer::from(unmarshalled_credential);

        Ok((buf, Self{credential: unmarshalled_credential}))
    }

    pub fn unmarshal(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2bIdObject<'static>, TpmErr> {
        let credential = copy_vec_from_slice(&self.credential)?;
        let credential = TpmBuffer::Owned(credential);

        Ok(Tpm2bIdObject {
            credential,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2bIdObject<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2bIdObject<'static>, TpmErr> {
        let Self {
            credential,
        } = self;

        let credential = credential.into_owned()?;

        Ok(Tpm2bIdObject {
            credential,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2bIdObject<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

const fn tpm2b_id_object_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += mem::size_of::<u16>() as u16;
    size += tpms_id_object_marshalled_max_size();

    size
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 193, table 232, TPMS_NV_PIN_COUNTER_PARAMETERS structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct TpmsNvPinCounterParameters {
    pub pin_count: u32,
    pub pin_limit: u32,
}

impl TpmsNvPinCounterParameters {
    pub const fn marshalled_size() -> u16 {
        tpms_nv_pin_counter_parameters_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = marshal_u32(buf, self.pin_count)?;

        let buf = marshal_u32(buf, self.pin_limit)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_pin_count) = match unmarshal_u32(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_pin_limit) = match unmarshal_u32(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{pin_count: unmarshalled_pin_count, pin_limit: unmarshalled_pin_limit}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpms_nv_pin_counter_parameters_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += mem::size_of::<u32>() as u16;
    size += mem::size_of::<u32>() as u16;

    size
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 194, table 233, TPMA_NV bits
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct TpmaNv {
    value: u32,
}

impl TpmaNv {
    pub fn new() -> Self {
        Self { value: 0u32 }
    }

    const PPWRITE_MASK: u32 = 1u32 << 0u32;

    pub fn get_ppwrite(&self) -> bool {
        self.value & Self::PPWRITE_MASK != 0
    }

    pub fn set_ppwrite(&mut self, value: bool) {
        if value {
            self.value |= Self::PPWRITE_MASK;
        } else {
            self.value &= !Self::PPWRITE_MASK;
        }
    }

    const OWNERWRITE_MASK: u32 = 1u32 << 1u32;

    pub fn get_ownerwrite(&self) -> bool {
        self.value & Self::OWNERWRITE_MASK != 0
    }

    pub fn set_ownerwrite(&mut self, value: bool) {
        if value {
            self.value |= Self::OWNERWRITE_MASK;
        } else {
            self.value &= !Self::OWNERWRITE_MASK;
        }
    }

    const AUTHWRITE_MASK: u32 = 1u32 << 2u32;

    pub fn get_authwrite(&self) -> bool {
        self.value & Self::AUTHWRITE_MASK != 0
    }

    pub fn set_authwrite(&mut self, value: bool) {
        if value {
            self.value |= Self::AUTHWRITE_MASK;
        } else {
            self.value &= !Self::AUTHWRITE_MASK;
        }
    }

    const POLICYWRITE_MASK: u32 = 1u32 << 3u32;

    pub fn get_policywrite(&self) -> bool {
        self.value & Self::POLICYWRITE_MASK != 0
    }

    pub fn set_policywrite(&mut self, value: bool) {
        if value {
            self.value |= Self::POLICYWRITE_MASK;
        } else {
            self.value &= !Self::POLICYWRITE_MASK;
        }
    }

    const TPM_NT_MASK: u32 = 0xffffffffu32 >> (32u32 - 1u32 - 7u32 + 4u32) << 4u32;
    const TPM_NT_SHIFT: u32 = 4u32;

    pub fn get_tpm_nt(&self) -> u32 {
        (self.value & Self::TPM_NT_MASK) >> Self::TPM_NT_SHIFT
    }

    pub fn set_tpm_nt(&mut self, value: u32) {
        let value = value << Self::TPM_NT_SHIFT;
        debug_assert!(value & !Self::TPM_NT_MASK == 0, "invalid bitfield value");
        self.value &= !Self::TPM_NT_MASK;
        self.value |= value;
    }

    const POLICY_DELETE_MASK: u32 = 1u32 << 10u32;

    pub fn get_policy_delete(&self) -> bool {
        self.value & Self::POLICY_DELETE_MASK != 0
    }

    pub fn set_policy_delete(&mut self, value: bool) {
        if value {
            self.value |= Self::POLICY_DELETE_MASK;
        } else {
            self.value &= !Self::POLICY_DELETE_MASK;
        }
    }

    const WRITELOCKED_MASK: u32 = 1u32 << 11u32;

    pub fn get_writelocked(&self) -> bool {
        self.value & Self::WRITELOCKED_MASK != 0
    }

    pub fn set_writelocked(&mut self, value: bool) {
        if value {
            self.value |= Self::WRITELOCKED_MASK;
        } else {
            self.value &= !Self::WRITELOCKED_MASK;
        }
    }

    const WRITEALL_MASK: u32 = 1u32 << 12u32;

    pub fn get_writeall(&self) -> bool {
        self.value & Self::WRITEALL_MASK != 0
    }

    pub fn set_writeall(&mut self, value: bool) {
        if value {
            self.value |= Self::WRITEALL_MASK;
        } else {
            self.value &= !Self::WRITEALL_MASK;
        }
    }

    const WRITEDEFINE_MASK: u32 = 1u32 << 13u32;

    pub fn get_writedefine(&self) -> bool {
        self.value & Self::WRITEDEFINE_MASK != 0
    }

    pub fn set_writedefine(&mut self, value: bool) {
        if value {
            self.value |= Self::WRITEDEFINE_MASK;
        } else {
            self.value &= !Self::WRITEDEFINE_MASK;
        }
    }

    const WRITE_STCLEAR_MASK: u32 = 1u32 << 14u32;

    pub fn get_write_stclear(&self) -> bool {
        self.value & Self::WRITE_STCLEAR_MASK != 0
    }

    pub fn set_write_stclear(&mut self, value: bool) {
        if value {
            self.value |= Self::WRITE_STCLEAR_MASK;
        } else {
            self.value &= !Self::WRITE_STCLEAR_MASK;
        }
    }

    const GLOBALLOCK_MASK: u32 = 1u32 << 15u32;

    pub fn get_globallock(&self) -> bool {
        self.value & Self::GLOBALLOCK_MASK != 0
    }

    pub fn set_globallock(&mut self, value: bool) {
        if value {
            self.value |= Self::GLOBALLOCK_MASK;
        } else {
            self.value &= !Self::GLOBALLOCK_MASK;
        }
    }

    const PPREAD_MASK: u32 = 1u32 << 16u32;

    pub fn get_ppread(&self) -> bool {
        self.value & Self::PPREAD_MASK != 0
    }

    pub fn set_ppread(&mut self, value: bool) {
        if value {
            self.value |= Self::PPREAD_MASK;
        } else {
            self.value &= !Self::PPREAD_MASK;
        }
    }

    const OWNERREAD_MASK: u32 = 1u32 << 17u32;

    pub fn get_ownerread(&self) -> bool {
        self.value & Self::OWNERREAD_MASK != 0
    }

    pub fn set_ownerread(&mut self, value: bool) {
        if value {
            self.value |= Self::OWNERREAD_MASK;
        } else {
            self.value &= !Self::OWNERREAD_MASK;
        }
    }

    const AUTHREAD_MASK: u32 = 1u32 << 18u32;

    pub fn get_authread(&self) -> bool {
        self.value & Self::AUTHREAD_MASK != 0
    }

    pub fn set_authread(&mut self, value: bool) {
        if value {
            self.value |= Self::AUTHREAD_MASK;
        } else {
            self.value &= !Self::AUTHREAD_MASK;
        }
    }

    const POLICYREAD_MASK: u32 = 1u32 << 19u32;

    pub fn get_policyread(&self) -> bool {
        self.value & Self::POLICYREAD_MASK != 0
    }

    pub fn set_policyread(&mut self, value: bool) {
        if value {
            self.value |= Self::POLICYREAD_MASK;
        } else {
            self.value &= !Self::POLICYREAD_MASK;
        }
    }

    const NO_DA_MASK: u32 = 1u32 << 25u32;

    pub fn get_no_da(&self) -> bool {
        self.value & Self::NO_DA_MASK != 0
    }

    pub fn set_no_da(&mut self, value: bool) {
        if value {
            self.value |= Self::NO_DA_MASK;
        } else {
            self.value &= !Self::NO_DA_MASK;
        }
    }

    const ORDERLY_MASK: u32 = 1u32 << 26u32;

    pub fn get_orderly(&self) -> bool {
        self.value & Self::ORDERLY_MASK != 0
    }

    pub fn set_orderly(&mut self, value: bool) {
        if value {
            self.value |= Self::ORDERLY_MASK;
        } else {
            self.value &= !Self::ORDERLY_MASK;
        }
    }

    const CLEAR_STCLEAR_MASK: u32 = 1u32 << 27u32;

    pub fn get_clear_stclear(&self) -> bool {
        self.value & Self::CLEAR_STCLEAR_MASK != 0
    }

    pub fn set_clear_stclear(&mut self, value: bool) {
        if value {
            self.value |= Self::CLEAR_STCLEAR_MASK;
        } else {
            self.value &= !Self::CLEAR_STCLEAR_MASK;
        }
    }

    const READLOCKED_MASK: u32 = 1u32 << 28u32;

    pub fn get_readlocked(&self) -> bool {
        self.value & Self::READLOCKED_MASK != 0
    }

    pub fn set_readlocked(&mut self, value: bool) {
        if value {
            self.value |= Self::READLOCKED_MASK;
        } else {
            self.value &= !Self::READLOCKED_MASK;
        }
    }

    const WRITTEN_MASK: u32 = 1u32 << 29u32;

    pub fn get_written(&self) -> bool {
        self.value & Self::WRITTEN_MASK != 0
    }

    pub fn set_written(&mut self, value: bool) {
        if value {
            self.value |= Self::WRITTEN_MASK;
        } else {
            self.value &= !Self::WRITTEN_MASK;
        }
    }

    const PLATFORMCREATE_MASK: u32 = 1u32 << 30u32;

    pub fn get_platformcreate(&self) -> bool {
        self.value & Self::PLATFORMCREATE_MASK != 0
    }

    pub fn set_platformcreate(&mut self, value: bool) {
        if value {
            self.value |= Self::PLATFORMCREATE_MASK;
        } else {
            self.value &= !Self::PLATFORMCREATE_MASK;
        }
    }

    const READ_STCLEAR_MASK: u32 = 1u32 << 31u32;

    pub fn get_read_stclear(&self) -> bool {
        self.value & Self::READ_STCLEAR_MASK != 0
    }

    pub fn set_read_stclear(&mut self, value: bool) {
        if value {
            self.value |= Self::READ_STCLEAR_MASK;
        } else {
            self.value &= !Self::READ_STCLEAR_MASK;
        }
    }

    const RESERVED_MASK0: u32 = 0xffffffffu32 >> (32u32 - 1u32 - 9u32 + 8u32) << 8u32;
    const RESERVED_MASK1: u32 = 0xffffffffu32 >> (32u32 - 1u32 - 24u32 + 20u32) << 20u32;
    const RESERVED_MASK: u32 = Self::RESERVED_MASK0 | Self::RESERVED_MASK1;

    pub const fn marshalled_size() -> u16 {
        mem::size_of::<u32>() as u16
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u32(buf, self.value)
    }

    pub fn unmarshal(buf: &[u8]) -> Result<(&[u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u32(buf)?;
        let result = Self::try_from(value)?;
        Ok((buf, result))
    }
}

impl convert::TryFrom<u32> for TpmaNv {
    type Error = TpmErr;

    fn try_from(value: u32) -> Result<Self, TpmErr> {

        if value & Self::RESERVED_MASK != 0 {
            return Err(TpmErr::Rc(TpmRc::RESERVED_BITS));
        }

        Ok(Self { value })
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 197, table 234, TPMA_NV_EXP bits
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct TpmaNvExp {
    value: u64,
}

impl TpmaNvExp {
    pub fn new() -> Self {
        Self { value: 0u64 }
    }

    const PPWRITE_MASK: u64 = 1u64 << 0u32;

    pub fn get_ppwrite(&self) -> bool {
        self.value & Self::PPWRITE_MASK != 0
    }

    pub fn set_ppwrite(&mut self, value: bool) {
        if value {
            self.value |= Self::PPWRITE_MASK;
        } else {
            self.value &= !Self::PPWRITE_MASK;
        }
    }

    const OWNERWRITE_MASK: u64 = 1u64 << 1u32;

    pub fn get_ownerwrite(&self) -> bool {
        self.value & Self::OWNERWRITE_MASK != 0
    }

    pub fn set_ownerwrite(&mut self, value: bool) {
        if value {
            self.value |= Self::OWNERWRITE_MASK;
        } else {
            self.value &= !Self::OWNERWRITE_MASK;
        }
    }

    const AUTHWRITE_MASK: u64 = 1u64 << 2u32;

    pub fn get_authwrite(&self) -> bool {
        self.value & Self::AUTHWRITE_MASK != 0
    }

    pub fn set_authwrite(&mut self, value: bool) {
        if value {
            self.value |= Self::AUTHWRITE_MASK;
        } else {
            self.value &= !Self::AUTHWRITE_MASK;
        }
    }

    const POLICYWRITE_MASK: u64 = 1u64 << 3u32;

    pub fn get_policywrite(&self) -> bool {
        self.value & Self::POLICYWRITE_MASK != 0
    }

    pub fn set_policywrite(&mut self, value: bool) {
        if value {
            self.value |= Self::POLICYWRITE_MASK;
        } else {
            self.value &= !Self::POLICYWRITE_MASK;
        }
    }

    const TPM_NT_MASK: u64 = 0xffffffffffffffffu64 >> (64u32 - 1u32 - 7u32 + 4u32) << 4u32;
    const TPM_NT_SHIFT: u32 = 4u32;

    pub fn get_tpm_nt(&self) -> u64 {
        (self.value & Self::TPM_NT_MASK) >> Self::TPM_NT_SHIFT
    }

    pub fn set_tpm_nt(&mut self, value: u64) {
        let value = value << Self::TPM_NT_SHIFT;
        debug_assert!(value & !Self::TPM_NT_MASK == 0, "invalid bitfield value");
        self.value &= !Self::TPM_NT_MASK;
        self.value |= value;
    }

    const POLICY_DELETE_MASK: u64 = 1u64 << 10u32;

    pub fn get_policy_delete(&self) -> bool {
        self.value & Self::POLICY_DELETE_MASK != 0
    }

    pub fn set_policy_delete(&mut self, value: bool) {
        if value {
            self.value |= Self::POLICY_DELETE_MASK;
        } else {
            self.value &= !Self::POLICY_DELETE_MASK;
        }
    }

    const WRITELOCKED_MASK: u64 = 1u64 << 11u32;

    pub fn get_writelocked(&self) -> bool {
        self.value & Self::WRITELOCKED_MASK != 0
    }

    pub fn set_writelocked(&mut self, value: bool) {
        if value {
            self.value |= Self::WRITELOCKED_MASK;
        } else {
            self.value &= !Self::WRITELOCKED_MASK;
        }
    }

    const WRITEALL_MASK: u64 = 1u64 << 12u32;

    pub fn get_writeall(&self) -> bool {
        self.value & Self::WRITEALL_MASK != 0
    }

    pub fn set_writeall(&mut self, value: bool) {
        if value {
            self.value |= Self::WRITEALL_MASK;
        } else {
            self.value &= !Self::WRITEALL_MASK;
        }
    }

    const WRITEDEFINE_MASK: u64 = 1u64 << 13u32;

    pub fn get_writedefine(&self) -> bool {
        self.value & Self::WRITEDEFINE_MASK != 0
    }

    pub fn set_writedefine(&mut self, value: bool) {
        if value {
            self.value |= Self::WRITEDEFINE_MASK;
        } else {
            self.value &= !Self::WRITEDEFINE_MASK;
        }
    }

    const WRITE_STCLEAR_MASK: u64 = 1u64 << 14u32;

    pub fn get_write_stclear(&self) -> bool {
        self.value & Self::WRITE_STCLEAR_MASK != 0
    }

    pub fn set_write_stclear(&mut self, value: bool) {
        if value {
            self.value |= Self::WRITE_STCLEAR_MASK;
        } else {
            self.value &= !Self::WRITE_STCLEAR_MASK;
        }
    }

    const GLOBALLOCK_MASK: u64 = 1u64 << 15u32;

    pub fn get_globallock(&self) -> bool {
        self.value & Self::GLOBALLOCK_MASK != 0
    }

    pub fn set_globallock(&mut self, value: bool) {
        if value {
            self.value |= Self::GLOBALLOCK_MASK;
        } else {
            self.value &= !Self::GLOBALLOCK_MASK;
        }
    }

    const PPREAD_MASK: u64 = 1u64 << 16u32;

    pub fn get_ppread(&self) -> bool {
        self.value & Self::PPREAD_MASK != 0
    }

    pub fn set_ppread(&mut self, value: bool) {
        if value {
            self.value |= Self::PPREAD_MASK;
        } else {
            self.value &= !Self::PPREAD_MASK;
        }
    }

    const OWNERREAD_MASK: u64 = 1u64 << 17u32;

    pub fn get_ownerread(&self) -> bool {
        self.value & Self::OWNERREAD_MASK != 0
    }

    pub fn set_ownerread(&mut self, value: bool) {
        if value {
            self.value |= Self::OWNERREAD_MASK;
        } else {
            self.value &= !Self::OWNERREAD_MASK;
        }
    }

    const AUTHREAD_MASK: u64 = 1u64 << 18u32;

    pub fn get_authread(&self) -> bool {
        self.value & Self::AUTHREAD_MASK != 0
    }

    pub fn set_authread(&mut self, value: bool) {
        if value {
            self.value |= Self::AUTHREAD_MASK;
        } else {
            self.value &= !Self::AUTHREAD_MASK;
        }
    }

    const POLICYREAD_MASK: u64 = 1u64 << 19u32;

    pub fn get_policyread(&self) -> bool {
        self.value & Self::POLICYREAD_MASK != 0
    }

    pub fn set_policyread(&mut self, value: bool) {
        if value {
            self.value |= Self::POLICYREAD_MASK;
        } else {
            self.value &= !Self::POLICYREAD_MASK;
        }
    }

    const NO_DA_MASK: u64 = 1u64 << 25u32;

    pub fn get_no_da(&self) -> bool {
        self.value & Self::NO_DA_MASK != 0
    }

    pub fn set_no_da(&mut self, value: bool) {
        if value {
            self.value |= Self::NO_DA_MASK;
        } else {
            self.value &= !Self::NO_DA_MASK;
        }
    }

    const ORDERLY_MASK: u64 = 1u64 << 26u32;

    pub fn get_orderly(&self) -> bool {
        self.value & Self::ORDERLY_MASK != 0
    }

    pub fn set_orderly(&mut self, value: bool) {
        if value {
            self.value |= Self::ORDERLY_MASK;
        } else {
            self.value &= !Self::ORDERLY_MASK;
        }
    }

    const CLEAR_STCLEAR_MASK: u64 = 1u64 << 27u32;

    pub fn get_clear_stclear(&self) -> bool {
        self.value & Self::CLEAR_STCLEAR_MASK != 0
    }

    pub fn set_clear_stclear(&mut self, value: bool) {
        if value {
            self.value |= Self::CLEAR_STCLEAR_MASK;
        } else {
            self.value &= !Self::CLEAR_STCLEAR_MASK;
        }
    }

    const READLOCKED_MASK: u64 = 1u64 << 28u32;

    pub fn get_readlocked(&self) -> bool {
        self.value & Self::READLOCKED_MASK != 0
    }

    pub fn set_readlocked(&mut self, value: bool) {
        if value {
            self.value |= Self::READLOCKED_MASK;
        } else {
            self.value &= !Self::READLOCKED_MASK;
        }
    }

    const WRITTEN_MASK: u64 = 1u64 << 29u32;

    pub fn get_written(&self) -> bool {
        self.value & Self::WRITTEN_MASK != 0
    }

    pub fn set_written(&mut self, value: bool) {
        if value {
            self.value |= Self::WRITTEN_MASK;
        } else {
            self.value &= !Self::WRITTEN_MASK;
        }
    }

    const PLATFORMCREATE_MASK: u64 = 1u64 << 30u32;

    pub fn get_platformcreate(&self) -> bool {
        self.value & Self::PLATFORMCREATE_MASK != 0
    }

    pub fn set_platformcreate(&mut self, value: bool) {
        if value {
            self.value |= Self::PLATFORMCREATE_MASK;
        } else {
            self.value &= !Self::PLATFORMCREATE_MASK;
        }
    }

    const READ_STCLEAR_MASK: u64 = 1u64 << 31u32;

    pub fn get_read_stclear(&self) -> bool {
        self.value & Self::READ_STCLEAR_MASK != 0
    }

    pub fn set_read_stclear(&mut self, value: bool) {
        if value {
            self.value |= Self::READ_STCLEAR_MASK;
        } else {
            self.value &= !Self::READ_STCLEAR_MASK;
        }
    }

    const EXTERNAL_NV_ENCRYPTION_MASK: u64 = 1u64 << 32u32;

    pub fn get_external_nv_encryption(&self) -> bool {
        self.value & Self::EXTERNAL_NV_ENCRYPTION_MASK != 0
    }

    pub fn set_external_nv_encryption(&mut self, value: bool) {
        if value {
            self.value |= Self::EXTERNAL_NV_ENCRYPTION_MASK;
        } else {
            self.value &= !Self::EXTERNAL_NV_ENCRYPTION_MASK;
        }
    }

    const EXTERNAL_NV_INTEGRITY_MASK: u64 = 1u64 << 33u32;

    pub fn get_external_nv_integrity(&self) -> bool {
        self.value & Self::EXTERNAL_NV_INTEGRITY_MASK != 0
    }

    pub fn set_external_nv_integrity(&mut self, value: bool) {
        if value {
            self.value |= Self::EXTERNAL_NV_INTEGRITY_MASK;
        } else {
            self.value &= !Self::EXTERNAL_NV_INTEGRITY_MASK;
        }
    }

    const EXTERNAL_NV_ANTIROLLBACK_MASK: u64 = 1u64 << 34u32;

    pub fn get_external_nv_antirollback(&self) -> bool {
        self.value & Self::EXTERNAL_NV_ANTIROLLBACK_MASK != 0
    }

    pub fn set_external_nv_antirollback(&mut self, value: bool) {
        if value {
            self.value |= Self::EXTERNAL_NV_ANTIROLLBACK_MASK;
        } else {
            self.value &= !Self::EXTERNAL_NV_ANTIROLLBACK_MASK;
        }
    }

    const RESERVED_MASK0: u64 = 0xffffffffffffffffu64 >> (64u32 - 1u32 - 9u32 + 8u32) << 8u32;
    const RESERVED_MASK1: u64 = 0xffffffffffffffffu64 >> (64u32 - 1u32 - 24u32 + 20u32) << 20u32;
    const RESERVED_MASK2: u64 = 0xffffffffffffffffu64 >> (64u32 - 1u32 - 63u32 + 35u32) << 35u32;
    const RESERVED_MASK: u64 = Self::RESERVED_MASK0 | Self::RESERVED_MASK1 | Self::RESERVED_MASK2;

    pub const fn marshalled_size() -> u16 {
        mem::size_of::<u64>() as u16
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u64(buf, self.value)
    }

    pub fn unmarshal(buf: &[u8]) -> Result<(&[u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u64(buf)?;
        let result = Self::try_from(value)?;
        Ok((buf, result))
    }
}

impl convert::TryFrom<u64> for TpmaNvExp {
    type Error = TpmErr;

    fn try_from(value: u64) -> Result<Self, TpmErr> {

        if value & Self::RESERVED_MASK != 0 {
            return Err(TpmErr::Rc(TpmRc::RESERVED_BITS));
        }

        Ok(Self { value })
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 198, table 235, TPMS_NV_PUBLIC structure
#[derive(Debug, PartialEq)]
pub struct TpmsNvPublic<'a> {
    pub nv_index: TpmiRhNvLegacyIndex,
    pub name_alg: TpmiAlgHash,
    pub attributes: TpmaNv,
    pub auth_policy: Tpm2bDigest<'a>,
    pub data_size: u16,
}

impl<'a> TpmsNvPublic<'a> {
    pub const fn marshalled_max_size() -> u16 {
        tpms_nv_public_marshalled_max_size()
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let nv_index_size = match usize::try_from(TpmiRhNvLegacyIndex::marshalled_size()) {
            Ok(nv_index_size) => nv_index_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(nv_index_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let name_alg_size = match usize::try_from(TpmiAlgHash::marshalled_size()) {
            Ok(name_alg_size) => name_alg_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(name_alg_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let attributes_size = match usize::try_from(TpmaNv::marshalled_size()) {
            Ok(attributes_size) => attributes_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(attributes_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let data_size_size = mem::size_of::<u16>();
        size = match size.checked_add(data_size_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let auth_policy_size = match self.auth_policy.marshalled_size() {
            Ok(auth_policy_size) => auth_policy_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(auth_policy_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.nv_index.marshal(buf)?;

        let buf = self.name_alg.marshal(buf)?;

        let buf = self.attributes.marshal(buf)?;

        let buf = self.auth_policy.marshal(buf)?;

        let buf = marshal_u16(buf, self.data_size)?;

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_nv_index) = match TpmiRhNvLegacyIndex::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_name_alg) = match TpmiAlgHash::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_attributes) = match TpmaNv::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_auth_policy) = match Tpm2bDigest::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_data_size) = match unmarshal_u16(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        if unmarshalled_data_size > limits.max_nv_index_size {
            return Err(TpmErr::Rc(TpmRc::SIZE));
        }

        Ok((buf, Self{nv_index: unmarshalled_nv_index, name_alg: unmarshalled_name_alg, attributes: unmarshalled_attributes, auth_policy: unmarshalled_auth_policy, data_size: unmarshalled_data_size}))
    }

    pub fn unmarshal(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<TpmsNvPublic<'static>, TpmErr> {
        Ok(TpmsNvPublic {
            nv_index: self.nv_index,
            name_alg: self.name_alg,
            attributes: self.attributes,
            auth_policy: self.auth_policy.try_clone_intern()?,
            data_size: self.data_size,
        })
    }

    pub fn try_clone(&self) -> Result<Box<TpmsNvPublic<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<TpmsNvPublic<'static>, TpmErr> {
        let Self {
            nv_index,
            name_alg,
            attributes,
            auth_policy,
            data_size,
        } = self;

        let auth_policy = auth_policy.into_bufs_owner_intern()?;

        Ok(TpmsNvPublic {
            nv_index,
            name_alg,
            attributes,
            auth_policy,
            data_size,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<TpmsNvPublic<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

const fn tpms_nv_public_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiRhNvLegacyIndex::marshalled_size();
    size += TpmiAlgHash::marshalled_size();
    size += TpmaNv::marshalled_size();
    size += tpm2b_digest_marshalled_max_size();
    size += mem::size_of::<u16>() as u16;

    size
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 199, table 236, TPM2B_NV_PUBLIC structure
#[derive(Debug, PartialEq)]
pub struct Tpm2bNvPublic<'a> {
    pub nv_public: TpmsNvPublic<'a>,
}

impl<'a> Tpm2bNvPublic<'a> {
    pub const fn marshalled_max_size() -> u16 {
        tpm2b_nv_public_marshalled_max_size()
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let size_size = mem::size_of::<u16>();
        size = match size.checked_add(size_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let nv_public_size = match self.nv_public.marshalled_size() {
            Ok(nv_public_size) => nv_public_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(nv_public_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let mut marshalled_size: usize = 0;

        let nv_public_size = match self.nv_public.marshalled_size() {
            Ok(nv_public_size) => nv_public_size,
            Err(_) => {
                return Err(TpmErr::InternalErr);
            },
        };
        marshalled_size = match marshalled_size.checked_add(nv_public_size) {
            Some(marshalled_size) => marshalled_size,
            None => {
                return Err(TpmErr::InternalErr);
            },
        };

        let marshalled_size = match u16::try_from(marshalled_size) {
            Ok(marshalled_size) => marshalled_size,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::SIZE));
            },
        };
        let buf = marshal_u16(buf, marshalled_size)?;

        let buf = self.nv_public.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_size) = match unmarshal_u16(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let unmarshalled_size = match usize::try_from(unmarshalled_size) {
            Ok(unmarshalled_size) => unmarshalled_size,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::SIZE));
            },
        };
        if unmarshalled_size == 0usize {
            return Err(TpmErr::Rc(TpmRc::SIZE));
        }
        let buf_len_at_size = buf.len();

        let (buf, unmarshalled_nv_public) = match TpmsNvPublic::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        if unmarshalled_size != buf_len_at_size - buf.len() {
            return Err(TpmErr::Rc(TpmRc::SIZE));
        }

        Ok((buf, Self{nv_public: unmarshalled_nv_public}))
    }

    pub fn unmarshal(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2bNvPublic<'static>, TpmErr> {
        Ok(Tpm2bNvPublic {
            nv_public: self.nv_public.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2bNvPublic<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2bNvPublic<'static>, TpmErr> {
        let Self {
            nv_public,
        } = self;

        let nv_public = nv_public.into_bufs_owner_intern()?;

        Ok(Tpm2bNvPublic {
            nv_public,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2bNvPublic<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

const fn tpm2b_nv_public_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += mem::size_of::<u16>() as u16;
    size += tpms_nv_public_marshalled_max_size();

    size
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 199, table 237, TPMS_NV_PUBLIC_EXP_ATTR structure
#[derive(Debug, PartialEq)]
pub struct TpmsNvPublicExpAttr<'a> {
    pub nv_index: TpmiRhNvExpIndex,
    pub name_alg: TpmiAlgHash,
    pub attributes: TpmaNvExp,
    pub auth_policy: Tpm2bDigest<'a>,
    pub data_size: u16,
}

impl<'a> TpmsNvPublicExpAttr<'a> {
    pub const fn marshalled_max_size() -> u16 {
        tpms_nv_public_exp_attr_marshalled_max_size()
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let nv_index_size = match usize::try_from(TpmiRhNvExpIndex::marshalled_size()) {
            Ok(nv_index_size) => nv_index_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(nv_index_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let name_alg_size = match usize::try_from(TpmiAlgHash::marshalled_size()) {
            Ok(name_alg_size) => name_alg_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(name_alg_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let attributes_size = match usize::try_from(TpmaNvExp::marshalled_size()) {
            Ok(attributes_size) => attributes_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(attributes_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let data_size_size = mem::size_of::<u16>();
        size = match size.checked_add(data_size_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let auth_policy_size = match self.auth_policy.marshalled_size() {
            Ok(auth_policy_size) => auth_policy_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(auth_policy_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.nv_index.marshal(buf)?;

        let buf = self.name_alg.marshal(buf)?;

        let buf = self.attributes.marshal(buf)?;

        let buf = self.auth_policy.marshal(buf)?;

        let buf = marshal_u16(buf, self.data_size)?;

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_nv_index) = match TpmiRhNvExpIndex::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_name_alg) = match TpmiAlgHash::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_attributes) = match TpmaNvExp::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_auth_policy) = match Tpm2bDigest::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_data_size) = match unmarshal_u16(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        if unmarshalled_data_size > limits.max_nv_index_size {
            return Err(TpmErr::Rc(TpmRc::SIZE));
        }

        Ok((buf, Self{nv_index: unmarshalled_nv_index, name_alg: unmarshalled_name_alg, attributes: unmarshalled_attributes, auth_policy: unmarshalled_auth_policy, data_size: unmarshalled_data_size}))
    }

    pub fn unmarshal(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<TpmsNvPublicExpAttr<'static>, TpmErr> {
        Ok(TpmsNvPublicExpAttr {
            nv_index: self.nv_index,
            name_alg: self.name_alg,
            attributes: self.attributes,
            auth_policy: self.auth_policy.try_clone_intern()?,
            data_size: self.data_size,
        })
    }

    pub fn try_clone(&self) -> Result<Box<TpmsNvPublicExpAttr<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<TpmsNvPublicExpAttr<'static>, TpmErr> {
        let Self {
            nv_index,
            name_alg,
            attributes,
            auth_policy,
            data_size,
        } = self;

        let auth_policy = auth_policy.into_bufs_owner_intern()?;

        Ok(TpmsNvPublicExpAttr {
            nv_index,
            name_alg,
            attributes,
            auth_policy,
            data_size,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<TpmsNvPublicExpAttr<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

const fn tpms_nv_public_exp_attr_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiRhNvExpIndex::marshalled_size();
    size += TpmiAlgHash::marshalled_size();
    size += TpmaNvExp::marshalled_size();
    size += tpm2b_digest_marshalled_max_size();
    size += mem::size_of::<u16>() as u16;

    size
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 200, table 238, TPMU_NV_PUBLIC_2 union
struct TpmuNvPublic2 {}

impl TpmuNvPublic2 {
    const fn marshalled_max_size() -> u16 {
        let mut size: u16 = 0;

        let nv_index_size = tpms_nv_public_marshalled_max_size();
        if nv_index_size > size {
            size = nv_index_size;
        }

        let external_nv_size = tpms_nv_public_exp_attr_marshalled_max_size();
        if external_nv_size > size {
            size = external_nv_size;
        }

        let permanent_nv_size = tpms_nv_public_marshalled_max_size();
        if permanent_nv_size > size {
            size = permanent_nv_size;
        }

        size
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 201, table 239, TPMT_NV_PUBLIC_2 structure
#[derive(Debug, PartialEq)]
#[repr(u8)]
pub enum TpmtNvPublic2<'a> {
    NvIndex(TpmsNvPublic<'a>) = TpmHt::NV_INDEX,
    ExternalNv(TpmsNvPublicExpAttr<'a>) = TpmHt::EXTERNAL_NV,
    PermanentNv(TpmsNvPublic<'a>) = TpmHt::PERMANENT_NV,
}

impl<'a> TpmtNvPublic2<'a> {
    pub const fn marshalled_max_size() -> u16 {
        tpmt_nv_public_2_marshalled_max_size()
    }

    const fn marshalled_selector_size() -> u16 {
        TpmiHtNv::marshalled_size()
    }

    fn marshalled_data_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;
        match self {
            Self::NvIndex(public_area) => {
                let public_area_size = match public_area.marshalled_size() {
                    Ok(public_area_size) => public_area_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(public_area_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            Self::ExternalNv(public_area) => {
                let public_area_size = match public_area.marshalled_size() {
                    Ok(public_area_size) => public_area_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(public_area_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
            Self::PermanentNv(public_area) => {
                let public_area_size = match public_area.marshalled_size() {
                    Ok(public_area_size) => public_area_size,
                    Err(_) => {
                        return Err(());
                    },
                };
                size = match size.checked_add(public_area_size) {
                    Some(size) => size,
                    None => {
                        return Err(());
                    },
                };
            },
        };

        Ok(size)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let selector_size = match usize::try_from(Self::marshalled_selector_size()) {
            Ok(selector_size) => selector_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(selector_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let data_size = match self.marshalled_data_size() {
            Ok(data_size) => data_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(data_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = match self {
            Self::NvIndex(public_area) => {
                let selector = TpmHt::NV_INDEX;
                let buf = marshal_u8(buf, selector)?;

                let buf = public_area.marshal(buf)?;

                buf
            },
            Self::ExternalNv(public_area) => {
                let selector = TpmHt::EXTERNAL_NV;
                let buf = marshal_u8(buf, selector)?;

                let buf = public_area.marshal(buf)?;

                buf
            },
            Self::PermanentNv(public_area) => {
                let selector = TpmHt::PERMANENT_NV;
                let buf = marshal_u8(buf, selector)?;

                let buf = public_area.marshal(buf)?;

                buf
            },
        };
        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_handle_type) = match unmarshal_u8(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, r) = match unmarshalled_handle_type {
            value if value == TpmHt::NV_INDEX => {
                let (buf, unmarshalled_public_area) = match TpmsNvPublic::unmarshal_intern(buf, limits) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::NvIndex(unmarshalled_public_area))
            },
            value if value == TpmHt::EXTERNAL_NV => {
                let (buf, unmarshalled_public_area) = match TpmsNvPublicExpAttr::unmarshal_intern(buf, limits) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::ExternalNv(unmarshalled_public_area))
            },
            value if value == TpmHt::PERMANENT_NV => {
                let (buf, unmarshalled_public_area) = match TpmsNvPublic::unmarshal_intern(buf, limits) {
                    Ok(r) => r,
                    Err(e) => {
                        return Err(e);
                    },
                };

                (buf, Self::PermanentNv(unmarshalled_public_area))
            },
            _ => {
                return Err(TpmErr::Rc(TpmRc::VALUE));
            },
        };

        Ok((buf, r))
    }

    pub fn unmarshal(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<TpmtNvPublic2<'static>, TpmErr> {
        match self {
            Self::NvIndex(public_area) => {
                Ok(TpmtNvPublic2::NvIndex(
                    public_area.try_clone_intern()?,
                ))
            },
            Self::ExternalNv(public_area) => {
                Ok(TpmtNvPublic2::ExternalNv(
                    public_area.try_clone_intern()?,
                ))
            },
            Self::PermanentNv(public_area) => {
                Ok(TpmtNvPublic2::PermanentNv(
                    public_area.try_clone_intern()?,
                ))
            },
        }
    }

    pub fn try_clone(&self) -> Result<Box<TpmtNvPublic2<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<TpmtNvPublic2<'static>, TpmErr> {
        match self {
            Self::NvIndex(public_area) => {
                let public_area = public_area.into_bufs_owner_intern()?;
                Ok(TpmtNvPublic2::NvIndex(public_area))
            },
            Self::ExternalNv(public_area) => {
                let public_area = public_area.into_bufs_owner_intern()?;
                Ok(TpmtNvPublic2::ExternalNv(public_area))
            },
            Self::PermanentNv(public_area) => {
                let public_area = public_area.into_bufs_owner_intern()?;
                Ok(TpmtNvPublic2::PermanentNv(public_area))
            },
        }
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<TpmtNvPublic2<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

const fn tpmt_nv_public_2_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiHtNv::marshalled_size();
    size += TpmuNvPublic2::marshalled_max_size();

    size
}

impl<'a> convert::From<&TpmtNvPublic2<'a>> for TpmiHtNv {
    fn from(value: &TpmtNvPublic2<'a>) -> Self {
        match value {
            TpmtNvPublic2::NvIndex(_) => Self::NvIndex,
            TpmtNvPublic2::ExternalNv(_) => Self::ExternalNv,
            TpmtNvPublic2::PermanentNv(_) => Self::PermanentNv,
        }
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 201, table 240, TPM2B_NV_PUBLIC_2 structure
#[derive(Debug, PartialEq)]
pub struct Tpm2bNvPublic2<'a> {
    pub nv_public: TpmtNvPublic2<'a>,
}

impl<'a> Tpm2bNvPublic2<'a> {
    pub const fn marshalled_max_size() -> u16 {
        tpm2b_nv_public_2_marshalled_max_size()
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let size_size = mem::size_of::<u16>();
        size = match size.checked_add(size_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let nv_public_size = match self.nv_public.marshalled_size() {
            Ok(nv_public_size) => nv_public_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(nv_public_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let mut marshalled_size: usize = 0;

        let nv_public_size = match self.nv_public.marshalled_size() {
            Ok(nv_public_size) => nv_public_size,
            Err(_) => {
                return Err(TpmErr::InternalErr);
            },
        };
        marshalled_size = match marshalled_size.checked_add(nv_public_size) {
            Some(marshalled_size) => marshalled_size,
            None => {
                return Err(TpmErr::InternalErr);
            },
        };

        let marshalled_size = match u16::try_from(marshalled_size) {
            Ok(marshalled_size) => marshalled_size,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::SIZE));
            },
        };
        let buf = marshal_u16(buf, marshalled_size)?;

        let buf = self.nv_public.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_size) = match unmarshal_u16(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let unmarshalled_size = match usize::try_from(unmarshalled_size) {
            Ok(unmarshalled_size) => unmarshalled_size,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::SIZE));
            },
        };
        if unmarshalled_size == 0usize {
            return Err(TpmErr::Rc(TpmRc::SIZE));
        }
        let buf_len_at_size = buf.len();

        let (buf, unmarshalled_nv_public) = match TpmtNvPublic2::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        if unmarshalled_size != buf_len_at_size - buf.len() {
            return Err(TpmErr::Rc(TpmRc::SIZE));
        }

        Ok((buf, Self{nv_public: unmarshalled_nv_public}))
    }

    pub fn unmarshal(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2bNvPublic2<'static>, TpmErr> {
        Ok(Tpm2bNvPublic2 {
            nv_public: self.nv_public.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2bNvPublic2<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2bNvPublic2<'static>, TpmErr> {
        let Self {
            nv_public,
        } = self;

        let nv_public = nv_public.into_bufs_owner_intern()?;

        Ok(Tpm2bNvPublic2 {
            nv_public,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2bNvPublic2<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

const fn tpm2b_nv_public_2_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += mem::size_of::<u16>() as u16;
    size += tpmt_nv_public_2_marshalled_max_size();

    size
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 202, table 241, TPM2B_CONTEXT_SENSITIVE structure
#[derive(Debug, PartialEq)]
pub struct Tpm2bContextSensitive<'a> {
    pub buffer: TpmBuffer<'a>,
}

impl<'a> Tpm2bContextSensitive<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2b_context_sensitive_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let size_size = mem::size_of::<u16>();
        size = match size.checked_add(size_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let buffer_size = self.buffer.len();
        size = match size.checked_add(buffer_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let marshalled_size = match u16::try_from(self.buffer.len()) {
            Ok(marshalled_size) => marshalled_size,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::SIZE));
            },
        };
        let buf = marshal_u16(buf, marshalled_size)?;

        let buf = marshal_bytes(buf, &self.buffer)?;

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_size) = match unmarshal_u16(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let buffer_size: u16 = unmarshalled_size;
        if buffer_size > limits.max_context_size {
            return Err(TpmErr::Rc(TpmRc::SIZE));
        }
        let buffer_size = match usize::try_from(buffer_size) {
            Ok(buffer_size) => buffer_size,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::INSUFFICIENT));
            },
        };
        let (unmarshalled_buffer, buf) = match split_slice_at(buf, buffer_size) {
            Ok((unmarshalled_buffer, buf)) => (unmarshalled_buffer, buf),
            Err(e) => {
                return Err(e);
            },
        };
        let unmarshalled_buffer = TpmBuffer::from(unmarshalled_buffer);

        Ok((buf, Self{buffer: unmarshalled_buffer}))
    }

    pub fn unmarshal(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2bContextSensitive<'static>, TpmErr> {
        let buffer = copy_vec_from_slice(&self.buffer)?;
        let buffer = TpmBuffer::Owned(buffer);

        Ok(Tpm2bContextSensitive {
            buffer,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2bContextSensitive<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2bContextSensitive<'static>, TpmErr> {
        let Self {
            buffer,
        } = self;

        let buffer = buffer.into_owned()?;

        Ok(Tpm2bContextSensitive {
            buffer,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2bContextSensitive<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpm2b_context_sensitive_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    size += mem::size_of::<u16>() as u32;

    let buffer_size = limits.max_context_size as u32;
    size = size.checked_add(buffer_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 202, table 242, TPMS_CONTEXT_DATA structure
#[derive(Debug, PartialEq)]
pub struct TpmsContextData<'a> {
    pub integrity: Tpm2bDigest<'a>,
    pub encrypted: Tpm2bContextSensitive<'a>,
}

impl<'a> TpmsContextData<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpms_context_data_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let integrity_size = match self.integrity.marshalled_size() {
            Ok(integrity_size) => integrity_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(integrity_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let encrypted_size = match self.encrypted.marshalled_size() {
            Ok(encrypted_size) => encrypted_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(encrypted_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.integrity.marshal(buf)?;

        let buf = self.encrypted.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_integrity) = match Tpm2bDigest::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_encrypted) = match Tpm2bContextSensitive::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{integrity: unmarshalled_integrity, encrypted: unmarshalled_encrypted}))
    }

    pub fn unmarshal(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<TpmsContextData<'static>, TpmErr> {
        Ok(TpmsContextData {
            integrity: self.integrity.try_clone_intern()?,
            encrypted: self.encrypted.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<TpmsContextData<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<TpmsContextData<'static>, TpmErr> {
        let Self {
            integrity,
            encrypted,
        } = self;

        let integrity = integrity.into_bufs_owner_intern()?;
        let encrypted = encrypted.into_bufs_owner_intern()?;

        Ok(TpmsContextData {
            integrity,
            encrypted,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<TpmsContextData<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpms_context_data_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    size += tpm2b_digest_marshalled_max_size() as u32;

    let encrypted_size = match tpm2b_context_sensitive_marshalled_max_size(limits) {
        Ok(encrypted_size) => encrypted_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(encrypted_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 202, table 243, TPM2B_CONTEXT_DATA structure
#[derive(Debug, PartialEq)]
pub struct Tpm2bContextData<'a> {
    pub buffer: TpmBuffer<'a>,
}

impl<'a> Tpm2bContextData<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2b_context_data_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let size_size = mem::size_of::<u16>();
        size = match size.checked_add(size_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let buffer_size = self.buffer.len();
        size = match size.checked_add(buffer_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let marshalled_size = match u16::try_from(self.buffer.len()) {
            Ok(marshalled_size) => marshalled_size,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::SIZE));
            },
        };
        let buf = marshal_u16(buf, marshalled_size)?;

        let buf = marshal_bytes(buf, &self.buffer)?;

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_size) = match unmarshal_u16(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let buffer_size: u16 = unmarshalled_size;
        let v0 = match tpms_context_data_marshalled_max_size(limits) {
            Ok(v) => v,
            Err(_) => {
                debug_assert!(false, "Unexpected sizeof() evaluation failure");
                return Err(TpmErr::InternalErr);
            },
        };
        if buffer_size as u32 > v0 {
            return Err(TpmErr::Rc(TpmRc::SIZE));
        }
        let buffer_size = match usize::try_from(buffer_size) {
            Ok(buffer_size) => buffer_size,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::INSUFFICIENT));
            },
        };
        let (unmarshalled_buffer, buf) = match split_slice_at(buf, buffer_size) {
            Ok((unmarshalled_buffer, buf)) => (unmarshalled_buffer, buf),
            Err(e) => {
                return Err(e);
            },
        };
        let unmarshalled_buffer = TpmBuffer::from(unmarshalled_buffer);

        Ok((buf, Self{buffer: unmarshalled_buffer}))
    }

    pub fn unmarshal(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2bContextData<'static>, TpmErr> {
        let buffer = copy_vec_from_slice(&self.buffer)?;
        let buffer = TpmBuffer::Owned(buffer);

        Ok(Tpm2bContextData {
            buffer,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2bContextData<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2bContextData<'static>, TpmErr> {
        let Self {
            buffer,
        } = self;

        let buffer = buffer.into_owned()?;

        Ok(Tpm2bContextData {
            buffer,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2bContextData<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpm2b_context_data_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    size += mem::size_of::<u16>() as u32;

    let v0 = match tpms_context_data_marshalled_max_size(limits) {
        Ok(v) => v,
        Err(_) => {
            debug_assert!(false, "Unexpected sizeof() evaluation failure");
            return Err(());
        },
    };
    let buffer_size = v0;
    size = size.checked_add(buffer_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 204, table 244, TPMS_CONTEXT structure
#[derive(Debug, PartialEq)]
pub struct TpmsContext<'a> {
    pub sequence: u64,
    pub saved_handle: TpmiDhSaved,
    pub hierarchy: TpmiRhHierarchy,
    pub context_blob: Tpm2bContextData<'a>,
}

impl<'a> TpmsContext<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpms_context_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let sequence_size = mem::size_of::<u64>();
        size = match size.checked_add(sequence_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let saved_handle_size = match usize::try_from(TpmiDhSaved::marshalled_size()) {
            Ok(saved_handle_size) => saved_handle_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(saved_handle_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let hierarchy_size = match usize::try_from(TpmiRhHierarchy::marshalled_size()) {
            Ok(hierarchy_size) => hierarchy_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(hierarchy_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let context_blob_size = match self.context_blob.marshalled_size() {
            Ok(context_blob_size) => context_blob_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(context_blob_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = marshal_u64(buf, self.sequence)?;

        let buf = self.saved_handle.marshal(buf)?;

        let buf = self.hierarchy.marshal(buf)?;

        let buf = self.context_blob.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_sequence) = match unmarshal_u64(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_saved_handle) = match TpmiDhSaved::unmarshal(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_hierarchy) = match TpmiRhHierarchy::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_context_blob) = match Tpm2bContextData::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{sequence: unmarshalled_sequence, saved_handle: unmarshalled_saved_handle, hierarchy: unmarshalled_hierarchy, context_blob: unmarshalled_context_blob}))
    }

    pub fn unmarshal(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<TpmsContext<'static>, TpmErr> {
        Ok(TpmsContext {
            sequence: self.sequence,
            saved_handle: self.saved_handle,
            hierarchy: self.hierarchy,
            context_blob: self.context_blob.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<TpmsContext<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<TpmsContext<'static>, TpmErr> {
        let Self {
            sequence,
            saved_handle,
            hierarchy,
            context_blob,
        } = self;

        let context_blob = context_blob.into_bufs_owner_intern()?;

        Ok(TpmsContext {
            sequence,
            saved_handle,
            hierarchy,
            context_blob,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<TpmsContext<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpms_context_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    size += mem::size_of::<u64>() as u32;
    size += TpmiDhSaved::marshalled_size() as u32;
    size += TpmiRhHierarchy::marshalled_size() as u32;

    let context_blob_size = match tpm2b_context_data_marshalled_max_size(limits) {
        Ok(context_blob_size) => context_blob_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(context_blob_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 206, table 246, TPMS_CREATION_DATA structure
#[derive(Debug, PartialEq)]
pub struct TpmsCreationData<'a> {
    pub pcr_select: TpmlPcrSelection<'a>,
    pub pcr_digest: Tpm2bDigest<'a>,
    pub locality: TpmaLocality,
    pub parent_name_alg: TpmAlgId,
    pub parent_name: Tpm2bName<'a>,
    pub parent_qualified_name: Tpm2bName<'a>,
    pub outside_info: Tpm2bData<'a>,
}

impl<'a> TpmsCreationData<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpms_creation_data_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let locality_size = match usize::try_from(TpmaLocality::marshalled_size()) {
            Ok(locality_size) => locality_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(locality_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let parent_name_alg_size = match usize::try_from(TpmAlgId::marshalled_size()) {
            Ok(parent_name_alg_size) => parent_name_alg_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(parent_name_alg_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let pcr_select_size = match self.pcr_select.marshalled_size() {
            Ok(pcr_select_size) => pcr_select_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(pcr_select_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let pcr_digest_size = match self.pcr_digest.marshalled_size() {
            Ok(pcr_digest_size) => pcr_digest_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(pcr_digest_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let parent_name_size = match self.parent_name.marshalled_size() {
            Ok(parent_name_size) => parent_name_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(parent_name_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let parent_qualified_name_size = match self.parent_qualified_name.marshalled_size() {
            Ok(parent_qualified_name_size) => parent_qualified_name_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(parent_qualified_name_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let outside_info_size = match self.outside_info.marshalled_size() {
            Ok(outside_info_size) => outside_info_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(outside_info_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.pcr_select.marshal(buf)?;

        let buf = self.pcr_digest.marshal(buf)?;

        let buf = self.locality.marshal(buf)?;

        let buf = self.parent_name_alg.marshal(buf)?;

        let buf = self.parent_name.marshal(buf)?;

        let buf = self.parent_qualified_name.marshal(buf)?;

        let buf = self.outside_info.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_pcr_select) = match TpmlPcrSelection::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_pcr_digest) = match Tpm2bDigest::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_locality) = match TpmaLocality::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_parent_name_alg) = match TpmAlgId::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_parent_name) = match Tpm2bName::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_parent_qualified_name) = match Tpm2bName::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_outside_info) = match Tpm2bData::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{pcr_select: unmarshalled_pcr_select, pcr_digest: unmarshalled_pcr_digest, locality: unmarshalled_locality, parent_name_alg: unmarshalled_parent_name_alg, parent_name: unmarshalled_parent_name, parent_qualified_name: unmarshalled_parent_qualified_name, outside_info: unmarshalled_outside_info}))
    }

    pub fn unmarshal(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<TpmsCreationData<'static>, TpmErr> {
        Ok(TpmsCreationData {
            pcr_select: self.pcr_select.try_clone_intern()?,
            pcr_digest: self.pcr_digest.try_clone_intern()?,
            locality: self.locality,
            parent_name_alg: self.parent_name_alg,
            parent_name: self.parent_name.try_clone_intern()?,
            parent_qualified_name: self.parent_qualified_name.try_clone_intern()?,
            outside_info: self.outside_info.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<TpmsCreationData<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<TpmsCreationData<'static>, TpmErr> {
        let Self {
            pcr_select,
            pcr_digest,
            locality,
            parent_name_alg,
            parent_name,
            parent_qualified_name,
            outside_info,
        } = self;

        let pcr_select = pcr_select.into_bufs_owner_intern()?;
        let pcr_digest = pcr_digest.into_bufs_owner_intern()?;
        let parent_name = parent_name.into_bufs_owner_intern()?;
        let parent_qualified_name = parent_qualified_name.into_bufs_owner_intern()?;
        let outside_info = outside_info.into_bufs_owner_intern()?;

        Ok(TpmsCreationData {
            pcr_select,
            pcr_digest,
            locality,
            parent_name_alg,
            parent_name,
            parent_qualified_name,
            outside_info,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<TpmsCreationData<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpms_creation_data_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    size += tpm2b_digest_marshalled_max_size() as u32;
    size += TpmaLocality::marshalled_size() as u32;
    size += TpmAlgId::marshalled_size() as u32;
    size += tpm2b_name_marshalled_max_size() as u32;
    size += tpm2b_name_marshalled_max_size() as u32;
    size += tpm2b_data_marshalled_max_size() as u32;

    let pcr_select_size = match tpml_pcr_selection_marshalled_max_size(limits) {
        Ok(pcr_select_size) => pcr_select_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(pcr_select_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 206, table 247, TPM2B_CREATION_DATA structure
#[derive(Debug, PartialEq)]
pub struct Tpm2bCreationData<'a> {
    pub creation_data: TpmsCreationData<'a>,
}

impl<'a> Tpm2bCreationData<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2b_creation_data_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let size_size = mem::size_of::<u16>();
        size = match size.checked_add(size_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let creation_data_size = match self.creation_data.marshalled_size() {
            Ok(creation_data_size) => creation_data_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(creation_data_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let mut marshalled_size: usize = 0;

        let creation_data_size = match self.creation_data.marshalled_size() {
            Ok(creation_data_size) => creation_data_size,
            Err(_) => {
                return Err(TpmErr::InternalErr);
            },
        };
        marshalled_size = match marshalled_size.checked_add(creation_data_size) {
            Some(marshalled_size) => marshalled_size,
            None => {
                return Err(TpmErr::InternalErr);
            },
        };

        let marshalled_size = match u16::try_from(marshalled_size) {
            Ok(marshalled_size) => marshalled_size,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::SIZE));
            },
        };
        let buf = marshal_u16(buf, marshalled_size)?;

        let buf = self.creation_data.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_size) = match unmarshal_u16(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let unmarshalled_size = match usize::try_from(unmarshalled_size) {
            Ok(unmarshalled_size) => unmarshalled_size,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::SIZE));
            },
        };
        if unmarshalled_size == 0usize {
            return Err(TpmErr::Rc(TpmRc::SIZE));
        }
        let buf_len_at_size = buf.len();

        let (buf, unmarshalled_creation_data) = match TpmsCreationData::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        if unmarshalled_size != buf_len_at_size - buf.len() {
            return Err(TpmErr::Rc(TpmRc::SIZE));
        }

        Ok((buf, Self{creation_data: unmarshalled_creation_data}))
    }

    pub fn unmarshal(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2bCreationData<'static>, TpmErr> {
        Ok(Tpm2bCreationData {
            creation_data: self.creation_data.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2bCreationData<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2bCreationData<'static>, TpmErr> {
        let Self {
            creation_data,
        } = self;

        let creation_data = creation_data.into_bufs_owner_intern()?;

        Ok(Tpm2bCreationData {
            creation_data,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2bCreationData<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpm2b_creation_data_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    size += mem::size_of::<u16>() as u32;

    let creation_data_size = match tpms_creation_data_marshalled_max_size(limits) {
        Ok(creation_data_size) => creation_data_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(creation_data_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 207, table 248, TPM_AT constants
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u32)]
pub enum TpmAt {
    Any = 0x0u32,
    Error = 0x1u32,
    Pv1 = 0x2u32,
    Vend = 0x80000000u32,
}

impl TpmAt {
    const fn marshalled_size() -> u16 {
        mem::size_of::<u32>() as u16
    }

    fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u32(buf, *self as u32)
    }

    fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u32(buf)?;
        let result = Self::try_from(value)?;
        Ok((buf, result))
    }
}

impl convert::TryFrom<u32> for TpmAt {
    type Error = TpmErr;

    fn try_from(value: u32) -> Result<Self, TpmErr> {
        let result = match value {
            value if value == Self::Any as u32 => Self::Any,
            value if value == Self::Error as u32 => Self::Error,
            value if value == Self::Pv1 as u32 => Self::Pv1,
            value if value == Self::Vend as u32 => Self::Vend,
            _ => {
                return Err(TpmErr::Rc(TpmRc::VALUE));
            },
        };

        Ok(result)
    }
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 207, table 250, TPMS_AC_OUTPUT structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct TpmsAcOutput {
    pub tag: TpmAt,
    pub data: u32,
}

impl TpmsAcOutput {
    pub const fn marshalled_size() -> u16 {
        tpms_ac_output_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.tag.marshal(buf)?;

        let buf = marshal_u32(buf, self.data)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_tag) = match TpmAt::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_data) = match unmarshal_u32(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{tag: unmarshalled_tag, data: unmarshalled_data}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpms_ac_output_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmAt::marshalled_size();
    size += mem::size_of::<u32>() as u16;

    size
}

// TCG TPM2 Library, Version 184, Part 2 -- Structures, page 208, table 251, TPML_AC_CAPABILITIES structure
#[derive(Debug, PartialEq, Eq)]
pub struct TpmlAcCapabilities {
    pub ac_capabilities: Vec<TpmsAcOutput>,
}

impl TpmlAcCapabilities {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpml_ac_capabilities_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let count_size = mem::size_of::<u32>();
        size = match size.checked_add(count_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let ac_capabilities_len = self.ac_capabilities.len();
        let ac_capabilities_element_size = match usize::try_from(tpms_ac_output_marshalled_size()) {
            Ok(ac_capabilities_element_size) => ac_capabilities_element_size,
            Err(_) => {
                return Err(());
            },
        };
        let ac_capabilities_size = match ac_capabilities_len.checked_mul(ac_capabilities_element_size) {
            Some(ac_capabilities_size) => ac_capabilities_size,
            None => {
                return Err(());
            },
        };
        size = match size.checked_add(ac_capabilities_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let marshalled_count = match u32::try_from(self.ac_capabilities.len()) {
            Ok(marshalled_count) => marshalled_count,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::SIZE));
            },
        };
        let buf = marshal_u32(buf, marshalled_count)?;

        let mut buf = buf;
        for element in self.ac_capabilities.iter() {
            let remaining = element.marshal(buf)?;
            buf = remaining;
        }

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_count) = match unmarshal_u32(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let ac_capabilities_len: u32 = unmarshalled_count;
        let v0 = match limits.max_ac_capabilities() {
            Ok(v) => v,
            Err(_) => {
                debug_assert!(false, "Unexpected runtime constant evaluation failure");
                return Err(TpmErr::InternalErr);
            },
        };
        if ac_capabilities_len > v0 {
            return Err(TpmErr::Rc(TpmRc::SIZE));
        }
        let ac_capabilities_len = match usize::try_from(ac_capabilities_len) {
            Ok(ac_capabilities_len) => ac_capabilities_len,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::INSUFFICIENT));
            },
        };
        let mut unmarshalled_ac_capabilities: Vec<TpmsAcOutput> = Vec::new();
        if unmarshalled_ac_capabilities.try_reserve_exact(ac_capabilities_len).is_err() {
            return Err(TpmErr::Rc(TpmRc::MEMORY));
        }
        let mut buf = buf;
        for _i in 0..ac_capabilities_len {
            let (remaining, unmarshalled_element) = match TpmsAcOutput::unmarshal_intern(buf) {
                Ok(r) => r,
                Err(e) => {
                    return Err(e);
                },
            };
            unmarshalled_ac_capabilities.push(unmarshalled_element);
            buf = remaining;
        }

        Ok((buf, Self{ac_capabilities: unmarshalled_ac_capabilities}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<TpmlAcCapabilities, TpmErr> {
        let ac_capabilities = copy_vec_from_slice(&self.ac_capabilities)?;

        Ok(TpmlAcCapabilities {
            ac_capabilities,
        })
    }

    pub fn try_clone(&self) -> Result<Box<TpmlAcCapabilities>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpml_ac_capabilities_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    size += mem::size_of::<u32>() as u32;

    let v0 = match limits.max_ac_capabilities() {
        Ok(v) => v,
        Err(_) => {
            debug_assert!(false, "Unexpected runtime constant evaluation failure");
            return Err(());
        },
    };
    let ac_capabilities_size = v0;
    let ac_capabilities_size = ac_capabilities_size.checked_mul(tpms_ac_output_marshalled_size() as u32).ok_or(())?;
    size = size.checked_add(ac_capabilities_size).ok_or(())?;

    Ok(size)
}

// Vendor amendment to TCG Algorithm Registry, RSA_KEY_BITS constants
#[cfg(all(feature = "rsa", any(feature = "rsa1024", feature = "rsa16384", feature = "rsa2048", feature = "rsa3072", feature = "rsa4096", feature = "rsa8192")))]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[cfg_attr(any(feature = "rsa1024", feature = "rsa16384", feature = "rsa2048", feature = "rsa3072", feature = "rsa4096", feature = "rsa8192"), repr(u16))]
enum RsaKeyBits {
    #[cfg(feature = "rsa1024")]
    Bits1024 = 1024u16,
    #[cfg(feature = "rsa2048")]
    Bits2048 = 2048u16,
    #[cfg(feature = "rsa3072")]
    Bits3072 = 3072u16,
    #[cfg(feature = "rsa4096")]
    Bits4096 = 4096u16,
    #[cfg(feature = "rsa8192")]
    Bits8192 = 8192u16,
    #[cfg(feature = "rsa16384")]
    Bits16384 = 16384u16,
}

// Vendor amendment to TCG TPM2 Library, Part 2 -- Structures, TPMS_EMPTY structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct TpmsEmpty {
}

impl TpmsEmpty {
    pub const fn marshalled_size() -> u16 {
        tpms_empty_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        Ok((buf, Self{}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpms_empty_marshalled_size() -> u16 {
    let size: u16 = 0;
    size
}

// Vendor amendment to TCG TPM2 Library, Part 2 -- Structures, TPMU_SET_CAPABILITIES union
struct TpmuSetCapabilities {}

impl TpmuSetCapabilities {
    const fn marshalled_max_size() -> u16 {
        let mut size: u16 = 0;

        size
    }
}

// Vendor amendment to TCG TPM2 Library, Part 2 -- Structures, TPMI_HT_NV type
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u8)]
pub enum TpmiHtNv {
    NvIndex = TpmHt::NV_INDEX,
    ExternalNv = TpmHt::EXTERNAL_NV,
    PermanentNv = TpmHt::PERMANENT_NV,
}

impl TpmiHtNv {
    pub const fn marshalled_size() -> u16 {
        mem::size_of::<u8>() as u16
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        marshal_u8(buf, *self as u8)
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, value) = unmarshal_u8(buf)?;
        let result = Self::try_from(value)?;
        Ok((buf, result))
    }
}

impl convert::TryFrom<u8> for TpmiHtNv {
    type Error = TpmErr;

    fn try_from(value: u8) -> Result<Self, TpmErr> {
        let result = match value {
            value if value == Self::NvIndex as u8 => Self::NvIndex,
            value if value == Self::ExternalNv as u8 => Self::ExternalNv,
            value if value == Self::PermanentNv as u8 => Self::PermanentNv,
            _ => {
                return Err(TpmErr::Rc(TpmRc::VALUE));
            },
        };

        Ok(result)
    }
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 45, table 4, TPM2_Startup_COMMAND_PARAMS structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2StartupCommandParams {
    pub startup_type: TpmSu,
}

impl Tpm2StartupCommandParams {
    pub const fn marshalled_size() -> u16 {
        tpm2_startup_command_params_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.startup_type.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_startup_type) = match TpmSu::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{startup_type: unmarshalled_startup_type}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_startup_command_params_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmSu::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 47, table 6, TPM2_Shutdown_COMMAND_PARAMS structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2ShutdownCommandParams {
    pub shutdown_type: TpmSu,
}

impl Tpm2ShutdownCommandParams {
    pub const fn marshalled_size() -> u16 {
        tpm2_shutdown_command_params_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.shutdown_type.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_shutdown_type) = match TpmSu::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{shutdown_type: unmarshalled_shutdown_type}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_shutdown_command_params_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmSu::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 50, table 8, TPM2_SelfTest_COMMAND_PARAMS structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2SelfTestCommandParams {
    pub full_test: TpmiYesNo,
}

impl Tpm2SelfTestCommandParams {
    pub const fn marshalled_size() -> u16 {
        tpm2_selftest_command_params_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.full_test.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_full_test) = match TpmiYesNo::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{full_test: unmarshalled_full_test}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_selftest_command_params_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiYesNo::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 53, table 10, TPM2_IncrementalSelfTest_COMMAND_PARAMS structure
#[derive(Debug, PartialEq, Eq)]
pub struct Tpm2IncrementalSelfTestCommandParams {
    pub to_test: TpmlAlg,
}

impl Tpm2IncrementalSelfTestCommandParams {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2_incrementalselftest_command_params_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let to_test_size = match self.to_test.marshalled_size() {
            Ok(to_test_size) => to_test_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(to_test_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.to_test.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_to_test) = match TpmlAlg::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{to_test: unmarshalled_to_test}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2IncrementalSelfTestCommandParams, TpmErr> {
        Ok(Tpm2IncrementalSelfTestCommandParams {
            to_test: self.to_test.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2IncrementalSelfTestCommandParams>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpm2_incrementalselftest_command_params_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    let to_test_size = match tpml_alg_marshalled_max_size(limits) {
        Ok(to_test_size) => to_test_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(to_test_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 53, table 11, TPM2_IncrementalSelfTest_RESPONSE_PARAMS structure
#[derive(Debug, PartialEq, Eq)]
pub struct Tpm2IncrementalSelfTestResponseParams {
    pub to_do_list: TpmlAlg,
}

impl Tpm2IncrementalSelfTestResponseParams {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2_incrementalselftest_response_params_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let to_do_list_size = match self.to_do_list.marshalled_size() {
            Ok(to_do_list_size) => to_do_list_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(to_do_list_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.to_do_list.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_to_do_list) = match TpmlAlg::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{to_do_list: unmarshalled_to_do_list}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2IncrementalSelfTestResponseParams, TpmErr> {
        Ok(Tpm2IncrementalSelfTestResponseParams {
            to_do_list: self.to_do_list.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2IncrementalSelfTestResponseParams>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpm2_incrementalselftest_response_params_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    let to_do_list_size = match tpml_alg_marshalled_max_size(limits) {
        Ok(to_do_list_size) => to_do_list_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(to_do_list_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 55, table 13, TPM2_GetTestResult_RESPONSE_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2GetTestResultResponseParams<'a> {
    pub out_data: Tpm2bMaxBuffer<'a>,
    pub test_result: TpmRc,
}

impl<'a> Tpm2GetTestResultResponseParams<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2_gettestresult_response_params_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let test_result_size = match usize::try_from(TpmRc::marshalled_size()) {
            Ok(test_result_size) => test_result_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(test_result_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let out_data_size = match self.out_data.marshalled_size() {
            Ok(out_data_size) => out_data_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(out_data_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.out_data.marshal(buf)?;

        let buf = self.test_result.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_out_data) = match Tpm2bMaxBuffer::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        let (buf, unmarshalled_test_result) = match TpmRc::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{out_data: unmarshalled_out_data, test_result: unmarshalled_test_result}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2GetTestResultResponseParams<'static>, TpmErr> {
        Ok(Tpm2GetTestResultResponseParams {
            out_data: self.out_data.try_clone_intern()?,
            test_result: self.test_result,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2GetTestResultResponseParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2GetTestResultResponseParams<'static>, TpmErr> {
        let Self {
            out_data,
            test_result,
        } = self;

        let out_data = out_data.into_bufs_owner_intern()?;

        Ok(Tpm2GetTestResultResponseParams {
            out_data,
            test_result,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2GetTestResultResponseParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpm2_gettestresult_response_params_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    size += TpmRc::marshalled_size() as u32;

    let out_data_size = match tpm2b_max_buffer_marshalled_max_size(limits) {
        Ok(out_data_size) => out_data_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(out_data_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 59, table 14, TPM2_StartAuthSession_COMMAND_HANDLES structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2StartAuthSessionCommandHandles {
    pub tpm_key: TpmiDhObjectWCV,
    pub bind: TpmiDhEntityWCV,
}

impl Tpm2StartAuthSessionCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_startauthsession_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.tpm_key.marshal(buf)?;

        let buf = self.bind.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_tpm_key) = match TpmiDhObjectWCV::unmarshal(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_bind) = match TpmiDhEntityWCV::unmarshal(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{tpm_key: unmarshalled_tpm_key, bind: unmarshalled_bind}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_startauthsession_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiDhObjectWCV::marshalled_size();
    size += TpmiDhEntityWCV::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 59, table 14, TPM2_StartAuthSession_COMMAND_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2StartAuthSessionCommandParams<'a> {
    pub nonce_caller: Tpm2bDigest<'a>,
    pub encrypted_salt: Tpm2bEncryptedSecret<'a>,
    pub session_type: TpmSe,
    pub symmetric: TpmtSymDefWCV,
    pub auth_hash: TpmiAlgHash,
}

impl<'a> Tpm2StartAuthSessionCommandParams<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2_startauthsession_command_params_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let session_type_size = match usize::try_from(TpmSe::marshalled_size()) {
            Ok(session_type_size) => session_type_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(session_type_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let auth_hash_size = match usize::try_from(TpmiAlgHash::marshalled_size()) {
            Ok(auth_hash_size) => auth_hash_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(auth_hash_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let nonce_caller_size = match self.nonce_caller.marshalled_size() {
            Ok(nonce_caller_size) => nonce_caller_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(nonce_caller_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let encrypted_salt_size = match self.encrypted_salt.marshalled_size() {
            Ok(encrypted_salt_size) => encrypted_salt_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(encrypted_salt_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let symmetric_size = match self.symmetric.marshalled_size() {
            Ok(symmetric_size) => symmetric_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(symmetric_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.nonce_caller.marshal(buf)?;

        let buf = self.encrypted_salt.marshal(buf)?;

        let buf = self.session_type.marshal(buf)?;

        let buf = self.symmetric.marshal(buf)?;

        let buf = self.auth_hash.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_nonce_caller) = match Tpm2bDigest::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        let (buf, unmarshalled_encrypted_salt) = match Tpm2bEncryptedSecret::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_session_type) = match TpmSe::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_symmetric) = match TpmtSymDefWCV::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_auth_hash) = match TpmiAlgHash::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{nonce_caller: unmarshalled_nonce_caller, encrypted_salt: unmarshalled_encrypted_salt, session_type: unmarshalled_session_type, symmetric: unmarshalled_symmetric, auth_hash: unmarshalled_auth_hash}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2StartAuthSessionCommandParams<'static>, TpmErr> {
        Ok(Tpm2StartAuthSessionCommandParams {
            nonce_caller: self.nonce_caller.try_clone_intern()?,
            encrypted_salt: self.encrypted_salt.try_clone_intern()?,
            session_type: self.session_type,
            symmetric: self.symmetric,
            auth_hash: self.auth_hash,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2StartAuthSessionCommandParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2StartAuthSessionCommandParams<'static>, TpmErr> {
        let Self {
            nonce_caller,
            encrypted_salt,
            session_type,
            symmetric,
            auth_hash,
        } = self;

        let nonce_caller = nonce_caller.into_bufs_owner_intern()?;
        let encrypted_salt = encrypted_salt.into_bufs_owner_intern()?;

        Ok(Tpm2StartAuthSessionCommandParams {
            nonce_caller,
            encrypted_salt,
            session_type,
            symmetric,
            auth_hash,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2StartAuthSessionCommandParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpm2_startauthsession_command_params_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    size += tpm2b_digest_marshalled_max_size() as u32;
    size += TpmSe::marshalled_size() as u32;
    size += tpmt_sym_def_wcv_marshalled_max_size() as u32;
    size += TpmiAlgHash::marshalled_size() as u32;

    let encrypted_salt_size = match tpm2b_encrypted_secret_marshalled_max_size(limits) {
        Ok(encrypted_salt_size) => encrypted_salt_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(encrypted_salt_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 59, table 15, TPM2_StartAuthSession_RESPONSE_HANDLES structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2StartAuthSessionResponseHandles {
    pub session_handle: TpmiShAuthSession,
}

impl Tpm2StartAuthSessionResponseHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_startauthsession_response_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.session_handle.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_session_handle) = match TpmiShAuthSession::unmarshal(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{session_handle: unmarshalled_session_handle}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_startauthsession_response_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiShAuthSession::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 59, table 15, TPM2_StartAuthSession_RESPONSE_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2StartAuthSessionResponseParams<'a> {
    pub nonce_tpm: Tpm2bDigest<'a>,
}

impl<'a> Tpm2StartAuthSessionResponseParams<'a> {
    pub const fn marshalled_max_size() -> u16 {
        tpm2_startauthsession_response_params_marshalled_max_size()
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let nonce_tpm_size = match self.nonce_tpm.marshalled_size() {
            Ok(nonce_tpm_size) => nonce_tpm_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(nonce_tpm_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.nonce_tpm.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_nonce_tpm) = match Tpm2bDigest::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        Ok((buf, Self{nonce_tpm: unmarshalled_nonce_tpm}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2StartAuthSessionResponseParams<'static>, TpmErr> {
        Ok(Tpm2StartAuthSessionResponseParams {
            nonce_tpm: self.nonce_tpm.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2StartAuthSessionResponseParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2StartAuthSessionResponseParams<'static>, TpmErr> {
        let Self {
            nonce_tpm,
        } = self;

        let nonce_tpm = nonce_tpm.into_bufs_owner_intern()?;

        Ok(Tpm2StartAuthSessionResponseParams {
            nonce_tpm,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2StartAuthSessionResponseParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

const fn tpm2_startauthsession_response_params_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += tpm2b_digest_marshalled_max_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 62, table 16, TPM2_PolicyRestart_COMMAND_HANDLES structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2PolicyRestartCommandHandles {
    pub session_handle: TpmiShPolicy,
}

impl Tpm2PolicyRestartCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_policyrestart_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.session_handle.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_session_handle) = match TpmiShPolicy::unmarshal(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{session_handle: unmarshalled_session_handle}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_policyrestart_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiShPolicy::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 67, table 18, TPM2_Create_COMMAND_HANDLES structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2CreateCommandHandles {
    pub parent_handle: TpmiDhObject,
}

impl Tpm2CreateCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_create_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.parent_handle.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_parent_handle) = match TpmiDhObject::unmarshal(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{parent_handle: unmarshalled_parent_handle}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_create_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiDhObject::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 67, table 18, TPM2_Create_COMMAND_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2CreateCommandParams<'a> {
    pub in_sensitive: Tpm2bSensitiveCreate<'a>,
    pub in_public: Tpm2bPublic<'a>,
    pub outside_info: Tpm2bData<'a>,
    pub creation_pcr: TpmlPcrSelection<'a>,
}

impl<'a> Tpm2CreateCommandParams<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2_create_command_params_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let in_sensitive_size = match self.in_sensitive.marshalled_size() {
            Ok(in_sensitive_size) => in_sensitive_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(in_sensitive_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let in_public_size = match self.in_public.marshalled_size() {
            Ok(in_public_size) => in_public_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(in_public_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let outside_info_size = match self.outside_info.marshalled_size() {
            Ok(outside_info_size) => outside_info_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(outside_info_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let creation_pcr_size = match self.creation_pcr.marshalled_size() {
            Ok(creation_pcr_size) => creation_pcr_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(creation_pcr_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.in_sensitive.marshal(buf)?;

        let buf = self.in_public.marshal(buf)?;

        let buf = self.outside_info.marshal(buf)?;

        let buf = self.creation_pcr.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_in_sensitive) = match Tpm2bSensitiveCreate::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        let (buf, unmarshalled_in_public) = match Tpm2bPublic::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_outside_info) = match Tpm2bData::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_creation_pcr) = match TpmlPcrSelection::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{in_sensitive: unmarshalled_in_sensitive, in_public: unmarshalled_in_public, outside_info: unmarshalled_outside_info, creation_pcr: unmarshalled_creation_pcr}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2CreateCommandParams<'static>, TpmErr> {
        Ok(Tpm2CreateCommandParams {
            in_sensitive: self.in_sensitive.try_clone_intern()?,
            in_public: self.in_public.try_clone_intern()?,
            outside_info: self.outside_info.try_clone_intern()?,
            creation_pcr: self.creation_pcr.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2CreateCommandParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2CreateCommandParams<'static>, TpmErr> {
        let Self {
            in_sensitive,
            in_public,
            outside_info,
            creation_pcr,
        } = self;

        let in_sensitive = in_sensitive.into_bufs_owner_intern()?;
        let in_public = in_public.into_bufs_owner_intern()?;
        let outside_info = outside_info.into_bufs_owner_intern()?;
        let creation_pcr = creation_pcr.into_bufs_owner_intern()?;

        Ok(Tpm2CreateCommandParams {
            in_sensitive,
            in_public,
            outside_info,
            creation_pcr,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2CreateCommandParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpm2_create_command_params_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    size += tpm2b_data_marshalled_max_size() as u32;

    let in_sensitive_size = match tpm2b_sensitive_create_marshalled_max_size(limits) {
        Ok(in_sensitive_size) => in_sensitive_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(in_sensitive_size).ok_or(())?;

    let in_public_size = match tpm2b_public_marshalled_max_size(limits) {
        Ok(in_public_size) => in_public_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(in_public_size).ok_or(())?;

    let creation_pcr_size = match tpml_pcr_selection_marshalled_max_size(limits) {
        Ok(creation_pcr_size) => creation_pcr_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(creation_pcr_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 67, table 19, TPM2_Create_RESPONSE_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2CreateResponseParams<'a> {
    pub out_private: Tpm2bPrivate<'a>,
    pub out_public: Tpm2bPublic<'a>,
    pub creation_data: Tpm2bCreationData<'a>,
    pub creation_hash: Tpm2bDigest<'a>,
    pub creation_ticket: TpmtTkCreation<'a>,
}

impl<'a> Tpm2CreateResponseParams<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2_create_response_params_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let out_private_size = match self.out_private.marshalled_size() {
            Ok(out_private_size) => out_private_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(out_private_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let out_public_size = match self.out_public.marshalled_size() {
            Ok(out_public_size) => out_public_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(out_public_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let creation_data_size = match self.creation_data.marshalled_size() {
            Ok(creation_data_size) => creation_data_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(creation_data_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let creation_hash_size = match self.creation_hash.marshalled_size() {
            Ok(creation_hash_size) => creation_hash_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(creation_hash_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let creation_ticket_size = match self.creation_ticket.marshalled_size() {
            Ok(creation_ticket_size) => creation_ticket_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(creation_ticket_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.out_private.marshal(buf)?;

        let buf = self.out_public.marshal(buf)?;

        let buf = self.creation_data.marshal(buf)?;

        let buf = self.creation_hash.marshal(buf)?;

        let buf = self.creation_ticket.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_out_private) = match Tpm2bPrivate::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        let (buf, unmarshalled_out_public) = match Tpm2bPublic::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_creation_data) = match Tpm2bCreationData::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_creation_hash) = match Tpm2bDigest::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_creation_ticket) = match TpmtTkCreation::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{out_private: unmarshalled_out_private, out_public: unmarshalled_out_public, creation_data: unmarshalled_creation_data, creation_hash: unmarshalled_creation_hash, creation_ticket: unmarshalled_creation_ticket}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2CreateResponseParams<'static>, TpmErr> {
        Ok(Tpm2CreateResponseParams {
            out_private: self.out_private.try_clone_intern()?,
            out_public: self.out_public.try_clone_intern()?,
            creation_data: self.creation_data.try_clone_intern()?,
            creation_hash: self.creation_hash.try_clone_intern()?,
            creation_ticket: self.creation_ticket.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2CreateResponseParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2CreateResponseParams<'static>, TpmErr> {
        let Self {
            out_private,
            out_public,
            creation_data,
            creation_hash,
            creation_ticket,
        } = self;

        let out_private = out_private.into_bufs_owner_intern()?;
        let out_public = out_public.into_bufs_owner_intern()?;
        let creation_data = creation_data.into_bufs_owner_intern()?;
        let creation_hash = creation_hash.into_bufs_owner_intern()?;
        let creation_ticket = creation_ticket.into_bufs_owner_intern()?;

        Ok(Tpm2CreateResponseParams {
            out_private,
            out_public,
            creation_data,
            creation_hash,
            creation_ticket,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2CreateResponseParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpm2_create_response_params_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    size += tpm2b_digest_marshalled_max_size() as u32;
    size += tpmt_tk_creation_marshalled_max_size() as u32;

    let out_private_size = match tpm2b_private_marshalled_max_size(limits) {
        Ok(out_private_size) => out_private_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(out_private_size).ok_or(())?;

    let out_public_size = match tpm2b_public_marshalled_max_size(limits) {
        Ok(out_public_size) => out_public_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(out_public_size).ok_or(())?;

    let creation_data_size = match tpm2b_creation_data_marshalled_max_size(limits) {
        Ok(creation_data_size) => creation_data_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(creation_data_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 70, table 20, TPM2_Load_COMMAND_HANDLES structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2LoadCommandHandles {
    pub parent_handle: TpmiDhObject,
}

impl Tpm2LoadCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_load_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.parent_handle.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_parent_handle) = match TpmiDhObject::unmarshal(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{parent_handle: unmarshalled_parent_handle}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_load_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiDhObject::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 70, table 20, TPM2_Load_COMMAND_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2LoadCommandParams<'a> {
    pub in_private: Tpm2bPrivate<'a>,
    pub in_public: Tpm2bPublic<'a>,
}

impl<'a> Tpm2LoadCommandParams<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2_load_command_params_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let in_private_size = match self.in_private.marshalled_size() {
            Ok(in_private_size) => in_private_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(in_private_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let in_public_size = match self.in_public.marshalled_size() {
            Ok(in_public_size) => in_public_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(in_public_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.in_private.marshal(buf)?;

        let buf = self.in_public.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_in_private) = match Tpm2bPrivate::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        let (buf, unmarshalled_in_public) = match Tpm2bPublic::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{in_private: unmarshalled_in_private, in_public: unmarshalled_in_public}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2LoadCommandParams<'static>, TpmErr> {
        Ok(Tpm2LoadCommandParams {
            in_private: self.in_private.try_clone_intern()?,
            in_public: self.in_public.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2LoadCommandParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2LoadCommandParams<'static>, TpmErr> {
        let Self {
            in_private,
            in_public,
        } = self;

        let in_private = in_private.into_bufs_owner_intern()?;
        let in_public = in_public.into_bufs_owner_intern()?;

        Ok(Tpm2LoadCommandParams {
            in_private,
            in_public,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2LoadCommandParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpm2_load_command_params_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    let in_private_size = match tpm2b_private_marshalled_max_size(limits) {
        Ok(in_private_size) => in_private_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(in_private_size).ok_or(())?;

    let in_public_size = match tpm2b_public_marshalled_max_size(limits) {
        Ok(in_public_size) => in_public_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(in_public_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 70, table 21, TPM2_Load_RESPONSE_HANDLES structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2LoadResponseHandles {
    pub object_handle: u32,
}

impl Tpm2LoadResponseHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_load_response_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = marshal_u32(buf, self.object_handle)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_object_handle) = match unmarshal_u32(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{object_handle: unmarshalled_object_handle}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_load_response_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += mem::size_of::<u32>() as u16;

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 70, table 21, TPM2_Load_RESPONSE_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2LoadResponseParams<'a> {
    pub name: Tpm2bName<'a>,
}

impl<'a> Tpm2LoadResponseParams<'a> {
    pub const fn marshalled_max_size() -> u16 {
        tpm2_load_response_params_marshalled_max_size()
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let name_size = match self.name.marshalled_size() {
            Ok(name_size) => name_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(name_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.name.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_name) = match Tpm2bName::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        Ok((buf, Self{name: unmarshalled_name}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2LoadResponseParams<'static>, TpmErr> {
        Ok(Tpm2LoadResponseParams {
            name: self.name.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2LoadResponseParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2LoadResponseParams<'static>, TpmErr> {
        let Self {
            name,
        } = self;

        let name = name.into_bufs_owner_intern()?;

        Ok(Tpm2LoadResponseParams {
            name,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2LoadResponseParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

const fn tpm2_load_response_params_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += tpm2b_name_marshalled_max_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 73, table 22, TPM2_LoadExternal_COMMAND_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2LoadExternalCommandParams<'a> {
    pub in_private: Tpm2bSensitive<'a>,
    pub in_public: Tpm2bPublicWCV<'a>,
    pub hierarchy: TpmiRhHierarchy,
}

impl<'a> Tpm2LoadExternalCommandParams<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2_loadexternal_command_params_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let hierarchy_size = match usize::try_from(TpmiRhHierarchy::marshalled_size()) {
            Ok(hierarchy_size) => hierarchy_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(hierarchy_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let in_private_size = match self.in_private.marshalled_size() {
            Ok(in_private_size) => in_private_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(in_private_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let in_public_size = match self.in_public.marshalled_size() {
            Ok(in_public_size) => in_public_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(in_public_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.in_private.marshal(buf)?;

        let buf = self.in_public.marshal(buf)?;

        let buf = self.hierarchy.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_in_private) = match Tpm2bSensitive::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_in_public) = match Tpm2bPublicWCV::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_hierarchy) = match TpmiRhHierarchy::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{in_private: unmarshalled_in_private, in_public: unmarshalled_in_public, hierarchy: unmarshalled_hierarchy}))
    }

    pub fn unmarshal(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2LoadExternalCommandParams<'static>, TpmErr> {
        Ok(Tpm2LoadExternalCommandParams {
            in_private: self.in_private.try_clone_intern()?,
            in_public: self.in_public.try_clone_intern()?,
            hierarchy: self.hierarchy,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2LoadExternalCommandParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2LoadExternalCommandParams<'static>, TpmErr> {
        let Self {
            in_private,
            in_public,
            hierarchy,
        } = self;

        let in_private = in_private.into_bufs_owner_intern()?;
        let in_public = in_public.into_bufs_owner_intern()?;

        Ok(Tpm2LoadExternalCommandParams {
            in_private,
            in_public,
            hierarchy,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2LoadExternalCommandParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpm2_loadexternal_command_params_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    size += TpmiRhHierarchy::marshalled_size() as u32;

    let in_private_size = match tpm2b_sensitive_marshalled_max_size(limits) {
        Ok(in_private_size) => in_private_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(in_private_size).ok_or(())?;

    let in_public_size = match tpm2b_public_wcv_marshalled_max_size(limits) {
        Ok(in_public_size) => in_public_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(in_public_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 73, table 23, TPM2_LoadExternal_RESPONSE_HANDLES structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2LoadExternalResponseHandles {
    pub object_handle: u32,
}

impl Tpm2LoadExternalResponseHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_loadexternal_response_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = marshal_u32(buf, self.object_handle)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_object_handle) = match unmarshal_u32(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{object_handle: unmarshalled_object_handle}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_loadexternal_response_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += mem::size_of::<u32>() as u16;

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 73, table 23, TPM2_LoadExternal_RESPONSE_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2LoadExternalResponseParams<'a> {
    pub name: Tpm2bName<'a>,
}

impl<'a> Tpm2LoadExternalResponseParams<'a> {
    pub const fn marshalled_max_size() -> u16 {
        tpm2_loadexternal_response_params_marshalled_max_size()
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let name_size = match self.name.marshalled_size() {
            Ok(name_size) => name_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(name_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.name.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_name) = match Tpm2bName::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        Ok((buf, Self{name: unmarshalled_name}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2LoadExternalResponseParams<'static>, TpmErr> {
        Ok(Tpm2LoadExternalResponseParams {
            name: self.name.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2LoadExternalResponseParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2LoadExternalResponseParams<'static>, TpmErr> {
        let Self {
            name,
        } = self;

        let name = name.into_bufs_owner_intern()?;

        Ok(Tpm2LoadExternalResponseParams {
            name,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2LoadExternalResponseParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

const fn tpm2_loadexternal_response_params_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += tpm2b_name_marshalled_max_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 75, table 24, TPM2_ReadPublic_COMMAND_HANDLES structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2ReadPublicCommandHandles {
    pub object_handle: TpmiDhObject,
}

impl Tpm2ReadPublicCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_readpublic_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.object_handle.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_object_handle) = match TpmiDhObject::unmarshal(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{object_handle: unmarshalled_object_handle}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_readpublic_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiDhObject::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 75, table 25, TPM2_ReadPublic_RESPONSE_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2ReadPublicResponseParams<'a> {
    pub out_public: Tpm2bPublic<'a>,
    pub name: Tpm2bName<'a>,
    pub qualified_name: Tpm2bName<'a>,
}

impl<'a> Tpm2ReadPublicResponseParams<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2_readpublic_response_params_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let out_public_size = match self.out_public.marshalled_size() {
            Ok(out_public_size) => out_public_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(out_public_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let name_size = match self.name.marshalled_size() {
            Ok(name_size) => name_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(name_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let qualified_name_size = match self.qualified_name.marshalled_size() {
            Ok(qualified_name_size) => qualified_name_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(qualified_name_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.out_public.marshal(buf)?;

        let buf = self.name.marshal(buf)?;

        let buf = self.qualified_name.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_out_public) = match Tpm2bPublic::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        let (buf, unmarshalled_name) = match Tpm2bName::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_qualified_name) = match Tpm2bName::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{out_public: unmarshalled_out_public, name: unmarshalled_name, qualified_name: unmarshalled_qualified_name}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2ReadPublicResponseParams<'static>, TpmErr> {
        Ok(Tpm2ReadPublicResponseParams {
            out_public: self.out_public.try_clone_intern()?,
            name: self.name.try_clone_intern()?,
            qualified_name: self.qualified_name.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2ReadPublicResponseParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2ReadPublicResponseParams<'static>, TpmErr> {
        let Self {
            out_public,
            name,
            qualified_name,
        } = self;

        let out_public = out_public.into_bufs_owner_intern()?;
        let name = name.into_bufs_owner_intern()?;
        let qualified_name = qualified_name.into_bufs_owner_intern()?;

        Ok(Tpm2ReadPublicResponseParams {
            out_public,
            name,
            qualified_name,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2ReadPublicResponseParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpm2_readpublic_response_params_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    size += tpm2b_name_marshalled_max_size() as u32;
    size += tpm2b_name_marshalled_max_size() as u32;

    let out_public_size = match tpm2b_public_marshalled_max_size(limits) {
        Ok(out_public_size) => out_public_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(out_public_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 77, table 26, TPM2_ActivateCredential_COMMAND_HANDLES structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2ActivateCredentialCommandHandles {
    pub activate_handle: TpmiDhObject,
    pub key_handle: TpmiDhObject,
}

impl Tpm2ActivateCredentialCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_activatecredential_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.activate_handle.marshal(buf)?;

        let buf = self.key_handle.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_activate_handle) = match TpmiDhObject::unmarshal(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_key_handle) = match TpmiDhObject::unmarshal(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{activate_handle: unmarshalled_activate_handle, key_handle: unmarshalled_key_handle}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_activatecredential_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiDhObject::marshalled_size();
    size += TpmiDhObject::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 77, table 26, TPM2_ActivateCredential_COMMAND_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2ActivateCredentialCommandParams<'a> {
    pub credential_blob: Tpm2bIdObject<'a>,
    pub secret: Tpm2bEncryptedSecret<'a>,
}

impl<'a> Tpm2ActivateCredentialCommandParams<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2_activatecredential_command_params_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let credential_blob_size = match self.credential_blob.marshalled_size() {
            Ok(credential_blob_size) => credential_blob_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(credential_blob_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let secret_size = match self.secret.marshalled_size() {
            Ok(secret_size) => secret_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(secret_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.credential_blob.marshal(buf)?;

        let buf = self.secret.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_credential_blob) = match Tpm2bIdObject::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        let (buf, unmarshalled_secret) = match Tpm2bEncryptedSecret::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{credential_blob: unmarshalled_credential_blob, secret: unmarshalled_secret}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2ActivateCredentialCommandParams<'static>, TpmErr> {
        Ok(Tpm2ActivateCredentialCommandParams {
            credential_blob: self.credential_blob.try_clone_intern()?,
            secret: self.secret.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2ActivateCredentialCommandParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2ActivateCredentialCommandParams<'static>, TpmErr> {
        let Self {
            credential_blob,
            secret,
        } = self;

        let credential_blob = credential_blob.into_bufs_owner_intern()?;
        let secret = secret.into_bufs_owner_intern()?;

        Ok(Tpm2ActivateCredentialCommandParams {
            credential_blob,
            secret,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2ActivateCredentialCommandParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpm2_activatecredential_command_params_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    size += tpm2b_id_object_marshalled_max_size() as u32;

    let secret_size = match tpm2b_encrypted_secret_marshalled_max_size(limits) {
        Ok(secret_size) => secret_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(secret_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 77, table 27, TPM2_ActivateCredential_RESPONSE_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2ActivateCredentialResponseParams<'a> {
    pub cert_info: Tpm2bDigest<'a>,
}

impl<'a> Tpm2ActivateCredentialResponseParams<'a> {
    pub const fn marshalled_max_size() -> u16 {
        tpm2_activatecredential_response_params_marshalled_max_size()
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let cert_info_size = match self.cert_info.marshalled_size() {
            Ok(cert_info_size) => cert_info_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(cert_info_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.cert_info.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_cert_info) = match Tpm2bDigest::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        Ok((buf, Self{cert_info: unmarshalled_cert_info}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2ActivateCredentialResponseParams<'static>, TpmErr> {
        Ok(Tpm2ActivateCredentialResponseParams {
            cert_info: self.cert_info.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2ActivateCredentialResponseParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2ActivateCredentialResponseParams<'static>, TpmErr> {
        let Self {
            cert_info,
        } = self;

        let cert_info = cert_info.into_bufs_owner_intern()?;

        Ok(Tpm2ActivateCredentialResponseParams {
            cert_info,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2ActivateCredentialResponseParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

const fn tpm2_activatecredential_response_params_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += tpm2b_digest_marshalled_max_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 79, table 28, TPM2_MakeCredential_COMMAND_HANDLES structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2MakeCredentialCommandHandles {
    pub handle: TpmiDhObject,
}

impl Tpm2MakeCredentialCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_makecredential_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.handle.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_handle) = match TpmiDhObject::unmarshal(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{handle: unmarshalled_handle}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_makecredential_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiDhObject::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 79, table 28, TPM2_MakeCredential_COMMAND_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2MakeCredentialCommandParams<'a> {
    pub credential: Tpm2bDigest<'a>,
    pub object_name: Tpm2bName<'a>,
}

impl<'a> Tpm2MakeCredentialCommandParams<'a> {
    pub const fn marshalled_max_size() -> u16 {
        tpm2_makecredential_command_params_marshalled_max_size()
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let credential_size = match self.credential.marshalled_size() {
            Ok(credential_size) => credential_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(credential_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let object_name_size = match self.object_name.marshalled_size() {
            Ok(object_name_size) => object_name_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(object_name_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.credential.marshal(buf)?;

        let buf = self.object_name.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_credential) = match Tpm2bDigest::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        let (buf, unmarshalled_object_name) = match Tpm2bName::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{credential: unmarshalled_credential, object_name: unmarshalled_object_name}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2MakeCredentialCommandParams<'static>, TpmErr> {
        Ok(Tpm2MakeCredentialCommandParams {
            credential: self.credential.try_clone_intern()?,
            object_name: self.object_name.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2MakeCredentialCommandParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2MakeCredentialCommandParams<'static>, TpmErr> {
        let Self {
            credential,
            object_name,
        } = self;

        let credential = credential.into_bufs_owner_intern()?;
        let object_name = object_name.into_bufs_owner_intern()?;

        Ok(Tpm2MakeCredentialCommandParams {
            credential,
            object_name,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2MakeCredentialCommandParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

const fn tpm2_makecredential_command_params_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += tpm2b_digest_marshalled_max_size();
    size += tpm2b_name_marshalled_max_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 79, table 29, TPM2_MakeCredential_RESPONSE_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2MakeCredentialResponseParams<'a> {
    pub credential_blob: Tpm2bIdObject<'a>,
    pub secret: Tpm2bEncryptedSecret<'a>,
}

impl<'a> Tpm2MakeCredentialResponseParams<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2_makecredential_response_params_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let credential_blob_size = match self.credential_blob.marshalled_size() {
            Ok(credential_blob_size) => credential_blob_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(credential_blob_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let secret_size = match self.secret.marshalled_size() {
            Ok(secret_size) => secret_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(secret_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.credential_blob.marshal(buf)?;

        let buf = self.secret.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_credential_blob) = match Tpm2bIdObject::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        let (buf, unmarshalled_secret) = match Tpm2bEncryptedSecret::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{credential_blob: unmarshalled_credential_blob, secret: unmarshalled_secret}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2MakeCredentialResponseParams<'static>, TpmErr> {
        Ok(Tpm2MakeCredentialResponseParams {
            credential_blob: self.credential_blob.try_clone_intern()?,
            secret: self.secret.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2MakeCredentialResponseParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2MakeCredentialResponseParams<'static>, TpmErr> {
        let Self {
            credential_blob,
            secret,
        } = self;

        let credential_blob = credential_blob.into_bufs_owner_intern()?;
        let secret = secret.into_bufs_owner_intern()?;

        Ok(Tpm2MakeCredentialResponseParams {
            credential_blob,
            secret,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2MakeCredentialResponseParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpm2_makecredential_response_params_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    size += tpm2b_id_object_marshalled_max_size() as u32;

    let secret_size = match tpm2b_encrypted_secret_marshalled_max_size(limits) {
        Ok(secret_size) => secret_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(secret_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 81, table 30, TPM2_Unseal_COMMAND_HANDLES structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2UnsealCommandHandles {
    pub item_handle: TpmiDhObject,
}

impl Tpm2UnsealCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_unseal_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.item_handle.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_item_handle) = match TpmiDhObject::unmarshal(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{item_handle: unmarshalled_item_handle}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_unseal_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiDhObject::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 81, table 31, TPM2_Unseal_RESPONSE_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2UnsealResponseParams<'a> {
    pub out_data: Tpm2bSensitiveData<'a>,
}

impl<'a> Tpm2UnsealResponseParams<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2_unseal_response_params_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let out_data_size = match self.out_data.marshalled_size() {
            Ok(out_data_size) => out_data_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(out_data_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.out_data.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_out_data) = match Tpm2bSensitiveData::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        Ok((buf, Self{out_data: unmarshalled_out_data}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2UnsealResponseParams<'static>, TpmErr> {
        Ok(Tpm2UnsealResponseParams {
            out_data: self.out_data.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2UnsealResponseParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2UnsealResponseParams<'static>, TpmErr> {
        let Self {
            out_data,
        } = self;

        let out_data = out_data.into_bufs_owner_intern()?;

        Ok(Tpm2UnsealResponseParams {
            out_data,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2UnsealResponseParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpm2_unseal_response_params_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    let out_data_size = match tpm2b_sensitive_data_marshalled_max_size(limits) {
        Ok(out_data_size) => out_data_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(out_data_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 83, table 32, TPM2_ObjectChangeAuth_COMMAND_HANDLES structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2ObjectChangeAuthCommandHandles {
    pub object_handle: TpmiDhObject,
    pub parent_handle: TpmiDhObject,
}

impl Tpm2ObjectChangeAuthCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_objectchangeauth_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.object_handle.marshal(buf)?;

        let buf = self.parent_handle.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_object_handle) = match TpmiDhObject::unmarshal(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_parent_handle) = match TpmiDhObject::unmarshal(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{object_handle: unmarshalled_object_handle, parent_handle: unmarshalled_parent_handle}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_objectchangeauth_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiDhObject::marshalled_size();
    size += TpmiDhObject::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 83, table 32, TPM2_ObjectChangeAuth_COMMAND_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2ObjectChangeAuthCommandParams<'a> {
    pub new_auth: Tpm2bDigest<'a>,
}

impl<'a> Tpm2ObjectChangeAuthCommandParams<'a> {
    pub const fn marshalled_max_size() -> u16 {
        tpm2_objectchangeauth_command_params_marshalled_max_size()
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let new_auth_size = match self.new_auth.marshalled_size() {
            Ok(new_auth_size) => new_auth_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(new_auth_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.new_auth.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_new_auth) = match Tpm2bDigest::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        Ok((buf, Self{new_auth: unmarshalled_new_auth}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2ObjectChangeAuthCommandParams<'static>, TpmErr> {
        Ok(Tpm2ObjectChangeAuthCommandParams {
            new_auth: self.new_auth.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2ObjectChangeAuthCommandParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2ObjectChangeAuthCommandParams<'static>, TpmErr> {
        let Self {
            new_auth,
        } = self;

        let new_auth = new_auth.into_bufs_owner_intern()?;

        Ok(Tpm2ObjectChangeAuthCommandParams {
            new_auth,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2ObjectChangeAuthCommandParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

const fn tpm2_objectchangeauth_command_params_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += tpm2b_digest_marshalled_max_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 83, table 33, TPM2_ObjectChangeAuth_RESPONSE_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2ObjectChangeAuthResponseParams<'a> {
    pub out_private: Tpm2bPrivate<'a>,
}

impl<'a> Tpm2ObjectChangeAuthResponseParams<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2_objectchangeauth_response_params_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let out_private_size = match self.out_private.marshalled_size() {
            Ok(out_private_size) => out_private_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(out_private_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.out_private.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_out_private) = match Tpm2bPrivate::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        Ok((buf, Self{out_private: unmarshalled_out_private}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2ObjectChangeAuthResponseParams<'static>, TpmErr> {
        Ok(Tpm2ObjectChangeAuthResponseParams {
            out_private: self.out_private.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2ObjectChangeAuthResponseParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2ObjectChangeAuthResponseParams<'static>, TpmErr> {
        let Self {
            out_private,
        } = self;

        let out_private = out_private.into_bufs_owner_intern()?;

        Ok(Tpm2ObjectChangeAuthResponseParams {
            out_private,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2ObjectChangeAuthResponseParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpm2_objectchangeauth_response_params_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    let out_private_size = match tpm2b_private_marshalled_max_size(limits) {
        Ok(out_private_size) => out_private_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(out_private_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 85, table 34, TPM2_CreateLoaded_COMMAND_HANDLES structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2CreateLoadedCommandHandles {
    pub parent_handle: TpmiDhParent,
}

impl Tpm2CreateLoadedCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_createloaded_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.parent_handle.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_parent_handle) = match TpmiDhParent::unmarshal(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{parent_handle: unmarshalled_parent_handle}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_createloaded_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiDhParent::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 85, table 34, TPM2_CreateLoaded_COMMAND_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2CreateLoadedCommandParams<'a> {
    pub in_sensitive: Tpm2bSensitiveCreate<'a>,
    pub in_public: Tpm2bTemplate<'a>,
}

impl<'a> Tpm2CreateLoadedCommandParams<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2_createloaded_command_params_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let in_sensitive_size = match self.in_sensitive.marshalled_size() {
            Ok(in_sensitive_size) => in_sensitive_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(in_sensitive_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let in_public_size = match self.in_public.marshalled_size() {
            Ok(in_public_size) => in_public_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(in_public_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.in_sensitive.marshal(buf)?;

        let buf = self.in_public.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_in_sensitive) = match Tpm2bSensitiveCreate::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        let (buf, unmarshalled_in_public) = match Tpm2bTemplate::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{in_sensitive: unmarshalled_in_sensitive, in_public: unmarshalled_in_public}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2CreateLoadedCommandParams<'static>, TpmErr> {
        Ok(Tpm2CreateLoadedCommandParams {
            in_sensitive: self.in_sensitive.try_clone_intern()?,
            in_public: self.in_public.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2CreateLoadedCommandParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2CreateLoadedCommandParams<'static>, TpmErr> {
        let Self {
            in_sensitive,
            in_public,
        } = self;

        let in_sensitive = in_sensitive.into_bufs_owner_intern()?;
        let in_public = in_public.into_bufs_owner_intern()?;

        Ok(Tpm2CreateLoadedCommandParams {
            in_sensitive,
            in_public,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2CreateLoadedCommandParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpm2_createloaded_command_params_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    let in_sensitive_size = match tpm2b_sensitive_create_marshalled_max_size(limits) {
        Ok(in_sensitive_size) => in_sensitive_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(in_sensitive_size).ok_or(())?;

    let in_public_size = match tpm2b_template_marshalled_max_size(limits) {
        Ok(in_public_size) => in_public_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(in_public_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 85, table 35, TPM2_CreateLoaded_RESPONSE_HANDLES structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2CreateLoadedResponseHandles {
    pub object_handle: u32,
}

impl Tpm2CreateLoadedResponseHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_createloaded_response_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = marshal_u32(buf, self.object_handle)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_object_handle) = match unmarshal_u32(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{object_handle: unmarshalled_object_handle}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_createloaded_response_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += mem::size_of::<u32>() as u16;

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 85, table 35, TPM2_CreateLoaded_RESPONSE_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2CreateLoadedResponseParams<'a> {
    pub out_private: Tpm2bPrivate<'a>,
    pub out_public: Tpm2bPublic<'a>,
    pub name: Tpm2bName<'a>,
}

impl<'a> Tpm2CreateLoadedResponseParams<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2_createloaded_response_params_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let out_private_size = match self.out_private.marshalled_size() {
            Ok(out_private_size) => out_private_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(out_private_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let out_public_size = match self.out_public.marshalled_size() {
            Ok(out_public_size) => out_public_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(out_public_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let name_size = match self.name.marshalled_size() {
            Ok(name_size) => name_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(name_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.out_private.marshal(buf)?;

        let buf = self.out_public.marshal(buf)?;

        let buf = self.name.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_out_private) = match Tpm2bPrivate::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        let (buf, unmarshalled_out_public) = match Tpm2bPublic::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_name) = match Tpm2bName::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{out_private: unmarshalled_out_private, out_public: unmarshalled_out_public, name: unmarshalled_name}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2CreateLoadedResponseParams<'static>, TpmErr> {
        Ok(Tpm2CreateLoadedResponseParams {
            out_private: self.out_private.try_clone_intern()?,
            out_public: self.out_public.try_clone_intern()?,
            name: self.name.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2CreateLoadedResponseParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2CreateLoadedResponseParams<'static>, TpmErr> {
        let Self {
            out_private,
            out_public,
            name,
        } = self;

        let out_private = out_private.into_bufs_owner_intern()?;
        let out_public = out_public.into_bufs_owner_intern()?;
        let name = name.into_bufs_owner_intern()?;

        Ok(Tpm2CreateLoadedResponseParams {
            out_private,
            out_public,
            name,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2CreateLoadedResponseParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpm2_createloaded_response_params_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    size += tpm2b_name_marshalled_max_size() as u32;

    let out_private_size = match tpm2b_private_marshalled_max_size(limits) {
        Ok(out_private_size) => out_private_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(out_private_size).ok_or(())?;

    let out_public_size = match tpm2b_public_marshalled_max_size(limits) {
        Ok(out_public_size) => out_public_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(out_public_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 87, table 36, TPM2_Duplicate_COMMAND_HANDLES structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2DuplicateCommandHandles {
    pub object_handle: TpmiDhObject,
    pub new_parent_handle: TpmiDhObjectWCV,
}

impl Tpm2DuplicateCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_duplicate_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.object_handle.marshal(buf)?;

        let buf = self.new_parent_handle.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_object_handle) = match TpmiDhObject::unmarshal(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_new_parent_handle) = match TpmiDhObjectWCV::unmarshal(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{object_handle: unmarshalled_object_handle, new_parent_handle: unmarshalled_new_parent_handle}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_duplicate_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiDhObject::marshalled_size();
    size += TpmiDhObjectWCV::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 87, table 36, TPM2_Duplicate_COMMAND_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2DuplicateCommandParams<'a> {
    pub encryption_key_in: Tpm2bData<'a>,
    pub symmetric_alg: TpmtSymDefObjectWCV,
}

impl<'a> Tpm2DuplicateCommandParams<'a> {
    pub const fn marshalled_max_size() -> u16 {
        tpm2_duplicate_command_params_marshalled_max_size()
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let encryption_key_in_size = match self.encryption_key_in.marshalled_size() {
            Ok(encryption_key_in_size) => encryption_key_in_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(encryption_key_in_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let symmetric_alg_size = match self.symmetric_alg.marshalled_size() {
            Ok(symmetric_alg_size) => symmetric_alg_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(symmetric_alg_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.encryption_key_in.marshal(buf)?;

        let buf = self.symmetric_alg.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_encryption_key_in) = match Tpm2bData::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        let (buf, unmarshalled_symmetric_alg) = match TpmtSymDefObjectWCV::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{encryption_key_in: unmarshalled_encryption_key_in, symmetric_alg: unmarshalled_symmetric_alg}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2DuplicateCommandParams<'static>, TpmErr> {
        Ok(Tpm2DuplicateCommandParams {
            encryption_key_in: self.encryption_key_in.try_clone_intern()?,
            symmetric_alg: self.symmetric_alg,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2DuplicateCommandParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2DuplicateCommandParams<'static>, TpmErr> {
        let Self {
            encryption_key_in,
            symmetric_alg,
        } = self;

        let encryption_key_in = encryption_key_in.into_bufs_owner_intern()?;

        Ok(Tpm2DuplicateCommandParams {
            encryption_key_in,
            symmetric_alg,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2DuplicateCommandParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

const fn tpm2_duplicate_command_params_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += tpm2b_data_marshalled_max_size();
    size += tpmt_sym_def_object_wcv_marshalled_max_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 87, table 37, TPM2_Duplicate_RESPONSE_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2DuplicateResponseParams<'a> {
    pub encryption_key_out: Tpm2bData<'a>,
    pub duplicate: Tpm2bPrivate<'a>,
    pub out_sym_seed: Tpm2bEncryptedSecret<'a>,
}

impl<'a> Tpm2DuplicateResponseParams<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2_duplicate_response_params_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let encryption_key_out_size = match self.encryption_key_out.marshalled_size() {
            Ok(encryption_key_out_size) => encryption_key_out_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(encryption_key_out_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let duplicate_size = match self.duplicate.marshalled_size() {
            Ok(duplicate_size) => duplicate_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(duplicate_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let out_sym_seed_size = match self.out_sym_seed.marshalled_size() {
            Ok(out_sym_seed_size) => out_sym_seed_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(out_sym_seed_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.encryption_key_out.marshal(buf)?;

        let buf = self.duplicate.marshal(buf)?;

        let buf = self.out_sym_seed.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_encryption_key_out) = match Tpm2bData::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        let (buf, unmarshalled_duplicate) = match Tpm2bPrivate::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_out_sym_seed) = match Tpm2bEncryptedSecret::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{encryption_key_out: unmarshalled_encryption_key_out, duplicate: unmarshalled_duplicate, out_sym_seed: unmarshalled_out_sym_seed}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2DuplicateResponseParams<'static>, TpmErr> {
        Ok(Tpm2DuplicateResponseParams {
            encryption_key_out: self.encryption_key_out.try_clone_intern()?,
            duplicate: self.duplicate.try_clone_intern()?,
            out_sym_seed: self.out_sym_seed.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2DuplicateResponseParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2DuplicateResponseParams<'static>, TpmErr> {
        let Self {
            encryption_key_out,
            duplicate,
            out_sym_seed,
        } = self;

        let encryption_key_out = encryption_key_out.into_bufs_owner_intern()?;
        let duplicate = duplicate.into_bufs_owner_intern()?;
        let out_sym_seed = out_sym_seed.into_bufs_owner_intern()?;

        Ok(Tpm2DuplicateResponseParams {
            encryption_key_out,
            duplicate,
            out_sym_seed,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2DuplicateResponseParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpm2_duplicate_response_params_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    size += tpm2b_data_marshalled_max_size() as u32;

    let duplicate_size = match tpm2b_private_marshalled_max_size(limits) {
        Ok(duplicate_size) => duplicate_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(duplicate_size).ok_or(())?;

    let out_sym_seed_size = match tpm2b_encrypted_secret_marshalled_max_size(limits) {
        Ok(out_sym_seed_size) => out_sym_seed_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(out_sym_seed_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 89, table 38, TPM2_Rewrap_COMMAND_HANDLES structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2RewrapCommandHandles {
    pub old_parent: TpmiDhObjectWCV,
    pub new_parent: TpmiDhObjectWCV,
}

impl Tpm2RewrapCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_rewrap_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.old_parent.marshal(buf)?;

        let buf = self.new_parent.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_old_parent) = match TpmiDhObjectWCV::unmarshal(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_new_parent) = match TpmiDhObjectWCV::unmarshal(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{old_parent: unmarshalled_old_parent, new_parent: unmarshalled_new_parent}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_rewrap_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiDhObjectWCV::marshalled_size();
    size += TpmiDhObjectWCV::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 89, table 38, TPM2_Rewrap_COMMAND_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2RewrapCommandParams<'a> {
    pub in_duplicate: Tpm2bPrivate<'a>,
    pub name: Tpm2bName<'a>,
    pub in_sym_seed: Tpm2bEncryptedSecret<'a>,
}

impl<'a> Tpm2RewrapCommandParams<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2_rewrap_command_params_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let in_duplicate_size = match self.in_duplicate.marshalled_size() {
            Ok(in_duplicate_size) => in_duplicate_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(in_duplicate_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let name_size = match self.name.marshalled_size() {
            Ok(name_size) => name_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(name_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let in_sym_seed_size = match self.in_sym_seed.marshalled_size() {
            Ok(in_sym_seed_size) => in_sym_seed_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(in_sym_seed_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.in_duplicate.marshal(buf)?;

        let buf = self.name.marshal(buf)?;

        let buf = self.in_sym_seed.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_in_duplicate) = match Tpm2bPrivate::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        let (buf, unmarshalled_name) = match Tpm2bName::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_in_sym_seed) = match Tpm2bEncryptedSecret::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{in_duplicate: unmarshalled_in_duplicate, name: unmarshalled_name, in_sym_seed: unmarshalled_in_sym_seed}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2RewrapCommandParams<'static>, TpmErr> {
        Ok(Tpm2RewrapCommandParams {
            in_duplicate: self.in_duplicate.try_clone_intern()?,
            name: self.name.try_clone_intern()?,
            in_sym_seed: self.in_sym_seed.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2RewrapCommandParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2RewrapCommandParams<'static>, TpmErr> {
        let Self {
            in_duplicate,
            name,
            in_sym_seed,
        } = self;

        let in_duplicate = in_duplicate.into_bufs_owner_intern()?;
        let name = name.into_bufs_owner_intern()?;
        let in_sym_seed = in_sym_seed.into_bufs_owner_intern()?;

        Ok(Tpm2RewrapCommandParams {
            in_duplicate,
            name,
            in_sym_seed,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2RewrapCommandParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpm2_rewrap_command_params_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    size += tpm2b_name_marshalled_max_size() as u32;

    let in_duplicate_size = match tpm2b_private_marshalled_max_size(limits) {
        Ok(in_duplicate_size) => in_duplicate_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(in_duplicate_size).ok_or(())?;

    let in_sym_seed_size = match tpm2b_encrypted_secret_marshalled_max_size(limits) {
        Ok(in_sym_seed_size) => in_sym_seed_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(in_sym_seed_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 89, table 39, TPM2_Rewrap_RESPONSE_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2RewrapResponseParams<'a> {
    pub out_duplicate: Tpm2bPrivate<'a>,
    pub out_sym_seed: Tpm2bEncryptedSecret<'a>,
}

impl<'a> Tpm2RewrapResponseParams<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2_rewrap_response_params_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let out_duplicate_size = match self.out_duplicate.marshalled_size() {
            Ok(out_duplicate_size) => out_duplicate_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(out_duplicate_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let out_sym_seed_size = match self.out_sym_seed.marshalled_size() {
            Ok(out_sym_seed_size) => out_sym_seed_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(out_sym_seed_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.out_duplicate.marshal(buf)?;

        let buf = self.out_sym_seed.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_out_duplicate) = match Tpm2bPrivate::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        let (buf, unmarshalled_out_sym_seed) = match Tpm2bEncryptedSecret::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{out_duplicate: unmarshalled_out_duplicate, out_sym_seed: unmarshalled_out_sym_seed}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2RewrapResponseParams<'static>, TpmErr> {
        Ok(Tpm2RewrapResponseParams {
            out_duplicate: self.out_duplicate.try_clone_intern()?,
            out_sym_seed: self.out_sym_seed.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2RewrapResponseParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2RewrapResponseParams<'static>, TpmErr> {
        let Self {
            out_duplicate,
            out_sym_seed,
        } = self;

        let out_duplicate = out_duplicate.into_bufs_owner_intern()?;
        let out_sym_seed = out_sym_seed.into_bufs_owner_intern()?;

        Ok(Tpm2RewrapResponseParams {
            out_duplicate,
            out_sym_seed,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2RewrapResponseParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpm2_rewrap_response_params_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    let out_duplicate_size = match tpm2b_private_marshalled_max_size(limits) {
        Ok(out_duplicate_size) => out_duplicate_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(out_duplicate_size).ok_or(())?;

    let out_sym_seed_size = match tpm2b_encrypted_secret_marshalled_max_size(limits) {
        Ok(out_sym_seed_size) => out_sym_seed_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(out_sym_seed_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 92, table 40, TPM2_Import_COMMAND_HANDLES structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2ImportCommandHandles {
    pub parent_handle: TpmiDhObject,
}

impl Tpm2ImportCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_import_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.parent_handle.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_parent_handle) = match TpmiDhObject::unmarshal(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{parent_handle: unmarshalled_parent_handle}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_import_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiDhObject::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 92, table 40, TPM2_Import_COMMAND_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2ImportCommandParams<'a> {
    pub encryption_key: Tpm2bData<'a>,
    pub object_public: Tpm2bPublic<'a>,
    pub duplicate: Tpm2bPrivate<'a>,
    pub in_sym_seed: Tpm2bEncryptedSecret<'a>,
    pub symmetric_alg: TpmtSymDefObjectWCV,
}

impl<'a> Tpm2ImportCommandParams<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2_import_command_params_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let encryption_key_size = match self.encryption_key.marshalled_size() {
            Ok(encryption_key_size) => encryption_key_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(encryption_key_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let object_public_size = match self.object_public.marshalled_size() {
            Ok(object_public_size) => object_public_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(object_public_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let duplicate_size = match self.duplicate.marshalled_size() {
            Ok(duplicate_size) => duplicate_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(duplicate_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let in_sym_seed_size = match self.in_sym_seed.marshalled_size() {
            Ok(in_sym_seed_size) => in_sym_seed_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(in_sym_seed_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let symmetric_alg_size = match self.symmetric_alg.marshalled_size() {
            Ok(symmetric_alg_size) => symmetric_alg_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(symmetric_alg_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.encryption_key.marshal(buf)?;

        let buf = self.object_public.marshal(buf)?;

        let buf = self.duplicate.marshal(buf)?;

        let buf = self.in_sym_seed.marshal(buf)?;

        let buf = self.symmetric_alg.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_encryption_key) = match Tpm2bData::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        let (buf, unmarshalled_object_public) = match Tpm2bPublic::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_duplicate) = match Tpm2bPrivate::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_in_sym_seed) = match Tpm2bEncryptedSecret::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_symmetric_alg) = match TpmtSymDefObjectWCV::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{encryption_key: unmarshalled_encryption_key, object_public: unmarshalled_object_public, duplicate: unmarshalled_duplicate, in_sym_seed: unmarshalled_in_sym_seed, symmetric_alg: unmarshalled_symmetric_alg}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2ImportCommandParams<'static>, TpmErr> {
        Ok(Tpm2ImportCommandParams {
            encryption_key: self.encryption_key.try_clone_intern()?,
            object_public: self.object_public.try_clone_intern()?,
            duplicate: self.duplicate.try_clone_intern()?,
            in_sym_seed: self.in_sym_seed.try_clone_intern()?,
            symmetric_alg: self.symmetric_alg,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2ImportCommandParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2ImportCommandParams<'static>, TpmErr> {
        let Self {
            encryption_key,
            object_public,
            duplicate,
            in_sym_seed,
            symmetric_alg,
        } = self;

        let encryption_key = encryption_key.into_bufs_owner_intern()?;
        let object_public = object_public.into_bufs_owner_intern()?;
        let duplicate = duplicate.into_bufs_owner_intern()?;
        let in_sym_seed = in_sym_seed.into_bufs_owner_intern()?;

        Ok(Tpm2ImportCommandParams {
            encryption_key,
            object_public,
            duplicate,
            in_sym_seed,
            symmetric_alg,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2ImportCommandParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpm2_import_command_params_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    size += tpm2b_data_marshalled_max_size() as u32;
    size += tpmt_sym_def_object_wcv_marshalled_max_size() as u32;

    let object_public_size = match tpm2b_public_marshalled_max_size(limits) {
        Ok(object_public_size) => object_public_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(object_public_size).ok_or(())?;

    let duplicate_size = match tpm2b_private_marshalled_max_size(limits) {
        Ok(duplicate_size) => duplicate_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(duplicate_size).ok_or(())?;

    let in_sym_seed_size = match tpm2b_encrypted_secret_marshalled_max_size(limits) {
        Ok(in_sym_seed_size) => in_sym_seed_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(in_sym_seed_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 92, table 41, TPM2_Import_RESPONSE_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2ImportResponseParams<'a> {
    pub out_private: Tpm2bPrivate<'a>,
}

impl<'a> Tpm2ImportResponseParams<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2_import_response_params_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let out_private_size = match self.out_private.marshalled_size() {
            Ok(out_private_size) => out_private_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(out_private_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.out_private.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_out_private) = match Tpm2bPrivate::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        Ok((buf, Self{out_private: unmarshalled_out_private}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2ImportResponseParams<'static>, TpmErr> {
        Ok(Tpm2ImportResponseParams {
            out_private: self.out_private.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2ImportResponseParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2ImportResponseParams<'static>, TpmErr> {
        let Self {
            out_private,
        } = self;

        let out_private = out_private.into_bufs_owner_intern()?;

        Ok(Tpm2ImportResponseParams {
            out_private,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2ImportResponseParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpm2_import_response_params_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    let out_private_size = match tpm2b_private_marshalled_max_size(limits) {
        Ok(out_private_size) => out_private_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(out_private_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 97, table 44, TPM2_RSA_Encrypt_COMMAND_HANDLES structure
#[cfg(feature = "rsa")]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2RsaEncryptCommandHandles {
    pub key_handle: TpmiDhObject,
}

#[cfg(feature = "rsa")]
impl Tpm2RsaEncryptCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_rsa_encrypt_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.key_handle.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_key_handle) = match TpmiDhObject::unmarshal(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{key_handle: unmarshalled_key_handle}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

#[cfg(feature = "rsa")]
const fn tpm2_rsa_encrypt_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiDhObject::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 97, table 44, TPM2_RSA_Encrypt_COMMAND_PARAMS structure
#[cfg(feature = "rsa")]
#[derive(Debug, PartialEq)]
pub struct Tpm2RsaEncryptCommandParams<'a> {
    pub message: Tpm2bPublicKeyRsa<'a>,
    pub in_scheme: TpmtRsaDecryptWCV,
    pub label: Tpm2bData<'a>,
}

#[cfg(feature = "rsa")]
impl<'a> Tpm2RsaEncryptCommandParams<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2_rsa_encrypt_command_params_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let message_size = match self.message.marshalled_size() {
            Ok(message_size) => message_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(message_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let in_scheme_size = match self.in_scheme.marshalled_size() {
            Ok(in_scheme_size) => in_scheme_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(in_scheme_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let label_size = match self.label.marshalled_size() {
            Ok(label_size) => label_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(label_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.message.marshal(buf)?;

        let buf = self.in_scheme.marshal(buf)?;

        let buf = self.label.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_message) = match Tpm2bPublicKeyRsa::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        let (buf, unmarshalled_in_scheme) = match TpmtRsaDecryptWCV::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_label) = match Tpm2bData::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{message: unmarshalled_message, in_scheme: unmarshalled_in_scheme, label: unmarshalled_label}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2RsaEncryptCommandParams<'static>, TpmErr> {
        Ok(Tpm2RsaEncryptCommandParams {
            message: self.message.try_clone_intern()?,
            in_scheme: self.in_scheme,
            label: self.label.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2RsaEncryptCommandParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2RsaEncryptCommandParams<'static>, TpmErr> {
        let Self {
            message,
            in_scheme,
            label,
        } = self;

        let message = message.into_bufs_owner_intern()?;
        let label = label.into_bufs_owner_intern()?;

        Ok(Tpm2RsaEncryptCommandParams {
            message,
            in_scheme,
            label,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2RsaEncryptCommandParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

#[cfg(feature = "rsa")]
fn tpm2_rsa_encrypt_command_params_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    size += tpmt_rsa_decrypt_wcv_marshalled_max_size() as u32;
    size += tpm2b_data_marshalled_max_size() as u32;

    let message_size = match tpm2b_public_key_rsa_marshalled_max_size(limits) {
        Ok(message_size) => message_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(message_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 97, table 45, TPM2_RSA_Encrypt_RESPONSE_PARAMS structure
#[cfg(feature = "rsa")]
#[derive(Debug, PartialEq)]
pub struct Tpm2RsaEncryptResponseParams<'a> {
    pub out_data: Tpm2bPublicKeyRsa<'a>,
}

#[cfg(feature = "rsa")]
impl<'a> Tpm2RsaEncryptResponseParams<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2_rsa_encrypt_response_params_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let out_data_size = match self.out_data.marshalled_size() {
            Ok(out_data_size) => out_data_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(out_data_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.out_data.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_out_data) = match Tpm2bPublicKeyRsa::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        Ok((buf, Self{out_data: unmarshalled_out_data}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2RsaEncryptResponseParams<'static>, TpmErr> {
        Ok(Tpm2RsaEncryptResponseParams {
            out_data: self.out_data.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2RsaEncryptResponseParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2RsaEncryptResponseParams<'static>, TpmErr> {
        let Self {
            out_data,
        } = self;

        let out_data = out_data.into_bufs_owner_intern()?;

        Ok(Tpm2RsaEncryptResponseParams {
            out_data,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2RsaEncryptResponseParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

#[cfg(feature = "rsa")]
fn tpm2_rsa_encrypt_response_params_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    let out_data_size = match tpm2b_public_key_rsa_marshalled_max_size(limits) {
        Ok(out_data_size) => out_data_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(out_data_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 99, table 46, TPM2_RSA_Decrypt_COMMAND_HANDLES structure
#[cfg(feature = "rsa")]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2RsaDecryptCommandHandles {
    pub key_handle: TpmiDhObject,
}

#[cfg(feature = "rsa")]
impl Tpm2RsaDecryptCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_rsa_decrypt_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.key_handle.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_key_handle) = match TpmiDhObject::unmarshal(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{key_handle: unmarshalled_key_handle}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

#[cfg(feature = "rsa")]
const fn tpm2_rsa_decrypt_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiDhObject::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 99, table 46, TPM2_RSA_Decrypt_COMMAND_PARAMS structure
#[cfg(feature = "rsa")]
#[derive(Debug, PartialEq)]
pub struct Tpm2RsaDecryptCommandParams<'a> {
    pub cipher_text: Tpm2bPublicKeyRsa<'a>,
    pub in_scheme: TpmtRsaDecryptWCV,
    pub label: Tpm2bData<'a>,
}

#[cfg(feature = "rsa")]
impl<'a> Tpm2RsaDecryptCommandParams<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2_rsa_decrypt_command_params_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let cipher_text_size = match self.cipher_text.marshalled_size() {
            Ok(cipher_text_size) => cipher_text_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(cipher_text_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let in_scheme_size = match self.in_scheme.marshalled_size() {
            Ok(in_scheme_size) => in_scheme_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(in_scheme_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let label_size = match self.label.marshalled_size() {
            Ok(label_size) => label_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(label_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.cipher_text.marshal(buf)?;

        let buf = self.in_scheme.marshal(buf)?;

        let buf = self.label.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_cipher_text) = match Tpm2bPublicKeyRsa::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        let (buf, unmarshalled_in_scheme) = match TpmtRsaDecryptWCV::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_label) = match Tpm2bData::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{cipher_text: unmarshalled_cipher_text, in_scheme: unmarshalled_in_scheme, label: unmarshalled_label}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2RsaDecryptCommandParams<'static>, TpmErr> {
        Ok(Tpm2RsaDecryptCommandParams {
            cipher_text: self.cipher_text.try_clone_intern()?,
            in_scheme: self.in_scheme,
            label: self.label.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2RsaDecryptCommandParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2RsaDecryptCommandParams<'static>, TpmErr> {
        let Self {
            cipher_text,
            in_scheme,
            label,
        } = self;

        let cipher_text = cipher_text.into_bufs_owner_intern()?;
        let label = label.into_bufs_owner_intern()?;

        Ok(Tpm2RsaDecryptCommandParams {
            cipher_text,
            in_scheme,
            label,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2RsaDecryptCommandParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

#[cfg(feature = "rsa")]
fn tpm2_rsa_decrypt_command_params_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    size += tpmt_rsa_decrypt_wcv_marshalled_max_size() as u32;
    size += tpm2b_data_marshalled_max_size() as u32;

    let cipher_text_size = match tpm2b_public_key_rsa_marshalled_max_size(limits) {
        Ok(cipher_text_size) => cipher_text_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(cipher_text_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 99, table 47, TPM2_RSA_Decrypt_RESPONSE_PARAMS structure
#[cfg(feature = "rsa")]
#[derive(Debug, PartialEq)]
pub struct Tpm2RsaDecryptResponseParams<'a> {
    pub message: Tpm2bPublicKeyRsa<'a>,
}

#[cfg(feature = "rsa")]
impl<'a> Tpm2RsaDecryptResponseParams<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2_rsa_decrypt_response_params_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let message_size = match self.message.marshalled_size() {
            Ok(message_size) => message_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(message_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.message.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_message) = match Tpm2bPublicKeyRsa::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        Ok((buf, Self{message: unmarshalled_message}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2RsaDecryptResponseParams<'static>, TpmErr> {
        Ok(Tpm2RsaDecryptResponseParams {
            message: self.message.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2RsaDecryptResponseParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2RsaDecryptResponseParams<'static>, TpmErr> {
        let Self {
            message,
        } = self;

        let message = message.into_bufs_owner_intern()?;

        Ok(Tpm2RsaDecryptResponseParams {
            message,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2RsaDecryptResponseParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

#[cfg(feature = "rsa")]
fn tpm2_rsa_decrypt_response_params_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    let message_size = match tpm2b_public_key_rsa_marshalled_max_size(limits) {
        Ok(message_size) => message_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(message_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 101, table 48, TPM2_ECDH_KeyGen_COMMAND_HANDLES structure
#[cfg(feature = "ecc")]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2EcdhKeyGenCommandHandles {
    pub key_handle: TpmiDhObject,
}

#[cfg(feature = "ecc")]
impl Tpm2EcdhKeyGenCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_ecdh_keygen_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.key_handle.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_key_handle) = match TpmiDhObject::unmarshal(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{key_handle: unmarshalled_key_handle}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

#[cfg(feature = "ecc")]
const fn tpm2_ecdh_keygen_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiDhObject::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 101, table 49, TPM2_ECDH_KeyGen_RESPONSE_PARAMS structure
#[cfg(feature = "ecc")]
#[derive(Debug, PartialEq)]
pub struct Tpm2EcdhKeyGenResponseParams<'a> {
    pub z_point: Tpm2bEccPoint<'a>,
    pub pub_point: Tpm2bEccPoint<'a>,
}

#[cfg(feature = "ecc")]
impl<'a> Tpm2EcdhKeyGenResponseParams<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2_ecdh_keygen_response_params_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let z_point_size = match self.z_point.marshalled_size() {
            Ok(z_point_size) => z_point_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(z_point_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let pub_point_size = match self.pub_point.marshalled_size() {
            Ok(pub_point_size) => pub_point_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(pub_point_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.z_point.marshal(buf)?;

        let buf = self.pub_point.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_z_point) = match Tpm2bEccPoint::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        let (buf, unmarshalled_pub_point) = match Tpm2bEccPoint::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{z_point: unmarshalled_z_point, pub_point: unmarshalled_pub_point}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2EcdhKeyGenResponseParams<'static>, TpmErr> {
        Ok(Tpm2EcdhKeyGenResponseParams {
            z_point: self.z_point.try_clone_intern()?,
            pub_point: self.pub_point.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2EcdhKeyGenResponseParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2EcdhKeyGenResponseParams<'static>, TpmErr> {
        let Self {
            z_point,
            pub_point,
        } = self;

        let z_point = z_point.into_bufs_owner_intern()?;
        let pub_point = pub_point.into_bufs_owner_intern()?;

        Ok(Tpm2EcdhKeyGenResponseParams {
            z_point,
            pub_point,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2EcdhKeyGenResponseParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

#[cfg(feature = "ecc")]
fn tpm2_ecdh_keygen_response_params_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    let z_point_size = match tpm2b_ecc_point_marshalled_max_size(limits) {
        Ok(z_point_size) => z_point_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(z_point_size).ok_or(())?;

    let pub_point_size = match tpm2b_ecc_point_marshalled_max_size(limits) {
        Ok(pub_point_size) => pub_point_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(pub_point_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 103, table 50, TPM2_ECDH_ZGen_COMMAND_HANDLES structure
#[cfg(feature = "ecc")]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2EcdhZGenCommandHandles {
    pub key_handle: TpmiDhObject,
}

#[cfg(feature = "ecc")]
impl Tpm2EcdhZGenCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_ecdh_zgen_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.key_handle.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_key_handle) = match TpmiDhObject::unmarshal(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{key_handle: unmarshalled_key_handle}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

#[cfg(feature = "ecc")]
const fn tpm2_ecdh_zgen_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiDhObject::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 103, table 50, TPM2_ECDH_ZGen_COMMAND_PARAMS structure
#[cfg(feature = "ecc")]
#[derive(Debug, PartialEq)]
pub struct Tpm2EcdhZGenCommandParams<'a> {
    pub in_point: Tpm2bEccPoint<'a>,
}

#[cfg(feature = "ecc")]
impl<'a> Tpm2EcdhZGenCommandParams<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2_ecdh_zgen_command_params_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let in_point_size = match self.in_point.marshalled_size() {
            Ok(in_point_size) => in_point_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(in_point_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.in_point.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_in_point) = match Tpm2bEccPoint::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        Ok((buf, Self{in_point: unmarshalled_in_point}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2EcdhZGenCommandParams<'static>, TpmErr> {
        Ok(Tpm2EcdhZGenCommandParams {
            in_point: self.in_point.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2EcdhZGenCommandParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2EcdhZGenCommandParams<'static>, TpmErr> {
        let Self {
            in_point,
        } = self;

        let in_point = in_point.into_bufs_owner_intern()?;

        Ok(Tpm2EcdhZGenCommandParams {
            in_point,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2EcdhZGenCommandParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

#[cfg(feature = "ecc")]
fn tpm2_ecdh_zgen_command_params_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    let in_point_size = match tpm2b_ecc_point_marshalled_max_size(limits) {
        Ok(in_point_size) => in_point_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(in_point_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 103, table 51, TPM2_ECDH_ZGen_RESPONSE_PARAMS structure
#[cfg(feature = "ecc")]
#[derive(Debug, PartialEq)]
pub struct Tpm2EcdhZGenResponseParams<'a> {
    pub out_point: Tpm2bEccPoint<'a>,
}

#[cfg(feature = "ecc")]
impl<'a> Tpm2EcdhZGenResponseParams<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2_ecdh_zgen_response_params_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let out_point_size = match self.out_point.marshalled_size() {
            Ok(out_point_size) => out_point_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(out_point_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.out_point.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_out_point) = match Tpm2bEccPoint::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        Ok((buf, Self{out_point: unmarshalled_out_point}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2EcdhZGenResponseParams<'static>, TpmErr> {
        Ok(Tpm2EcdhZGenResponseParams {
            out_point: self.out_point.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2EcdhZGenResponseParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2EcdhZGenResponseParams<'static>, TpmErr> {
        let Self {
            out_point,
        } = self;

        let out_point = out_point.into_bufs_owner_intern()?;

        Ok(Tpm2EcdhZGenResponseParams {
            out_point,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2EcdhZGenResponseParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

#[cfg(feature = "ecc")]
fn tpm2_ecdh_zgen_response_params_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    let out_point_size = match tpm2b_ecc_point_marshalled_max_size(limits) {
        Ok(out_point_size) => out_point_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(out_point_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 105, table 52, TPM2_ECC_Parameters_COMMAND_PARAMS structure
#[cfg(feature = "ecc")]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2EccParametersCommandParams {
    pub curve_id: TpmiEccCurve,
}

#[cfg(feature = "ecc")]
impl Tpm2EccParametersCommandParams {
    pub const fn marshalled_size() -> u16 {
        tpm2_ecc_parameters_command_params_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.curve_id.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_curve_id) = match TpmiEccCurve::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{curve_id: unmarshalled_curve_id}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

#[cfg(feature = "ecc")]
const fn tpm2_ecc_parameters_command_params_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiEccCurve::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 105, table 53, TPM2_ECC_Parameters_RESPONSE_PARAMS structure
#[cfg(feature = "ecc")]
#[derive(Debug, PartialEq)]
pub struct Tpm2EccParametersResponseParams<'a> {
    pub parameters: TpmsAlgorithmDetailEcc<'a>,
}

#[cfg(feature = "ecc")]
impl<'a> Tpm2EccParametersResponseParams<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2_ecc_parameters_response_params_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let parameters_size = match self.parameters.marshalled_size() {
            Ok(parameters_size) => parameters_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(parameters_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.parameters.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_parameters) = match TpmsAlgorithmDetailEcc::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{parameters: unmarshalled_parameters}))
    }

    pub fn unmarshal(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2EccParametersResponseParams<'static>, TpmErr> {
        Ok(Tpm2EccParametersResponseParams {
            parameters: self.parameters.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2EccParametersResponseParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2EccParametersResponseParams<'static>, TpmErr> {
        let Self {
            parameters,
        } = self;

        let parameters = parameters.into_bufs_owner_intern()?;

        Ok(Tpm2EccParametersResponseParams {
            parameters,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2EccParametersResponseParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

#[cfg(feature = "ecc")]
fn tpm2_ecc_parameters_response_params_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    let parameters_size = match tpms_algorithm_detail_ecc_marshalled_max_size(limits) {
        Ok(parameters_size) => parameters_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(parameters_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 107, table 54, TPM2_ZGen_2Phase_COMMAND_HANDLES structure
#[cfg(feature = "ecc")]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2ZGen2PhaseCommandHandles {
    pub key_a: TpmiDhObject,
}

#[cfg(feature = "ecc")]
impl Tpm2ZGen2PhaseCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_zgen_2phase_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.key_a.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_key_a) = match TpmiDhObject::unmarshal(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{key_a: unmarshalled_key_a}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

#[cfg(feature = "ecc")]
const fn tpm2_zgen_2phase_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiDhObject::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 107, table 54, TPM2_ZGen_2Phase_COMMAND_PARAMS structure
#[cfg(feature = "ecc")]
#[derive(Debug, PartialEq)]
pub struct Tpm2ZGen2PhaseCommandParams<'a> {
    pub in_qs_b: Tpm2bEccPoint<'a>,
    pub in_qe_b: Tpm2bEccPoint<'a>,
    pub in_scheme: TpmiEccKeyExchange,
    pub counter: u16,
}

#[cfg(feature = "ecc")]
impl<'a> Tpm2ZGen2PhaseCommandParams<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2_zgen_2phase_command_params_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let in_scheme_size = match usize::try_from(TpmiEccKeyExchange::marshalled_size()) {
            Ok(in_scheme_size) => in_scheme_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(in_scheme_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let counter_size = mem::size_of::<u16>();
        size = match size.checked_add(counter_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let in_qs_b_size = match self.in_qs_b.marshalled_size() {
            Ok(in_qs_b_size) => in_qs_b_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(in_qs_b_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let in_qe_b_size = match self.in_qe_b.marshalled_size() {
            Ok(in_qe_b_size) => in_qe_b_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(in_qe_b_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.in_qs_b.marshal(buf)?;

        let buf = self.in_qe_b.marshal(buf)?;

        let buf = self.in_scheme.marshal(buf)?;

        let buf = marshal_u16(buf, self.counter)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_in_qs_b) = match Tpm2bEccPoint::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        let (buf, unmarshalled_in_qe_b) = match Tpm2bEccPoint::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_in_scheme) = match TpmiEccKeyExchange::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_counter) = match unmarshal_u16(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{in_qs_b: unmarshalled_in_qs_b, in_qe_b: unmarshalled_in_qe_b, in_scheme: unmarshalled_in_scheme, counter: unmarshalled_counter}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2ZGen2PhaseCommandParams<'static>, TpmErr> {
        Ok(Tpm2ZGen2PhaseCommandParams {
            in_qs_b: self.in_qs_b.try_clone_intern()?,
            in_qe_b: self.in_qe_b.try_clone_intern()?,
            in_scheme: self.in_scheme,
            counter: self.counter,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2ZGen2PhaseCommandParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2ZGen2PhaseCommandParams<'static>, TpmErr> {
        let Self {
            in_qs_b,
            in_qe_b,
            in_scheme,
            counter,
        } = self;

        let in_qs_b = in_qs_b.into_bufs_owner_intern()?;
        let in_qe_b = in_qe_b.into_bufs_owner_intern()?;

        Ok(Tpm2ZGen2PhaseCommandParams {
            in_qs_b,
            in_qe_b,
            in_scheme,
            counter,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2ZGen2PhaseCommandParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

#[cfg(feature = "ecc")]
fn tpm2_zgen_2phase_command_params_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    size += TpmiEccKeyExchange::marshalled_size() as u32;
    size += mem::size_of::<u16>() as u32;

    let in_qs_b_size = match tpm2b_ecc_point_marshalled_max_size(limits) {
        Ok(in_qs_b_size) => in_qs_b_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(in_qs_b_size).ok_or(())?;

    let in_qe_b_size = match tpm2b_ecc_point_marshalled_max_size(limits) {
        Ok(in_qe_b_size) => in_qe_b_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(in_qe_b_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 107, table 55, TPM2_ZGen_2Phase_RESPONSE_PARAMS structure
#[cfg(feature = "ecc")]
#[derive(Debug, PartialEq)]
pub struct Tpm2ZGen2PhaseResponseParams<'a> {
    pub out_z1: Tpm2bEccPoint<'a>,
    pub out_z2: Tpm2bEccPoint<'a>,
}

#[cfg(feature = "ecc")]
impl<'a> Tpm2ZGen2PhaseResponseParams<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2_zgen_2phase_response_params_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let out_z1_size = match self.out_z1.marshalled_size() {
            Ok(out_z1_size) => out_z1_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(out_z1_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let out_z2_size = match self.out_z2.marshalled_size() {
            Ok(out_z2_size) => out_z2_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(out_z2_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.out_z1.marshal(buf)?;

        let buf = self.out_z2.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_out_z1) = match Tpm2bEccPoint::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        let (buf, unmarshalled_out_z2) = match Tpm2bEccPoint::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{out_z1: unmarshalled_out_z1, out_z2: unmarshalled_out_z2}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2ZGen2PhaseResponseParams<'static>, TpmErr> {
        Ok(Tpm2ZGen2PhaseResponseParams {
            out_z1: self.out_z1.try_clone_intern()?,
            out_z2: self.out_z2.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2ZGen2PhaseResponseParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2ZGen2PhaseResponseParams<'static>, TpmErr> {
        let Self {
            out_z1,
            out_z2,
        } = self;

        let out_z1 = out_z1.into_bufs_owner_intern()?;
        let out_z2 = out_z2.into_bufs_owner_intern()?;

        Ok(Tpm2ZGen2PhaseResponseParams {
            out_z1,
            out_z2,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2ZGen2PhaseResponseParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

#[cfg(feature = "ecc")]
fn tpm2_zgen_2phase_response_params_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    let out_z1_size = match tpm2b_ecc_point_marshalled_max_size(limits) {
        Ok(out_z1_size) => out_z1_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(out_z1_size).ok_or(())?;

    let out_z2_size = match tpm2b_ecc_point_marshalled_max_size(limits) {
        Ok(out_z2_size) => out_z2_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(out_z2_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 109, table 56, TPM2_ECC_Encrypt_COMMAND_HANDLES structure
#[cfg(feature = "ecc")]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2EccEncryptCommandHandles {
    pub key_handle: TpmiDhObject,
}

#[cfg(feature = "ecc")]
impl Tpm2EccEncryptCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_ecc_encrypt_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.key_handle.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_key_handle) = match TpmiDhObject::unmarshal(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{key_handle: unmarshalled_key_handle}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

#[cfg(feature = "ecc")]
const fn tpm2_ecc_encrypt_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiDhObject::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 109, table 56, TPM2_ECC_Encrypt_COMMAND_PARAMS structure
#[cfg(feature = "ecc")]
#[derive(Debug, PartialEq)]
pub struct Tpm2EccEncryptCommandParams<'a> {
    pub plain_text: Tpm2bMaxBuffer<'a>,
    pub in_scheme: TpmtKdfSchemeWCV,
}

#[cfg(feature = "ecc")]
impl<'a> Tpm2EccEncryptCommandParams<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2_ecc_encrypt_command_params_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let plain_text_size = match self.plain_text.marshalled_size() {
            Ok(plain_text_size) => plain_text_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(plain_text_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let in_scheme_size = match self.in_scheme.marshalled_size() {
            Ok(in_scheme_size) => in_scheme_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(in_scheme_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.plain_text.marshal(buf)?;

        let buf = self.in_scheme.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_plain_text) = match Tpm2bMaxBuffer::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        let (buf, unmarshalled_in_scheme) = match TpmtKdfSchemeWCV::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{plain_text: unmarshalled_plain_text, in_scheme: unmarshalled_in_scheme}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2EccEncryptCommandParams<'static>, TpmErr> {
        Ok(Tpm2EccEncryptCommandParams {
            plain_text: self.plain_text.try_clone_intern()?,
            in_scheme: self.in_scheme,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2EccEncryptCommandParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2EccEncryptCommandParams<'static>, TpmErr> {
        let Self {
            plain_text,
            in_scheme,
        } = self;

        let plain_text = plain_text.into_bufs_owner_intern()?;

        Ok(Tpm2EccEncryptCommandParams {
            plain_text,
            in_scheme,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2EccEncryptCommandParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

#[cfg(feature = "ecc")]
fn tpm2_ecc_encrypt_command_params_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    size += tpmt_kdf_scheme_wcv_marshalled_max_size() as u32;

    let plain_text_size = match tpm2b_max_buffer_marshalled_max_size(limits) {
        Ok(plain_text_size) => plain_text_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(plain_text_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 109, table 57, TPM2_ECC_Encrypt_RESPONSE_PARAMS structure
#[cfg(feature = "ecc")]
#[derive(Debug, PartialEq)]
pub struct Tpm2EccEncryptResponseParams<'a> {
    pub c1: Tpm2bEccPoint<'a>,
    pub c2: Tpm2bMaxBuffer<'a>,
    pub c3: Tpm2bDigest<'a>,
}

#[cfg(feature = "ecc")]
impl<'a> Tpm2EccEncryptResponseParams<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2_ecc_encrypt_response_params_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let c1_size = match self.c1.marshalled_size() {
            Ok(c1_size) => c1_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(c1_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let c2_size = match self.c2.marshalled_size() {
            Ok(c2_size) => c2_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(c2_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let c3_size = match self.c3.marshalled_size() {
            Ok(c3_size) => c3_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(c3_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.c1.marshal(buf)?;

        let buf = self.c2.marshal(buf)?;

        let buf = self.c3.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_c1) = match Tpm2bEccPoint::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        let (buf, unmarshalled_c2) = match Tpm2bMaxBuffer::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_c3) = match Tpm2bDigest::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{c1: unmarshalled_c1, c2: unmarshalled_c2, c3: unmarshalled_c3}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2EccEncryptResponseParams<'static>, TpmErr> {
        Ok(Tpm2EccEncryptResponseParams {
            c1: self.c1.try_clone_intern()?,
            c2: self.c2.try_clone_intern()?,
            c3: self.c3.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2EccEncryptResponseParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2EccEncryptResponseParams<'static>, TpmErr> {
        let Self {
            c1,
            c2,
            c3,
        } = self;

        let c1 = c1.into_bufs_owner_intern()?;
        let c2 = c2.into_bufs_owner_intern()?;
        let c3 = c3.into_bufs_owner_intern()?;

        Ok(Tpm2EccEncryptResponseParams {
            c1,
            c2,
            c3,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2EccEncryptResponseParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

#[cfg(feature = "ecc")]
fn tpm2_ecc_encrypt_response_params_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    size += tpm2b_digest_marshalled_max_size() as u32;

    let c1_size = match tpm2b_ecc_point_marshalled_max_size(limits) {
        Ok(c1_size) => c1_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(c1_size).ok_or(())?;

    let c2_size = match tpm2b_max_buffer_marshalled_max_size(limits) {
        Ok(c2_size) => c2_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(c2_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 111, table 58, TPM2_ECC_Decrypt_COMMAND_HANDLES structure
#[cfg(feature = "ecc")]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2EccDecryptCommandHandles {
    pub key_handle: TpmiDhObject,
}

#[cfg(feature = "ecc")]
impl Tpm2EccDecryptCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_ecc_decrypt_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.key_handle.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_key_handle) = match TpmiDhObject::unmarshal(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{key_handle: unmarshalled_key_handle}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

#[cfg(feature = "ecc")]
const fn tpm2_ecc_decrypt_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiDhObject::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 111, table 58, TPM2_ECC_Decrypt_COMMAND_PARAMS structure
#[cfg(feature = "ecc")]
#[derive(Debug, PartialEq)]
pub struct Tpm2EccDecryptCommandParams<'a> {
    pub c1: Tpm2bEccPoint<'a>,
    pub c2: Tpm2bMaxBuffer<'a>,
    pub c3: Tpm2bDigest<'a>,
    pub in_scheme: TpmtKdfSchemeWCV,
}

#[cfg(feature = "ecc")]
impl<'a> Tpm2EccDecryptCommandParams<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2_ecc_decrypt_command_params_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let c1_size = match self.c1.marshalled_size() {
            Ok(c1_size) => c1_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(c1_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let c2_size = match self.c2.marshalled_size() {
            Ok(c2_size) => c2_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(c2_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let c3_size = match self.c3.marshalled_size() {
            Ok(c3_size) => c3_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(c3_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let in_scheme_size = match self.in_scheme.marshalled_size() {
            Ok(in_scheme_size) => in_scheme_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(in_scheme_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.c1.marshal(buf)?;

        let buf = self.c2.marshal(buf)?;

        let buf = self.c3.marshal(buf)?;

        let buf = self.in_scheme.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_c1) = match Tpm2bEccPoint::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        let (buf, unmarshalled_c2) = match Tpm2bMaxBuffer::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_c3) = match Tpm2bDigest::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_in_scheme) = match TpmtKdfSchemeWCV::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{c1: unmarshalled_c1, c2: unmarshalled_c2, c3: unmarshalled_c3, in_scheme: unmarshalled_in_scheme}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2EccDecryptCommandParams<'static>, TpmErr> {
        Ok(Tpm2EccDecryptCommandParams {
            c1: self.c1.try_clone_intern()?,
            c2: self.c2.try_clone_intern()?,
            c3: self.c3.try_clone_intern()?,
            in_scheme: self.in_scheme,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2EccDecryptCommandParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2EccDecryptCommandParams<'static>, TpmErr> {
        let Self {
            c1,
            c2,
            c3,
            in_scheme,
        } = self;

        let c1 = c1.into_bufs_owner_intern()?;
        let c2 = c2.into_bufs_owner_intern()?;
        let c3 = c3.into_bufs_owner_intern()?;

        Ok(Tpm2EccDecryptCommandParams {
            c1,
            c2,
            c3,
            in_scheme,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2EccDecryptCommandParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

#[cfg(feature = "ecc")]
fn tpm2_ecc_decrypt_command_params_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    size += tpm2b_digest_marshalled_max_size() as u32;
    size += tpmt_kdf_scheme_wcv_marshalled_max_size() as u32;

    let c1_size = match tpm2b_ecc_point_marshalled_max_size(limits) {
        Ok(c1_size) => c1_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(c1_size).ok_or(())?;

    let c2_size = match tpm2b_max_buffer_marshalled_max_size(limits) {
        Ok(c2_size) => c2_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(c2_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 111, table 59, TPM2_ECC_Decrypt_RESPONSE_PARAMS structure
#[cfg(feature = "ecc")]
#[derive(Debug, PartialEq)]
pub struct Tpm2EccDecryptResponseParams<'a> {
    pub plain_text: Tpm2bMaxBuffer<'a>,
}

#[cfg(feature = "ecc")]
impl<'a> Tpm2EccDecryptResponseParams<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2_ecc_decrypt_response_params_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let plain_text_size = match self.plain_text.marshalled_size() {
            Ok(plain_text_size) => plain_text_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(plain_text_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.plain_text.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_plain_text) = match Tpm2bMaxBuffer::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        Ok((buf, Self{plain_text: unmarshalled_plain_text}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2EccDecryptResponseParams<'static>, TpmErr> {
        Ok(Tpm2EccDecryptResponseParams {
            plain_text: self.plain_text.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2EccDecryptResponseParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2EccDecryptResponseParams<'static>, TpmErr> {
        let Self {
            plain_text,
        } = self;

        let plain_text = plain_text.into_bufs_owner_intern()?;

        Ok(Tpm2EccDecryptResponseParams {
            plain_text,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2EccDecryptResponseParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

#[cfg(feature = "ecc")]
fn tpm2_ecc_decrypt_response_params_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    let plain_text_size = match tpm2b_max_buffer_marshalled_max_size(limits) {
        Ok(plain_text_size) => plain_text_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(plain_text_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 115, table 61, TPM2_EncryptDecrypt_COMMAND_HANDLES structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2EncryptDecryptCommandHandles {
    pub key_handle: TpmiDhObject,
}

impl Tpm2EncryptDecryptCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_encryptdecrypt_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.key_handle.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_key_handle) = match TpmiDhObject::unmarshal(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{key_handle: unmarshalled_key_handle}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_encryptdecrypt_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiDhObject::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 115, table 61, TPM2_EncryptDecrypt_COMMAND_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2EncryptDecryptCommandParams<'a> {
    pub decrypt: TpmiYesNo,
    pub mode: TpmiAlgCipherModeWCV,
    pub iv_in: Tpm2bIv<'a>,
    pub in_data: Tpm2bMaxBuffer<'a>,
}

impl<'a> Tpm2EncryptDecryptCommandParams<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2_encryptdecrypt_command_params_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let decrypt_size = match usize::try_from(TpmiYesNo::marshalled_size()) {
            Ok(decrypt_size) => decrypt_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(decrypt_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let mode_size = match usize::try_from(TpmiAlgCipherModeWCV::marshalled_size()) {
            Ok(mode_size) => mode_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(mode_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let iv_in_size = match self.iv_in.marshalled_size() {
            Ok(iv_in_size) => iv_in_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(iv_in_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let in_data_size = match self.in_data.marshalled_size() {
            Ok(in_data_size) => in_data_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(in_data_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.decrypt.marshal(buf)?;

        let buf = self.mode.marshal(buf)?;

        let buf = self.iv_in.marshal(buf)?;

        let buf = self.in_data.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_decrypt) = match TpmiYesNo::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_mode) = match TpmiAlgCipherModeWCV::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_iv_in) = match Tpm2bIv::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_in_data) = match Tpm2bMaxBuffer::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{decrypt: unmarshalled_decrypt, mode: unmarshalled_mode, iv_in: unmarshalled_iv_in, in_data: unmarshalled_in_data}))
    }

    pub fn unmarshal(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2EncryptDecryptCommandParams<'static>, TpmErr> {
        Ok(Tpm2EncryptDecryptCommandParams {
            decrypt: self.decrypt,
            mode: self.mode,
            iv_in: self.iv_in.try_clone_intern()?,
            in_data: self.in_data.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2EncryptDecryptCommandParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2EncryptDecryptCommandParams<'static>, TpmErr> {
        let Self {
            decrypt,
            mode,
            iv_in,
            in_data,
        } = self;

        let iv_in = iv_in.into_bufs_owner_intern()?;
        let in_data = in_data.into_bufs_owner_intern()?;

        Ok(Tpm2EncryptDecryptCommandParams {
            decrypt,
            mode,
            iv_in,
            in_data,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2EncryptDecryptCommandParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpm2_encryptdecrypt_command_params_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    size += TpmiYesNo::marshalled_size() as u32;
    size += TpmiAlgCipherModeWCV::marshalled_size() as u32;

    let iv_in_size = match tpm2b_iv_marshalled_max_size(limits) {
        Ok(iv_in_size) => iv_in_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(iv_in_size).ok_or(())?;

    let in_data_size = match tpm2b_max_buffer_marshalled_max_size(limits) {
        Ok(in_data_size) => in_data_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(in_data_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 115, table 62, TPM2_EncryptDecrypt_RESPONSE_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2EncryptDecryptResponseParams<'a> {
    pub out_data: Tpm2bMaxBuffer<'a>,
    pub iv_out: Tpm2bIv<'a>,
}

impl<'a> Tpm2EncryptDecryptResponseParams<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2_encryptdecrypt_response_params_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let out_data_size = match self.out_data.marshalled_size() {
            Ok(out_data_size) => out_data_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(out_data_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let iv_out_size = match self.iv_out.marshalled_size() {
            Ok(iv_out_size) => iv_out_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(iv_out_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.out_data.marshal(buf)?;

        let buf = self.iv_out.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_out_data) = match Tpm2bMaxBuffer::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        let (buf, unmarshalled_iv_out) = match Tpm2bIv::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{out_data: unmarshalled_out_data, iv_out: unmarshalled_iv_out}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2EncryptDecryptResponseParams<'static>, TpmErr> {
        Ok(Tpm2EncryptDecryptResponseParams {
            out_data: self.out_data.try_clone_intern()?,
            iv_out: self.iv_out.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2EncryptDecryptResponseParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2EncryptDecryptResponseParams<'static>, TpmErr> {
        let Self {
            out_data,
            iv_out,
        } = self;

        let out_data = out_data.into_bufs_owner_intern()?;
        let iv_out = iv_out.into_bufs_owner_intern()?;

        Ok(Tpm2EncryptDecryptResponseParams {
            out_data,
            iv_out,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2EncryptDecryptResponseParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpm2_encryptdecrypt_response_params_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    let out_data_size = match tpm2b_max_buffer_marshalled_max_size(limits) {
        Ok(out_data_size) => out_data_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(out_data_size).ok_or(())?;

    let iv_out_size = match tpm2b_iv_marshalled_max_size(limits) {
        Ok(iv_out_size) => iv_out_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(iv_out_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 117, table 63, TPM2_EncryptDecrypt2_COMMAND_HANDLES structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2EncryptDecrypt2CommandHandles {
    pub key_handle: TpmiDhObject,
}

impl Tpm2EncryptDecrypt2CommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_encryptdecrypt2_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.key_handle.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_key_handle) = match TpmiDhObject::unmarshal(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{key_handle: unmarshalled_key_handle}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_encryptdecrypt2_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiDhObject::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 117, table 63, TPM2_EncryptDecrypt2_COMMAND_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2EncryptDecrypt2CommandParams<'a> {
    pub in_data: Tpm2bMaxBuffer<'a>,
    pub decrypt: TpmiYesNo,
    pub mode: TpmiAlgCipherModeWCV,
    pub iv_in: Tpm2bIv<'a>,
}

impl<'a> Tpm2EncryptDecrypt2CommandParams<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2_encryptdecrypt2_command_params_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let decrypt_size = match usize::try_from(TpmiYesNo::marshalled_size()) {
            Ok(decrypt_size) => decrypt_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(decrypt_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let mode_size = match usize::try_from(TpmiAlgCipherModeWCV::marshalled_size()) {
            Ok(mode_size) => mode_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(mode_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let in_data_size = match self.in_data.marshalled_size() {
            Ok(in_data_size) => in_data_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(in_data_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let iv_in_size = match self.iv_in.marshalled_size() {
            Ok(iv_in_size) => iv_in_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(iv_in_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.in_data.marshal(buf)?;

        let buf = self.decrypt.marshal(buf)?;

        let buf = self.mode.marshal(buf)?;

        let buf = self.iv_in.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_in_data) = match Tpm2bMaxBuffer::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        let (buf, unmarshalled_decrypt) = match TpmiYesNo::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_mode) = match TpmiAlgCipherModeWCV::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_iv_in) = match Tpm2bIv::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{in_data: unmarshalled_in_data, decrypt: unmarshalled_decrypt, mode: unmarshalled_mode, iv_in: unmarshalled_iv_in}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2EncryptDecrypt2CommandParams<'static>, TpmErr> {
        Ok(Tpm2EncryptDecrypt2CommandParams {
            in_data: self.in_data.try_clone_intern()?,
            decrypt: self.decrypt,
            mode: self.mode,
            iv_in: self.iv_in.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2EncryptDecrypt2CommandParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2EncryptDecrypt2CommandParams<'static>, TpmErr> {
        let Self {
            in_data,
            decrypt,
            mode,
            iv_in,
        } = self;

        let in_data = in_data.into_bufs_owner_intern()?;
        let iv_in = iv_in.into_bufs_owner_intern()?;

        Ok(Tpm2EncryptDecrypt2CommandParams {
            in_data,
            decrypt,
            mode,
            iv_in,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2EncryptDecrypt2CommandParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpm2_encryptdecrypt2_command_params_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    size += TpmiYesNo::marshalled_size() as u32;
    size += TpmiAlgCipherModeWCV::marshalled_size() as u32;

    let in_data_size = match tpm2b_max_buffer_marshalled_max_size(limits) {
        Ok(in_data_size) => in_data_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(in_data_size).ok_or(())?;

    let iv_in_size = match tpm2b_iv_marshalled_max_size(limits) {
        Ok(iv_in_size) => iv_in_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(iv_in_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 117, table 64, TPM2_EncryptDecrypt2_RESPONSE_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2EncryptDecrypt2ResponseParams<'a> {
    pub out_data: Tpm2bMaxBuffer<'a>,
    pub iv_out: Tpm2bIv<'a>,
}

impl<'a> Tpm2EncryptDecrypt2ResponseParams<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2_encryptdecrypt2_response_params_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let out_data_size = match self.out_data.marshalled_size() {
            Ok(out_data_size) => out_data_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(out_data_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let iv_out_size = match self.iv_out.marshalled_size() {
            Ok(iv_out_size) => iv_out_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(iv_out_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.out_data.marshal(buf)?;

        let buf = self.iv_out.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_out_data) = match Tpm2bMaxBuffer::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        let (buf, unmarshalled_iv_out) = match Tpm2bIv::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{out_data: unmarshalled_out_data, iv_out: unmarshalled_iv_out}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2EncryptDecrypt2ResponseParams<'static>, TpmErr> {
        Ok(Tpm2EncryptDecrypt2ResponseParams {
            out_data: self.out_data.try_clone_intern()?,
            iv_out: self.iv_out.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2EncryptDecrypt2ResponseParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2EncryptDecrypt2ResponseParams<'static>, TpmErr> {
        let Self {
            out_data,
            iv_out,
        } = self;

        let out_data = out_data.into_bufs_owner_intern()?;
        let iv_out = iv_out.into_bufs_owner_intern()?;

        Ok(Tpm2EncryptDecrypt2ResponseParams {
            out_data,
            iv_out,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2EncryptDecrypt2ResponseParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpm2_encryptdecrypt2_response_params_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    let out_data_size = match tpm2b_max_buffer_marshalled_max_size(limits) {
        Ok(out_data_size) => out_data_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(out_data_size).ok_or(())?;

    let iv_out_size = match tpm2b_iv_marshalled_max_size(limits) {
        Ok(iv_out_size) => iv_out_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(iv_out_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 119, table 65, TPM2_Hash_COMMAND_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2HashCommandParams<'a> {
    pub data: Tpm2bMaxBuffer<'a>,
    pub hash_alg: TpmiAlgHash,
    pub hierarchy: TpmiRhHierarchy,
}

impl<'a> Tpm2HashCommandParams<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2_hash_command_params_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let hash_alg_size = match usize::try_from(TpmiAlgHash::marshalled_size()) {
            Ok(hash_alg_size) => hash_alg_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(hash_alg_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let hierarchy_size = match usize::try_from(TpmiRhHierarchy::marshalled_size()) {
            Ok(hierarchy_size) => hierarchy_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(hierarchy_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let data_size = match self.data.marshalled_size() {
            Ok(data_size) => data_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(data_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.data.marshal(buf)?;

        let buf = self.hash_alg.marshal(buf)?;

        let buf = self.hierarchy.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_data) = match Tpm2bMaxBuffer::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        let (buf, unmarshalled_hash_alg) = match TpmiAlgHash::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_hierarchy) = match TpmiRhHierarchy::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{data: unmarshalled_data, hash_alg: unmarshalled_hash_alg, hierarchy: unmarshalled_hierarchy}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2HashCommandParams<'static>, TpmErr> {
        Ok(Tpm2HashCommandParams {
            data: self.data.try_clone_intern()?,
            hash_alg: self.hash_alg,
            hierarchy: self.hierarchy,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2HashCommandParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2HashCommandParams<'static>, TpmErr> {
        let Self {
            data,
            hash_alg,
            hierarchy,
        } = self;

        let data = data.into_bufs_owner_intern()?;

        Ok(Tpm2HashCommandParams {
            data,
            hash_alg,
            hierarchy,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2HashCommandParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpm2_hash_command_params_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    size += TpmiAlgHash::marshalled_size() as u32;
    size += TpmiRhHierarchy::marshalled_size() as u32;

    let data_size = match tpm2b_max_buffer_marshalled_max_size(limits) {
        Ok(data_size) => data_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(data_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 119, table 66, TPM2_Hash_RESPONSE_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2HashResponseParams<'a> {
    pub out_hash: Tpm2bDigest<'a>,
    pub validation: TpmtTkHashcheck<'a>,
}

impl<'a> Tpm2HashResponseParams<'a> {
    pub const fn marshalled_max_size() -> u16 {
        tpm2_hash_response_params_marshalled_max_size()
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let out_hash_size = match self.out_hash.marshalled_size() {
            Ok(out_hash_size) => out_hash_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(out_hash_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let validation_size = match self.validation.marshalled_size() {
            Ok(validation_size) => validation_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(validation_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.out_hash.marshal(buf)?;

        let buf = self.validation.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_out_hash) = match Tpm2bDigest::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        let (buf, unmarshalled_validation) = match TpmtTkHashcheck::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{out_hash: unmarshalled_out_hash, validation: unmarshalled_validation}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2HashResponseParams<'static>, TpmErr> {
        Ok(Tpm2HashResponseParams {
            out_hash: self.out_hash.try_clone_intern()?,
            validation: self.validation.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2HashResponseParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2HashResponseParams<'static>, TpmErr> {
        let Self {
            out_hash,
            validation,
        } = self;

        let out_hash = out_hash.into_bufs_owner_intern()?;
        let validation = validation.into_bufs_owner_intern()?;

        Ok(Tpm2HashResponseParams {
            out_hash,
            validation,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2HashResponseParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

const fn tpm2_hash_response_params_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += tpm2b_digest_marshalled_max_size();
    size += tpmt_tk_hashcheck_marshalled_max_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 121, table 67, TPM2_HMAC_COMMAND_HANDLES structure
#[cfg(not(feature = "cmac"))]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2HmacCommandHandles {
    pub handle: TpmiDhObject,
}

#[cfg(not(feature = "cmac"))]
impl Tpm2HmacCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_hmac_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.handle.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_handle) = match TpmiDhObject::unmarshal(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{handle: unmarshalled_handle}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

#[cfg(not(feature = "cmac"))]
const fn tpm2_hmac_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiDhObject::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 121, table 67, TPM2_HMAC_COMMAND_PARAMS structure
#[cfg(not(feature = "cmac"))]
#[derive(Debug, PartialEq)]
pub struct Tpm2HmacCommandParams<'a> {
    pub buffer: Tpm2bMaxBuffer<'a>,
    pub hash_alg: TpmiAlgHashWCV,
}

#[cfg(not(feature = "cmac"))]
impl<'a> Tpm2HmacCommandParams<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2_hmac_command_params_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let hash_alg_size = match usize::try_from(TpmiAlgHashWCV::marshalled_size()) {
            Ok(hash_alg_size) => hash_alg_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(hash_alg_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let buffer_size = match self.buffer.marshalled_size() {
            Ok(buffer_size) => buffer_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(buffer_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.buffer.marshal(buf)?;

        let buf = self.hash_alg.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_buffer) = match Tpm2bMaxBuffer::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        let (buf, unmarshalled_hash_alg) = match TpmiAlgHashWCV::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{buffer: unmarshalled_buffer, hash_alg: unmarshalled_hash_alg}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2HmacCommandParams<'static>, TpmErr> {
        Ok(Tpm2HmacCommandParams {
            buffer: self.buffer.try_clone_intern()?,
            hash_alg: self.hash_alg,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2HmacCommandParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2HmacCommandParams<'static>, TpmErr> {
        let Self {
            buffer,
            hash_alg,
        } = self;

        let buffer = buffer.into_bufs_owner_intern()?;

        Ok(Tpm2HmacCommandParams {
            buffer,
            hash_alg,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2HmacCommandParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

#[cfg(not(feature = "cmac"))]
fn tpm2_hmac_command_params_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    size += TpmiAlgHashWCV::marshalled_size() as u32;

    let buffer_size = match tpm2b_max_buffer_marshalled_max_size(limits) {
        Ok(buffer_size) => buffer_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(buffer_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 121, table 68, TPM2_HMAC_RESPONSE_PARAMS structure
#[cfg(not(feature = "cmac"))]
#[derive(Debug, PartialEq)]
pub struct Tpm2HmacResponseParams<'a> {
    pub out_hmac: Tpm2bDigest<'a>,
}

#[cfg(not(feature = "cmac"))]
impl<'a> Tpm2HmacResponseParams<'a> {
    pub const fn marshalled_max_size() -> u16 {
        tpm2_hmac_response_params_marshalled_max_size()
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let out_hmac_size = match self.out_hmac.marshalled_size() {
            Ok(out_hmac_size) => out_hmac_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(out_hmac_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.out_hmac.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_out_hmac) = match Tpm2bDigest::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        Ok((buf, Self{out_hmac: unmarshalled_out_hmac}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2HmacResponseParams<'static>, TpmErr> {
        Ok(Tpm2HmacResponseParams {
            out_hmac: self.out_hmac.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2HmacResponseParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2HmacResponseParams<'static>, TpmErr> {
        let Self {
            out_hmac,
        } = self;

        let out_hmac = out_hmac.into_bufs_owner_intern()?;

        Ok(Tpm2HmacResponseParams {
            out_hmac,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2HmacResponseParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

#[cfg(not(feature = "cmac"))]
const fn tpm2_hmac_response_params_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += tpm2b_digest_marshalled_max_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 123, table 69, TPM2_MAC_COMMAND_HANDLES structure
#[cfg(feature = "cmac")]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2MacCommandHandles {
    pub handle: TpmiDhObject,
}

#[cfg(feature = "cmac")]
impl Tpm2MacCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_mac_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.handle.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_handle) = match TpmiDhObject::unmarshal(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{handle: unmarshalled_handle}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

#[cfg(feature = "cmac")]
const fn tpm2_mac_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiDhObject::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 123, table 69, TPM2_MAC_COMMAND_PARAMS structure
#[cfg(feature = "cmac")]
#[derive(Debug, PartialEq)]
pub struct Tpm2MacCommandParams<'a> {
    pub buffer: Tpm2bMaxBuffer<'a>,
    pub in_scheme: TpmiAlgMacSchemeWCV,
}

#[cfg(feature = "cmac")]
impl<'a> Tpm2MacCommandParams<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2_mac_command_params_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let in_scheme_size = match usize::try_from(TpmiAlgMacSchemeWCV::marshalled_size()) {
            Ok(in_scheme_size) => in_scheme_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(in_scheme_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let buffer_size = match self.buffer.marshalled_size() {
            Ok(buffer_size) => buffer_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(buffer_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.buffer.marshal(buf)?;

        let buf = self.in_scheme.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_buffer) = match Tpm2bMaxBuffer::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        let (buf, unmarshalled_in_scheme) = match TpmiAlgMacSchemeWCV::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{buffer: unmarshalled_buffer, in_scheme: unmarshalled_in_scheme}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2MacCommandParams<'static>, TpmErr> {
        Ok(Tpm2MacCommandParams {
            buffer: self.buffer.try_clone_intern()?,
            in_scheme: self.in_scheme,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2MacCommandParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2MacCommandParams<'static>, TpmErr> {
        let Self {
            buffer,
            in_scheme,
        } = self;

        let buffer = buffer.into_bufs_owner_intern()?;

        Ok(Tpm2MacCommandParams {
            buffer,
            in_scheme,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2MacCommandParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

#[cfg(feature = "cmac")]
fn tpm2_mac_command_params_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    size += TpmiAlgMacSchemeWCV::marshalled_size() as u32;

    let buffer_size = match tpm2b_max_buffer_marshalled_max_size(limits) {
        Ok(buffer_size) => buffer_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(buffer_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 123, table 70, TPM2_MAC_RESPONSE_PARAMS structure
#[cfg(feature = "cmac")]
#[derive(Debug, PartialEq)]
pub struct Tpm2MacResponseParams<'a> {
    pub out_mac: Tpm2bDigest<'a>,
}

#[cfg(feature = "cmac")]
impl<'a> Tpm2MacResponseParams<'a> {
    pub const fn marshalled_max_size() -> u16 {
        tpm2_mac_response_params_marshalled_max_size()
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let out_mac_size = match self.out_mac.marshalled_size() {
            Ok(out_mac_size) => out_mac_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(out_mac_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.out_mac.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_out_mac) = match Tpm2bDigest::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        Ok((buf, Self{out_mac: unmarshalled_out_mac}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2MacResponseParams<'static>, TpmErr> {
        Ok(Tpm2MacResponseParams {
            out_mac: self.out_mac.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2MacResponseParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2MacResponseParams<'static>, TpmErr> {
        let Self {
            out_mac,
        } = self;

        let out_mac = out_mac.into_bufs_owner_intern()?;

        Ok(Tpm2MacResponseParams {
            out_mac,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2MacResponseParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

#[cfg(feature = "cmac")]
const fn tpm2_mac_response_params_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += tpm2b_digest_marshalled_max_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 125, table 71, TPM2_GetRandom_COMMAND_PARAMS structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2GetRandomCommandParams {
    pub bytes_requested: u16,
}

impl Tpm2GetRandomCommandParams {
    pub const fn marshalled_size() -> u16 {
        tpm2_getrandom_command_params_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = marshal_u16(buf, self.bytes_requested)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_bytes_requested) = match unmarshal_u16(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{bytes_requested: unmarshalled_bytes_requested}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_getrandom_command_params_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += mem::size_of::<u16>() as u16;

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 125, table 72, TPM2_GetRandom_RESPONSE_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2GetRandomResponseParams<'a> {
    pub random_bytes: Tpm2bDigest<'a>,
}

impl<'a> Tpm2GetRandomResponseParams<'a> {
    pub const fn marshalled_max_size() -> u16 {
        tpm2_getrandom_response_params_marshalled_max_size()
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let random_bytes_size = match self.random_bytes.marshalled_size() {
            Ok(random_bytes_size) => random_bytes_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(random_bytes_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.random_bytes.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_random_bytes) = match Tpm2bDigest::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        Ok((buf, Self{random_bytes: unmarshalled_random_bytes}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2GetRandomResponseParams<'static>, TpmErr> {
        Ok(Tpm2GetRandomResponseParams {
            random_bytes: self.random_bytes.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2GetRandomResponseParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2GetRandomResponseParams<'static>, TpmErr> {
        let Self {
            random_bytes,
        } = self;

        let random_bytes = random_bytes.into_bufs_owner_intern()?;

        Ok(Tpm2GetRandomResponseParams {
            random_bytes,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2GetRandomResponseParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

const fn tpm2_getrandom_response_params_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += tpm2b_digest_marshalled_max_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 127, table 73, TPM2_StirRandom_COMMAND_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2StirRandomCommandParams<'a> {
    pub in_data: Tpm2bSensitiveData<'a>,
}

impl<'a> Tpm2StirRandomCommandParams<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2_stirrandom_command_params_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let in_data_size = match self.in_data.marshalled_size() {
            Ok(in_data_size) => in_data_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(in_data_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.in_data.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_in_data) = match Tpm2bSensitiveData::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        Ok((buf, Self{in_data: unmarshalled_in_data}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2StirRandomCommandParams<'static>, TpmErr> {
        Ok(Tpm2StirRandomCommandParams {
            in_data: self.in_data.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2StirRandomCommandParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2StirRandomCommandParams<'static>, TpmErr> {
        let Self {
            in_data,
        } = self;

        let in_data = in_data.into_bufs_owner_intern()?;

        Ok(Tpm2StirRandomCommandParams {
            in_data,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2StirRandomCommandParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpm2_stirrandom_command_params_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    let in_data_size = match tpm2b_sensitive_data_marshalled_max_size(limits) {
        Ok(in_data_size) => in_data_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(in_data_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 130, table 76, TPM2_HMAC_Start_COMMAND_HANDLES structure
#[cfg(not(feature = "cmac"))]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2HmacStartCommandHandles {
    pub handle: TpmiDhObject,
}

#[cfg(not(feature = "cmac"))]
impl Tpm2HmacStartCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_hmac_start_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.handle.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_handle) = match TpmiDhObject::unmarshal(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{handle: unmarshalled_handle}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

#[cfg(not(feature = "cmac"))]
const fn tpm2_hmac_start_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiDhObject::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 130, table 76, TPM2_HMAC_Start_COMMAND_PARAMS structure
#[cfg(not(feature = "cmac"))]
#[derive(Debug, PartialEq)]
pub struct Tpm2HmacStartCommandParams<'a> {
    pub auth: Tpm2bDigest<'a>,
    pub hash_alg: TpmiAlgHashWCV,
}

#[cfg(not(feature = "cmac"))]
impl<'a> Tpm2HmacStartCommandParams<'a> {
    pub const fn marshalled_max_size() -> u16 {
        tpm2_hmac_start_command_params_marshalled_max_size()
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let hash_alg_size = match usize::try_from(TpmiAlgHashWCV::marshalled_size()) {
            Ok(hash_alg_size) => hash_alg_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(hash_alg_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let auth_size = match self.auth.marshalled_size() {
            Ok(auth_size) => auth_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(auth_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.auth.marshal(buf)?;

        let buf = self.hash_alg.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_auth) = match Tpm2bDigest::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        let (buf, unmarshalled_hash_alg) = match TpmiAlgHashWCV::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{auth: unmarshalled_auth, hash_alg: unmarshalled_hash_alg}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2HmacStartCommandParams<'static>, TpmErr> {
        Ok(Tpm2HmacStartCommandParams {
            auth: self.auth.try_clone_intern()?,
            hash_alg: self.hash_alg,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2HmacStartCommandParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2HmacStartCommandParams<'static>, TpmErr> {
        let Self {
            auth,
            hash_alg,
        } = self;

        let auth = auth.into_bufs_owner_intern()?;

        Ok(Tpm2HmacStartCommandParams {
            auth,
            hash_alg,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2HmacStartCommandParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

#[cfg(not(feature = "cmac"))]
const fn tpm2_hmac_start_command_params_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += tpm2b_digest_marshalled_max_size();
    size += TpmiAlgHashWCV::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 130, table 77, TPM2_HMAC_Start_RESPONSE_HANDLES structure
#[cfg(not(feature = "cmac"))]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2HmacStartResponseHandles {
    pub sequence_handle: TpmiDhObject,
}

#[cfg(not(feature = "cmac"))]
impl Tpm2HmacStartResponseHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_hmac_start_response_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.sequence_handle.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_sequence_handle) = match TpmiDhObject::unmarshal(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{sequence_handle: unmarshalled_sequence_handle}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

#[cfg(not(feature = "cmac"))]
const fn tpm2_hmac_start_response_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiDhObject::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 133, table 79, TPM2_MAC_Start_COMMAND_HANDLES structure
#[cfg(feature = "cmac")]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2MacStartCommandHandles {
    pub handle: TpmiDhObject,
}

#[cfg(feature = "cmac")]
impl Tpm2MacStartCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_mac_start_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.handle.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_handle) = match TpmiDhObject::unmarshal(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{handle: unmarshalled_handle}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

#[cfg(feature = "cmac")]
const fn tpm2_mac_start_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiDhObject::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 133, table 79, TPM2_MAC_Start_COMMAND_PARAMS structure
#[cfg(feature = "cmac")]
#[derive(Debug, PartialEq)]
pub struct Tpm2MacStartCommandParams<'a> {
    pub auth: Tpm2bDigest<'a>,
    pub in_scheme: TpmiAlgMacSchemeWCV,
}

#[cfg(feature = "cmac")]
impl<'a> Tpm2MacStartCommandParams<'a> {
    pub const fn marshalled_max_size() -> u16 {
        tpm2_mac_start_command_params_marshalled_max_size()
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let in_scheme_size = match usize::try_from(TpmiAlgMacSchemeWCV::marshalled_size()) {
            Ok(in_scheme_size) => in_scheme_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(in_scheme_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let auth_size = match self.auth.marshalled_size() {
            Ok(auth_size) => auth_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(auth_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.auth.marshal(buf)?;

        let buf = self.in_scheme.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_auth) = match Tpm2bDigest::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        let (buf, unmarshalled_in_scheme) = match TpmiAlgMacSchemeWCV::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{auth: unmarshalled_auth, in_scheme: unmarshalled_in_scheme}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2MacStartCommandParams<'static>, TpmErr> {
        Ok(Tpm2MacStartCommandParams {
            auth: self.auth.try_clone_intern()?,
            in_scheme: self.in_scheme,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2MacStartCommandParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2MacStartCommandParams<'static>, TpmErr> {
        let Self {
            auth,
            in_scheme,
        } = self;

        let auth = auth.into_bufs_owner_intern()?;

        Ok(Tpm2MacStartCommandParams {
            auth,
            in_scheme,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2MacStartCommandParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

#[cfg(feature = "cmac")]
const fn tpm2_mac_start_command_params_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += tpm2b_digest_marshalled_max_size();
    size += TpmiAlgMacSchemeWCV::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 133, table 80, TPM2_MAC_Start_RESPONSE_HANDLES structure
#[cfg(feature = "cmac")]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2MacStartResponseHandles {
    pub sequence_handle: TpmiDhObject,
}

#[cfg(feature = "cmac")]
impl Tpm2MacStartResponseHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_mac_start_response_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.sequence_handle.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_sequence_handle) = match TpmiDhObject::unmarshal(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{sequence_handle: unmarshalled_sequence_handle}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

#[cfg(feature = "cmac")]
const fn tpm2_mac_start_response_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiDhObject::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 135, table 81, TPM2_HashSequenceStart_COMMAND_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2HashSequenceStartCommandParams<'a> {
    pub auth: Tpm2bDigest<'a>,
    pub hash_alg: TpmiAlgHashWCV,
}

impl<'a> Tpm2HashSequenceStartCommandParams<'a> {
    pub const fn marshalled_max_size() -> u16 {
        tpm2_hashsequencestart_command_params_marshalled_max_size()
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let hash_alg_size = match usize::try_from(TpmiAlgHashWCV::marshalled_size()) {
            Ok(hash_alg_size) => hash_alg_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(hash_alg_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let auth_size = match self.auth.marshalled_size() {
            Ok(auth_size) => auth_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(auth_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.auth.marshal(buf)?;

        let buf = self.hash_alg.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_auth) = match Tpm2bDigest::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        let (buf, unmarshalled_hash_alg) = match TpmiAlgHashWCV::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{auth: unmarshalled_auth, hash_alg: unmarshalled_hash_alg}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2HashSequenceStartCommandParams<'static>, TpmErr> {
        Ok(Tpm2HashSequenceStartCommandParams {
            auth: self.auth.try_clone_intern()?,
            hash_alg: self.hash_alg,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2HashSequenceStartCommandParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2HashSequenceStartCommandParams<'static>, TpmErr> {
        let Self {
            auth,
            hash_alg,
        } = self;

        let auth = auth.into_bufs_owner_intern()?;

        Ok(Tpm2HashSequenceStartCommandParams {
            auth,
            hash_alg,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2HashSequenceStartCommandParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

const fn tpm2_hashsequencestart_command_params_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += tpm2b_digest_marshalled_max_size();
    size += TpmiAlgHashWCV::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 135, table 82, TPM2_HashSequenceStart_RESPONSE_HANDLES structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2HashSequenceStartResponseHandles {
    pub sequence_handle: TpmiDhObject,
}

impl Tpm2HashSequenceStartResponseHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_hashsequencestart_response_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.sequence_handle.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_sequence_handle) = match TpmiDhObject::unmarshal(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{sequence_handle: unmarshalled_sequence_handle}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_hashsequencestart_response_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiDhObject::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 137, table 83, TPM2_SequenceUpdate_COMMAND_HANDLES structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2SequenceUpdateCommandHandles {
    pub sequence_handle: TpmiDhObject,
}

impl Tpm2SequenceUpdateCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_sequenceupdate_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.sequence_handle.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_sequence_handle) = match TpmiDhObject::unmarshal(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{sequence_handle: unmarshalled_sequence_handle}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_sequenceupdate_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiDhObject::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 137, table 83, TPM2_SequenceUpdate_COMMAND_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2SequenceUpdateCommandParams<'a> {
    pub buffer: Tpm2bMaxBuffer<'a>,
}

impl<'a> Tpm2SequenceUpdateCommandParams<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2_sequenceupdate_command_params_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let buffer_size = match self.buffer.marshalled_size() {
            Ok(buffer_size) => buffer_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(buffer_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.buffer.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_buffer) = match Tpm2bMaxBuffer::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        Ok((buf, Self{buffer: unmarshalled_buffer}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2SequenceUpdateCommandParams<'static>, TpmErr> {
        Ok(Tpm2SequenceUpdateCommandParams {
            buffer: self.buffer.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2SequenceUpdateCommandParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2SequenceUpdateCommandParams<'static>, TpmErr> {
        let Self {
            buffer,
        } = self;

        let buffer = buffer.into_bufs_owner_intern()?;

        Ok(Tpm2SequenceUpdateCommandParams {
            buffer,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2SequenceUpdateCommandParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpm2_sequenceupdate_command_params_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    let buffer_size = match tpm2b_max_buffer_marshalled_max_size(limits) {
        Ok(buffer_size) => buffer_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(buffer_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 139, table 85, TPM2_SequenceComplete_COMMAND_HANDLES structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2SequenceCompleteCommandHandles {
    pub sequence_handle: TpmiDhObject,
}

impl Tpm2SequenceCompleteCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_sequencecomplete_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.sequence_handle.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_sequence_handle) = match TpmiDhObject::unmarshal(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{sequence_handle: unmarshalled_sequence_handle}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_sequencecomplete_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiDhObject::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 139, table 85, TPM2_SequenceComplete_COMMAND_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2SequenceCompleteCommandParams<'a> {
    pub buffer: Tpm2bMaxBuffer<'a>,
    pub hierarchy: TpmiRhHierarchy,
}

impl<'a> Tpm2SequenceCompleteCommandParams<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2_sequencecomplete_command_params_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let hierarchy_size = match usize::try_from(TpmiRhHierarchy::marshalled_size()) {
            Ok(hierarchy_size) => hierarchy_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(hierarchy_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let buffer_size = match self.buffer.marshalled_size() {
            Ok(buffer_size) => buffer_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(buffer_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.buffer.marshal(buf)?;

        let buf = self.hierarchy.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_buffer) = match Tpm2bMaxBuffer::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        let (buf, unmarshalled_hierarchy) = match TpmiRhHierarchy::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{buffer: unmarshalled_buffer, hierarchy: unmarshalled_hierarchy}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2SequenceCompleteCommandParams<'static>, TpmErr> {
        Ok(Tpm2SequenceCompleteCommandParams {
            buffer: self.buffer.try_clone_intern()?,
            hierarchy: self.hierarchy,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2SequenceCompleteCommandParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2SequenceCompleteCommandParams<'static>, TpmErr> {
        let Self {
            buffer,
            hierarchy,
        } = self;

        let buffer = buffer.into_bufs_owner_intern()?;

        Ok(Tpm2SequenceCompleteCommandParams {
            buffer,
            hierarchy,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2SequenceCompleteCommandParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpm2_sequencecomplete_command_params_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    size += TpmiRhHierarchy::marshalled_size() as u32;

    let buffer_size = match tpm2b_max_buffer_marshalled_max_size(limits) {
        Ok(buffer_size) => buffer_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(buffer_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 139, table 86, TPM2_SequenceComplete_RESPONSE_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2SequenceCompleteResponseParams<'a> {
    pub result: Tpm2bDigest<'a>,
    pub validation: TpmtTkHashcheck<'a>,
}

impl<'a> Tpm2SequenceCompleteResponseParams<'a> {
    pub const fn marshalled_max_size() -> u16 {
        tpm2_sequencecomplete_response_params_marshalled_max_size()
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let result_size = match self.result.marshalled_size() {
            Ok(result_size) => result_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(result_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let validation_size = match self.validation.marshalled_size() {
            Ok(validation_size) => validation_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(validation_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.result.marshal(buf)?;

        let buf = self.validation.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_result) = match Tpm2bDigest::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        let (buf, unmarshalled_validation) = match TpmtTkHashcheck::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{result: unmarshalled_result, validation: unmarshalled_validation}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2SequenceCompleteResponseParams<'static>, TpmErr> {
        Ok(Tpm2SequenceCompleteResponseParams {
            result: self.result.try_clone_intern()?,
            validation: self.validation.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2SequenceCompleteResponseParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2SequenceCompleteResponseParams<'static>, TpmErr> {
        let Self {
            result,
            validation,
        } = self;

        let result = result.into_bufs_owner_intern()?;
        let validation = validation.into_bufs_owner_intern()?;

        Ok(Tpm2SequenceCompleteResponseParams {
            result,
            validation,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2SequenceCompleteResponseParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

const fn tpm2_sequencecomplete_response_params_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += tpm2b_digest_marshalled_max_size();
    size += tpmt_tk_hashcheck_marshalled_max_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 141, table 87, TPM2_EventSequenceComplete_COMMAND_HANDLES structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2EventSequenceCompleteCommandHandles {
    pub pcr_handle: TpmiDhPcrWCV,
    pub sequence_handle: TpmiDhObject,
}

impl Tpm2EventSequenceCompleteCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_eventsequencecomplete_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.pcr_handle.marshal(buf)?;

        let buf = self.sequence_handle.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_pcr_handle) = match TpmiDhPcrWCV::unmarshal(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_sequence_handle) = match TpmiDhObject::unmarshal(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{pcr_handle: unmarshalled_pcr_handle, sequence_handle: unmarshalled_sequence_handle}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_eventsequencecomplete_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiDhPcrWCV::marshalled_size();
    size += TpmiDhObject::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 141, table 87, TPM2_EventSequenceComplete_COMMAND_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2EventSequenceCompleteCommandParams<'a> {
    pub buffer: Tpm2bMaxBuffer<'a>,
}

impl<'a> Tpm2EventSequenceCompleteCommandParams<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2_eventsequencecomplete_command_params_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let buffer_size = match self.buffer.marshalled_size() {
            Ok(buffer_size) => buffer_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(buffer_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.buffer.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_buffer) = match Tpm2bMaxBuffer::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        Ok((buf, Self{buffer: unmarshalled_buffer}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2EventSequenceCompleteCommandParams<'static>, TpmErr> {
        Ok(Tpm2EventSequenceCompleteCommandParams {
            buffer: self.buffer.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2EventSequenceCompleteCommandParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2EventSequenceCompleteCommandParams<'static>, TpmErr> {
        let Self {
            buffer,
        } = self;

        let buffer = buffer.into_bufs_owner_intern()?;

        Ok(Tpm2EventSequenceCompleteCommandParams {
            buffer,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2EventSequenceCompleteCommandParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpm2_eventsequencecomplete_command_params_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    let buffer_size = match tpm2b_max_buffer_marshalled_max_size(limits) {
        Ok(buffer_size) => buffer_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(buffer_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 141, table 88, TPM2_EventSequenceComplete_RESPONSE_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2EventSequenceCompleteResponseParams<'a> {
    pub results: TpmlDigestValues<'a>,
}

impl<'a> Tpm2EventSequenceCompleteResponseParams<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2_eventsequencecomplete_response_params_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let results_size = match self.results.marshalled_size() {
            Ok(results_size) => results_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(results_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.results.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_results) = match TpmlDigestValues::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{results: unmarshalled_results}))
    }

    pub fn unmarshal(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2EventSequenceCompleteResponseParams<'static>, TpmErr> {
        Ok(Tpm2EventSequenceCompleteResponseParams {
            results: self.results.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2EventSequenceCompleteResponseParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2EventSequenceCompleteResponseParams<'static>, TpmErr> {
        let Self {
            results,
        } = self;

        let results = results.into_bufs_owner_intern()?;

        Ok(Tpm2EventSequenceCompleteResponseParams {
            results,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2EventSequenceCompleteResponseParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpm2_eventsequencecomplete_response_params_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    let results_size = match tpml_digest_values_marshalled_max_size(limits) {
        Ok(results_size) => results_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(results_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 145, table 89, TPM2_Certify_COMMAND_HANDLES structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2CertifyCommandHandles {
    pub object_handle: TpmiDhObject,
    pub sign_handle: TpmiDhObjectWCV,
}

impl Tpm2CertifyCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_certify_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.object_handle.marshal(buf)?;

        let buf = self.sign_handle.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_object_handle) = match TpmiDhObject::unmarshal(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_sign_handle) = match TpmiDhObjectWCV::unmarshal(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{object_handle: unmarshalled_object_handle, sign_handle: unmarshalled_sign_handle}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_certify_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiDhObject::marshalled_size();
    size += TpmiDhObjectWCV::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 145, table 89, TPM2_Certify_COMMAND_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2CertifyCommandParams<'a> {
    pub qualifying_data: Tpm2bData<'a>,
    pub in_scheme: TpmtSigSchemeWCV,
}

impl<'a> Tpm2CertifyCommandParams<'a> {
    pub const fn marshalled_max_size() -> u16 {
        tpm2_certify_command_params_marshalled_max_size()
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let qualifying_data_size = match self.qualifying_data.marshalled_size() {
            Ok(qualifying_data_size) => qualifying_data_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(qualifying_data_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let in_scheme_size = match self.in_scheme.marshalled_size() {
            Ok(in_scheme_size) => in_scheme_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(in_scheme_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.qualifying_data.marshal(buf)?;

        let buf = self.in_scheme.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_qualifying_data) = match Tpm2bData::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        let (buf, unmarshalled_in_scheme) = match TpmtSigSchemeWCV::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{qualifying_data: unmarshalled_qualifying_data, in_scheme: unmarshalled_in_scheme}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2CertifyCommandParams<'static>, TpmErr> {
        Ok(Tpm2CertifyCommandParams {
            qualifying_data: self.qualifying_data.try_clone_intern()?,
            in_scheme: self.in_scheme,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2CertifyCommandParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2CertifyCommandParams<'static>, TpmErr> {
        let Self {
            qualifying_data,
            in_scheme,
        } = self;

        let qualifying_data = qualifying_data.into_bufs_owner_intern()?;

        Ok(Tpm2CertifyCommandParams {
            qualifying_data,
            in_scheme,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2CertifyCommandParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

const fn tpm2_certify_command_params_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += tpm2b_data_marshalled_max_size();
    size += tpmt_sig_scheme_wcv_marshalled_max_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 145, table 90, TPM2_Certify_RESPONSE_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2CertifyResponseParams<'a> {
    pub certify_info: Tpm2bAttest<'a>,
    pub signature: TpmtSignature<'a>,
}

impl<'a> Tpm2CertifyResponseParams<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2_certify_response_params_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let certify_info_size = match self.certify_info.marshalled_size() {
            Ok(certify_info_size) => certify_info_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(certify_info_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let signature_size = match self.signature.marshalled_size() {
            Ok(signature_size) => signature_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(signature_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.certify_info.marshal(buf)?;

        let buf = self.signature.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_certify_info) = match Tpm2bAttest::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        let (buf, unmarshalled_signature) = match TpmtSignature::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{certify_info: unmarshalled_certify_info, signature: unmarshalled_signature}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2CertifyResponseParams<'static>, TpmErr> {
        Ok(Tpm2CertifyResponseParams {
            certify_info: self.certify_info.try_clone_intern()?,
            signature: self.signature.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2CertifyResponseParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2CertifyResponseParams<'static>, TpmErr> {
        let Self {
            certify_info,
            signature,
        } = self;

        let certify_info = certify_info.into_bufs_owner_intern()?;
        let signature = signature.into_bufs_owner_intern()?;

        Ok(Tpm2CertifyResponseParams {
            certify_info,
            signature,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2CertifyResponseParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpm2_certify_response_params_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    let certify_info_size = match tpm2b_attest_marshalled_max_size(limits) {
        Ok(certify_info_size) => certify_info_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(certify_info_size).ok_or(())?;

    let signature_size = match tpmt_signature_marshalled_max_size(limits) {
        Ok(signature_size) => signature_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(signature_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 147, table 91, TPM2_CertifyCreation_COMMAND_HANDLES structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2CertifyCreationCommandHandles {
    pub sign_handle: TpmiDhObjectWCV,
    pub object_handle: TpmiDhObject,
}

impl Tpm2CertifyCreationCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_certifycreation_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.sign_handle.marshal(buf)?;

        let buf = self.object_handle.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_sign_handle) = match TpmiDhObjectWCV::unmarshal(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_object_handle) = match TpmiDhObject::unmarshal(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{sign_handle: unmarshalled_sign_handle, object_handle: unmarshalled_object_handle}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_certifycreation_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiDhObjectWCV::marshalled_size();
    size += TpmiDhObject::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 147, table 91, TPM2_CertifyCreation_COMMAND_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2CertifyCreationCommandParams<'a> {
    pub qualifying_data: Tpm2bData<'a>,
    pub creation_hash: Tpm2bDigest<'a>,
    pub in_scheme: TpmtSigSchemeWCV,
    pub creation_ticket: TpmtTkCreation<'a>,
}

impl<'a> Tpm2CertifyCreationCommandParams<'a> {
    pub const fn marshalled_max_size() -> u16 {
        tpm2_certifycreation_command_params_marshalled_max_size()
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let qualifying_data_size = match self.qualifying_data.marshalled_size() {
            Ok(qualifying_data_size) => qualifying_data_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(qualifying_data_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let creation_hash_size = match self.creation_hash.marshalled_size() {
            Ok(creation_hash_size) => creation_hash_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(creation_hash_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let in_scheme_size = match self.in_scheme.marshalled_size() {
            Ok(in_scheme_size) => in_scheme_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(in_scheme_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let creation_ticket_size = match self.creation_ticket.marshalled_size() {
            Ok(creation_ticket_size) => creation_ticket_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(creation_ticket_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.qualifying_data.marshal(buf)?;

        let buf = self.creation_hash.marshal(buf)?;

        let buf = self.in_scheme.marshal(buf)?;

        let buf = self.creation_ticket.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_qualifying_data) = match Tpm2bData::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        let (buf, unmarshalled_creation_hash) = match Tpm2bDigest::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_in_scheme) = match TpmtSigSchemeWCV::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_creation_ticket) = match TpmtTkCreation::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{qualifying_data: unmarshalled_qualifying_data, creation_hash: unmarshalled_creation_hash, in_scheme: unmarshalled_in_scheme, creation_ticket: unmarshalled_creation_ticket}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2CertifyCreationCommandParams<'static>, TpmErr> {
        Ok(Tpm2CertifyCreationCommandParams {
            qualifying_data: self.qualifying_data.try_clone_intern()?,
            creation_hash: self.creation_hash.try_clone_intern()?,
            in_scheme: self.in_scheme,
            creation_ticket: self.creation_ticket.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2CertifyCreationCommandParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2CertifyCreationCommandParams<'static>, TpmErr> {
        let Self {
            qualifying_data,
            creation_hash,
            in_scheme,
            creation_ticket,
        } = self;

        let qualifying_data = qualifying_data.into_bufs_owner_intern()?;
        let creation_hash = creation_hash.into_bufs_owner_intern()?;
        let creation_ticket = creation_ticket.into_bufs_owner_intern()?;

        Ok(Tpm2CertifyCreationCommandParams {
            qualifying_data,
            creation_hash,
            in_scheme,
            creation_ticket,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2CertifyCreationCommandParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

const fn tpm2_certifycreation_command_params_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += tpm2b_data_marshalled_max_size();
    size += tpm2b_digest_marshalled_max_size();
    size += tpmt_sig_scheme_wcv_marshalled_max_size();
    size += tpmt_tk_creation_marshalled_max_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 147, table 92, TPM2_CertifyCreation_RESPONSE_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2CertifyCreationResponseParams<'a> {
    pub certify_info: Tpm2bAttest<'a>,
    pub signature: TpmtSignature<'a>,
}

impl<'a> Tpm2CertifyCreationResponseParams<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2_certifycreation_response_params_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let certify_info_size = match self.certify_info.marshalled_size() {
            Ok(certify_info_size) => certify_info_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(certify_info_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let signature_size = match self.signature.marshalled_size() {
            Ok(signature_size) => signature_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(signature_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.certify_info.marshal(buf)?;

        let buf = self.signature.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_certify_info) = match Tpm2bAttest::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        let (buf, unmarshalled_signature) = match TpmtSignature::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{certify_info: unmarshalled_certify_info, signature: unmarshalled_signature}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2CertifyCreationResponseParams<'static>, TpmErr> {
        Ok(Tpm2CertifyCreationResponseParams {
            certify_info: self.certify_info.try_clone_intern()?,
            signature: self.signature.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2CertifyCreationResponseParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2CertifyCreationResponseParams<'static>, TpmErr> {
        let Self {
            certify_info,
            signature,
        } = self;

        let certify_info = certify_info.into_bufs_owner_intern()?;
        let signature = signature.into_bufs_owner_intern()?;

        Ok(Tpm2CertifyCreationResponseParams {
            certify_info,
            signature,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2CertifyCreationResponseParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpm2_certifycreation_response_params_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    let certify_info_size = match tpm2b_attest_marshalled_max_size(limits) {
        Ok(certify_info_size) => certify_info_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(certify_info_size).ok_or(())?;

    let signature_size = match tpmt_signature_marshalled_max_size(limits) {
        Ok(signature_size) => signature_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(signature_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 149, table 93, TPM2_Quote_COMMAND_HANDLES structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2QuoteCommandHandles {
    pub sign_handle: TpmiDhObjectWCV,
}

impl Tpm2QuoteCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_quote_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.sign_handle.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_sign_handle) = match TpmiDhObjectWCV::unmarshal(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{sign_handle: unmarshalled_sign_handle}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_quote_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiDhObjectWCV::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 149, table 93, TPM2_Quote_COMMAND_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2QuoteCommandParams<'a> {
    pub qualifying_data: Tpm2bData<'a>,
    pub in_scheme: TpmtSigSchemeWCV,
    pub pcr_select: TpmlPcrSelection<'a>,
}

impl<'a> Tpm2QuoteCommandParams<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2_quote_command_params_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let qualifying_data_size = match self.qualifying_data.marshalled_size() {
            Ok(qualifying_data_size) => qualifying_data_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(qualifying_data_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let in_scheme_size = match self.in_scheme.marshalled_size() {
            Ok(in_scheme_size) => in_scheme_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(in_scheme_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let pcr_select_size = match self.pcr_select.marshalled_size() {
            Ok(pcr_select_size) => pcr_select_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(pcr_select_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.qualifying_data.marshal(buf)?;

        let buf = self.in_scheme.marshal(buf)?;

        let buf = self.pcr_select.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_qualifying_data) = match Tpm2bData::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        let (buf, unmarshalled_in_scheme) = match TpmtSigSchemeWCV::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_pcr_select) = match TpmlPcrSelection::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{qualifying_data: unmarshalled_qualifying_data, in_scheme: unmarshalled_in_scheme, pcr_select: unmarshalled_pcr_select}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2QuoteCommandParams<'static>, TpmErr> {
        Ok(Tpm2QuoteCommandParams {
            qualifying_data: self.qualifying_data.try_clone_intern()?,
            in_scheme: self.in_scheme,
            pcr_select: self.pcr_select.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2QuoteCommandParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2QuoteCommandParams<'static>, TpmErr> {
        let Self {
            qualifying_data,
            in_scheme,
            pcr_select,
        } = self;

        let qualifying_data = qualifying_data.into_bufs_owner_intern()?;
        let pcr_select = pcr_select.into_bufs_owner_intern()?;

        Ok(Tpm2QuoteCommandParams {
            qualifying_data,
            in_scheme,
            pcr_select,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2QuoteCommandParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpm2_quote_command_params_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    size += tpm2b_data_marshalled_max_size() as u32;
    size += tpmt_sig_scheme_wcv_marshalled_max_size() as u32;

    let pcr_select_size = match tpml_pcr_selection_marshalled_max_size(limits) {
        Ok(pcr_select_size) => pcr_select_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(pcr_select_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 149, table 94, TPM2_Quote_RESPONSE_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2QuoteResponseParams<'a> {
    pub quoted: Tpm2bAttest<'a>,
    pub signature: TpmtSignature<'a>,
}

impl<'a> Tpm2QuoteResponseParams<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2_quote_response_params_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let quoted_size = match self.quoted.marshalled_size() {
            Ok(quoted_size) => quoted_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(quoted_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let signature_size = match self.signature.marshalled_size() {
            Ok(signature_size) => signature_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(signature_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.quoted.marshal(buf)?;

        let buf = self.signature.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_quoted) = match Tpm2bAttest::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        let (buf, unmarshalled_signature) = match TpmtSignature::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{quoted: unmarshalled_quoted, signature: unmarshalled_signature}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2QuoteResponseParams<'static>, TpmErr> {
        Ok(Tpm2QuoteResponseParams {
            quoted: self.quoted.try_clone_intern()?,
            signature: self.signature.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2QuoteResponseParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2QuoteResponseParams<'static>, TpmErr> {
        let Self {
            quoted,
            signature,
        } = self;

        let quoted = quoted.into_bufs_owner_intern()?;
        let signature = signature.into_bufs_owner_intern()?;

        Ok(Tpm2QuoteResponseParams {
            quoted,
            signature,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2QuoteResponseParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpm2_quote_response_params_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    let quoted_size = match tpm2b_attest_marshalled_max_size(limits) {
        Ok(quoted_size) => quoted_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(quoted_size).ok_or(())?;

    let signature_size = match tpmt_signature_marshalled_max_size(limits) {
        Ok(signature_size) => signature_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(signature_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 151, table 95, TPM2_GetSessionAuditDigest_COMMAND_HANDLES structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2GetSessionAuditDigestCommandHandles {
    pub privacy_admin_handle: TpmiRhEndorsement,
    pub sign_handle: TpmiDhObjectWCV,
    pub session_handle: TpmiShHmac,
}

impl Tpm2GetSessionAuditDigestCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_getsessionauditdigest_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.privacy_admin_handle.marshal(buf)?;

        let buf = self.sign_handle.marshal(buf)?;

        let buf = self.session_handle.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_privacy_admin_handle) = match TpmiRhEndorsement::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_sign_handle) = match TpmiDhObjectWCV::unmarshal(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_session_handle) = match TpmiShHmac::unmarshal(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{privacy_admin_handle: unmarshalled_privacy_admin_handle, sign_handle: unmarshalled_sign_handle, session_handle: unmarshalled_session_handle}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_getsessionauditdigest_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiRhEndorsement::marshalled_size();
    size += TpmiDhObjectWCV::marshalled_size();
    size += TpmiShHmac::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 151, table 95, TPM2_GetSessionAuditDigest_COMMAND_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2GetSessionAuditDigestCommandParams<'a> {
    pub qualifying_data: Tpm2bData<'a>,
    pub in_scheme: TpmtSigSchemeWCV,
}

impl<'a> Tpm2GetSessionAuditDigestCommandParams<'a> {
    pub const fn marshalled_max_size() -> u16 {
        tpm2_getsessionauditdigest_command_params_marshalled_max_size()
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let qualifying_data_size = match self.qualifying_data.marshalled_size() {
            Ok(qualifying_data_size) => qualifying_data_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(qualifying_data_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let in_scheme_size = match self.in_scheme.marshalled_size() {
            Ok(in_scheme_size) => in_scheme_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(in_scheme_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.qualifying_data.marshal(buf)?;

        let buf = self.in_scheme.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_qualifying_data) = match Tpm2bData::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        let (buf, unmarshalled_in_scheme) = match TpmtSigSchemeWCV::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{qualifying_data: unmarshalled_qualifying_data, in_scheme: unmarshalled_in_scheme}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2GetSessionAuditDigestCommandParams<'static>, TpmErr> {
        Ok(Tpm2GetSessionAuditDigestCommandParams {
            qualifying_data: self.qualifying_data.try_clone_intern()?,
            in_scheme: self.in_scheme,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2GetSessionAuditDigestCommandParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2GetSessionAuditDigestCommandParams<'static>, TpmErr> {
        let Self {
            qualifying_data,
            in_scheme,
        } = self;

        let qualifying_data = qualifying_data.into_bufs_owner_intern()?;

        Ok(Tpm2GetSessionAuditDigestCommandParams {
            qualifying_data,
            in_scheme,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2GetSessionAuditDigestCommandParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

const fn tpm2_getsessionauditdigest_command_params_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += tpm2b_data_marshalled_max_size();
    size += tpmt_sig_scheme_wcv_marshalled_max_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 151, table 96, TPM2_GetSessionAuditDigest_RESPONSE_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2GetSessionAuditDigestResponseParams<'a> {
    pub audit_info: Tpm2bAttest<'a>,
    pub signature: TpmtSignature<'a>,
}

impl<'a> Tpm2GetSessionAuditDigestResponseParams<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2_getsessionauditdigest_response_params_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let audit_info_size = match self.audit_info.marshalled_size() {
            Ok(audit_info_size) => audit_info_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(audit_info_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let signature_size = match self.signature.marshalled_size() {
            Ok(signature_size) => signature_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(signature_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.audit_info.marshal(buf)?;

        let buf = self.signature.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_audit_info) = match Tpm2bAttest::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        let (buf, unmarshalled_signature) = match TpmtSignature::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{audit_info: unmarshalled_audit_info, signature: unmarshalled_signature}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2GetSessionAuditDigestResponseParams<'static>, TpmErr> {
        Ok(Tpm2GetSessionAuditDigestResponseParams {
            audit_info: self.audit_info.try_clone_intern()?,
            signature: self.signature.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2GetSessionAuditDigestResponseParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2GetSessionAuditDigestResponseParams<'static>, TpmErr> {
        let Self {
            audit_info,
            signature,
        } = self;

        let audit_info = audit_info.into_bufs_owner_intern()?;
        let signature = signature.into_bufs_owner_intern()?;

        Ok(Tpm2GetSessionAuditDigestResponseParams {
            audit_info,
            signature,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2GetSessionAuditDigestResponseParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpm2_getsessionauditdigest_response_params_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    let audit_info_size = match tpm2b_attest_marshalled_max_size(limits) {
        Ok(audit_info_size) => audit_info_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(audit_info_size).ok_or(())?;

    let signature_size = match tpmt_signature_marshalled_max_size(limits) {
        Ok(signature_size) => signature_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(signature_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 153, table 97, TPM2_GetCommandAuditDigest_COMMAND_HANDLES structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2GetCommandAuditDigestCommandHandles {
    pub privacy_handle: TpmiRhEndorsement,
    pub sign_handle: TpmiDhObjectWCV,
}

impl Tpm2GetCommandAuditDigestCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_getcommandauditdigest_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.privacy_handle.marshal(buf)?;

        let buf = self.sign_handle.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_privacy_handle) = match TpmiRhEndorsement::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_sign_handle) = match TpmiDhObjectWCV::unmarshal(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{privacy_handle: unmarshalled_privacy_handle, sign_handle: unmarshalled_sign_handle}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_getcommandauditdigest_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiRhEndorsement::marshalled_size();
    size += TpmiDhObjectWCV::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 153, table 97, TPM2_GetCommandAuditDigest_COMMAND_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2GetCommandAuditDigestCommandParams<'a> {
    pub qualifying_data: Tpm2bData<'a>,
    pub in_scheme: TpmtSigSchemeWCV,
}

impl<'a> Tpm2GetCommandAuditDigestCommandParams<'a> {
    pub const fn marshalled_max_size() -> u16 {
        tpm2_getcommandauditdigest_command_params_marshalled_max_size()
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let qualifying_data_size = match self.qualifying_data.marshalled_size() {
            Ok(qualifying_data_size) => qualifying_data_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(qualifying_data_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let in_scheme_size = match self.in_scheme.marshalled_size() {
            Ok(in_scheme_size) => in_scheme_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(in_scheme_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.qualifying_data.marshal(buf)?;

        let buf = self.in_scheme.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_qualifying_data) = match Tpm2bData::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        let (buf, unmarshalled_in_scheme) = match TpmtSigSchemeWCV::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{qualifying_data: unmarshalled_qualifying_data, in_scheme: unmarshalled_in_scheme}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2GetCommandAuditDigestCommandParams<'static>, TpmErr> {
        Ok(Tpm2GetCommandAuditDigestCommandParams {
            qualifying_data: self.qualifying_data.try_clone_intern()?,
            in_scheme: self.in_scheme,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2GetCommandAuditDigestCommandParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2GetCommandAuditDigestCommandParams<'static>, TpmErr> {
        let Self {
            qualifying_data,
            in_scheme,
        } = self;

        let qualifying_data = qualifying_data.into_bufs_owner_intern()?;

        Ok(Tpm2GetCommandAuditDigestCommandParams {
            qualifying_data,
            in_scheme,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2GetCommandAuditDigestCommandParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

const fn tpm2_getcommandauditdigest_command_params_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += tpm2b_data_marshalled_max_size();
    size += tpmt_sig_scheme_wcv_marshalled_max_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 153, table 98, TPM2_GetCommandAuditDigest_RESPONSE_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2GetCommandAuditDigestResponseParams<'a> {
    pub audit_info: Tpm2bAttest<'a>,
    pub signature: TpmtSignature<'a>,
}

impl<'a> Tpm2GetCommandAuditDigestResponseParams<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2_getcommandauditdigest_response_params_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let audit_info_size = match self.audit_info.marshalled_size() {
            Ok(audit_info_size) => audit_info_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(audit_info_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let signature_size = match self.signature.marshalled_size() {
            Ok(signature_size) => signature_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(signature_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.audit_info.marshal(buf)?;

        let buf = self.signature.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_audit_info) = match Tpm2bAttest::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        let (buf, unmarshalled_signature) = match TpmtSignature::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{audit_info: unmarshalled_audit_info, signature: unmarshalled_signature}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2GetCommandAuditDigestResponseParams<'static>, TpmErr> {
        Ok(Tpm2GetCommandAuditDigestResponseParams {
            audit_info: self.audit_info.try_clone_intern()?,
            signature: self.signature.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2GetCommandAuditDigestResponseParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2GetCommandAuditDigestResponseParams<'static>, TpmErr> {
        let Self {
            audit_info,
            signature,
        } = self;

        let audit_info = audit_info.into_bufs_owner_intern()?;
        let signature = signature.into_bufs_owner_intern()?;

        Ok(Tpm2GetCommandAuditDigestResponseParams {
            audit_info,
            signature,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2GetCommandAuditDigestResponseParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpm2_getcommandauditdigest_response_params_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    let audit_info_size = match tpm2b_attest_marshalled_max_size(limits) {
        Ok(audit_info_size) => audit_info_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(audit_info_size).ok_or(())?;

    let signature_size = match tpmt_signature_marshalled_max_size(limits) {
        Ok(signature_size) => signature_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(signature_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 155, table 99, TPM2_GetTime_COMMAND_HANDLES structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2GetTimeCommandHandles {
    pub privacy_admin_handle: TpmiRhEndorsement,
    pub sign_handle: TpmiDhObjectWCV,
}

impl Tpm2GetTimeCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_gettime_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.privacy_admin_handle.marshal(buf)?;

        let buf = self.sign_handle.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_privacy_admin_handle) = match TpmiRhEndorsement::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_sign_handle) = match TpmiDhObjectWCV::unmarshal(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{privacy_admin_handle: unmarshalled_privacy_admin_handle, sign_handle: unmarshalled_sign_handle}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_gettime_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiRhEndorsement::marshalled_size();
    size += TpmiDhObjectWCV::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 155, table 99, TPM2_GetTime_COMMAND_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2GetTimeCommandParams<'a> {
    pub qualifying_data: Tpm2bData<'a>,
    pub in_scheme: TpmtSigSchemeWCV,
}

impl<'a> Tpm2GetTimeCommandParams<'a> {
    pub const fn marshalled_max_size() -> u16 {
        tpm2_gettime_command_params_marshalled_max_size()
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let qualifying_data_size = match self.qualifying_data.marshalled_size() {
            Ok(qualifying_data_size) => qualifying_data_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(qualifying_data_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let in_scheme_size = match self.in_scheme.marshalled_size() {
            Ok(in_scheme_size) => in_scheme_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(in_scheme_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.qualifying_data.marshal(buf)?;

        let buf = self.in_scheme.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_qualifying_data) = match Tpm2bData::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        let (buf, unmarshalled_in_scheme) = match TpmtSigSchemeWCV::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{qualifying_data: unmarshalled_qualifying_data, in_scheme: unmarshalled_in_scheme}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2GetTimeCommandParams<'static>, TpmErr> {
        Ok(Tpm2GetTimeCommandParams {
            qualifying_data: self.qualifying_data.try_clone_intern()?,
            in_scheme: self.in_scheme,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2GetTimeCommandParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2GetTimeCommandParams<'static>, TpmErr> {
        let Self {
            qualifying_data,
            in_scheme,
        } = self;

        let qualifying_data = qualifying_data.into_bufs_owner_intern()?;

        Ok(Tpm2GetTimeCommandParams {
            qualifying_data,
            in_scheme,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2GetTimeCommandParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

const fn tpm2_gettime_command_params_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += tpm2b_data_marshalled_max_size();
    size += tpmt_sig_scheme_wcv_marshalled_max_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 155, table 100, TPM2_GetTime_RESPONSE_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2GetTimeResponseParams<'a> {
    pub time_info: Tpm2bAttest<'a>,
    pub signature: TpmtSignature<'a>,
}

impl<'a> Tpm2GetTimeResponseParams<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2_gettime_response_params_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let time_info_size = match self.time_info.marshalled_size() {
            Ok(time_info_size) => time_info_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(time_info_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let signature_size = match self.signature.marshalled_size() {
            Ok(signature_size) => signature_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(signature_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.time_info.marshal(buf)?;

        let buf = self.signature.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_time_info) = match Tpm2bAttest::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        let (buf, unmarshalled_signature) = match TpmtSignature::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{time_info: unmarshalled_time_info, signature: unmarshalled_signature}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2GetTimeResponseParams<'static>, TpmErr> {
        Ok(Tpm2GetTimeResponseParams {
            time_info: self.time_info.try_clone_intern()?,
            signature: self.signature.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2GetTimeResponseParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2GetTimeResponseParams<'static>, TpmErr> {
        let Self {
            time_info,
            signature,
        } = self;

        let time_info = time_info.into_bufs_owner_intern()?;
        let signature = signature.into_bufs_owner_intern()?;

        Ok(Tpm2GetTimeResponseParams {
            time_info,
            signature,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2GetTimeResponseParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpm2_gettime_response_params_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    let time_info_size = match tpm2b_attest_marshalled_max_size(limits) {
        Ok(time_info_size) => time_info_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(time_info_size).ok_or(())?;

    let signature_size = match tpmt_signature_marshalled_max_size(limits) {
        Ok(signature_size) => signature_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(signature_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 159, table 101, TPM2_CertifyX509_COMMAND_HANDLES structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2CertifyX509CommandHandles {
    pub object_handle: TpmiDhObject,
    pub sign_handle: TpmiDhObject,
}

impl Tpm2CertifyX509CommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_certifyx509_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.object_handle.marshal(buf)?;

        let buf = self.sign_handle.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_object_handle) = match TpmiDhObject::unmarshal(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_sign_handle) = match TpmiDhObject::unmarshal(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{object_handle: unmarshalled_object_handle, sign_handle: unmarshalled_sign_handle}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_certifyx509_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiDhObject::marshalled_size();
    size += TpmiDhObject::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 159, table 101, TPM2_CertifyX509_COMMAND_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2CertifyX509CommandParams<'a> {
    pub reserved: Tpm2bData<'a>,
    pub in_scheme: TpmtSigSchemeWCV,
    pub partial_certificate: Tpm2bMaxBuffer<'a>,
}

impl<'a> Tpm2CertifyX509CommandParams<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2_certifyx509_command_params_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let reserved_size = match self.reserved.marshalled_size() {
            Ok(reserved_size) => reserved_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(reserved_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let in_scheme_size = match self.in_scheme.marshalled_size() {
            Ok(in_scheme_size) => in_scheme_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(in_scheme_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let partial_certificate_size = match self.partial_certificate.marshalled_size() {
            Ok(partial_certificate_size) => partial_certificate_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(partial_certificate_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.reserved.marshal(buf)?;

        let buf = self.in_scheme.marshal(buf)?;

        let buf = self.partial_certificate.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_reserved) = match Tpm2bData::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        let (buf, unmarshalled_in_scheme) = match TpmtSigSchemeWCV::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_partial_certificate) = match Tpm2bMaxBuffer::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{reserved: unmarshalled_reserved, in_scheme: unmarshalled_in_scheme, partial_certificate: unmarshalled_partial_certificate}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2CertifyX509CommandParams<'static>, TpmErr> {
        Ok(Tpm2CertifyX509CommandParams {
            reserved: self.reserved.try_clone_intern()?,
            in_scheme: self.in_scheme,
            partial_certificate: self.partial_certificate.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2CertifyX509CommandParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2CertifyX509CommandParams<'static>, TpmErr> {
        let Self {
            reserved,
            in_scheme,
            partial_certificate,
        } = self;

        let reserved = reserved.into_bufs_owner_intern()?;
        let partial_certificate = partial_certificate.into_bufs_owner_intern()?;

        Ok(Tpm2CertifyX509CommandParams {
            reserved,
            in_scheme,
            partial_certificate,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2CertifyX509CommandParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpm2_certifyx509_command_params_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    size += tpm2b_data_marshalled_max_size() as u32;
    size += tpmt_sig_scheme_wcv_marshalled_max_size() as u32;

    let partial_certificate_size = match tpm2b_max_buffer_marshalled_max_size(limits) {
        Ok(partial_certificate_size) => partial_certificate_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(partial_certificate_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 159, table 102, TPM2_CertifyX509_RESPONSE_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2CertifyX509ResponseParams<'a> {
    pub added_to_certificate: Tpm2bMaxBuffer<'a>,
    pub tbs_digest: Tpm2bDigest<'a>,
    pub signature: TpmtSignature<'a>,
}

impl<'a> Tpm2CertifyX509ResponseParams<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2_certifyx509_response_params_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let added_to_certificate_size = match self.added_to_certificate.marshalled_size() {
            Ok(added_to_certificate_size) => added_to_certificate_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(added_to_certificate_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let tbs_digest_size = match self.tbs_digest.marshalled_size() {
            Ok(tbs_digest_size) => tbs_digest_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(tbs_digest_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let signature_size = match self.signature.marshalled_size() {
            Ok(signature_size) => signature_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(signature_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.added_to_certificate.marshal(buf)?;

        let buf = self.tbs_digest.marshal(buf)?;

        let buf = self.signature.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_added_to_certificate) = match Tpm2bMaxBuffer::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        let (buf, unmarshalled_tbs_digest) = match Tpm2bDigest::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_signature) = match TpmtSignature::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{added_to_certificate: unmarshalled_added_to_certificate, tbs_digest: unmarshalled_tbs_digest, signature: unmarshalled_signature}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2CertifyX509ResponseParams<'static>, TpmErr> {
        Ok(Tpm2CertifyX509ResponseParams {
            added_to_certificate: self.added_to_certificate.try_clone_intern()?,
            tbs_digest: self.tbs_digest.try_clone_intern()?,
            signature: self.signature.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2CertifyX509ResponseParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2CertifyX509ResponseParams<'static>, TpmErr> {
        let Self {
            added_to_certificate,
            tbs_digest,
            signature,
        } = self;

        let added_to_certificate = added_to_certificate.into_bufs_owner_intern()?;
        let tbs_digest = tbs_digest.into_bufs_owner_intern()?;
        let signature = signature.into_bufs_owner_intern()?;

        Ok(Tpm2CertifyX509ResponseParams {
            added_to_certificate,
            tbs_digest,
            signature,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2CertifyX509ResponseParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpm2_certifyx509_response_params_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    size += tpm2b_digest_marshalled_max_size() as u32;

    let added_to_certificate_size = match tpm2b_max_buffer_marshalled_max_size(limits) {
        Ok(added_to_certificate_size) => added_to_certificate_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(added_to_certificate_size).ok_or(())?;

    let signature_size = match tpmt_signature_marshalled_max_size(limits) {
        Ok(signature_size) => signature_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(signature_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 162, table 103, TPM2_Commit_COMMAND_HANDLES structure
#[cfg(feature = "ecc")]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2CommitCommandHandles {
    pub sign_handle: TpmiDhObject,
}

#[cfg(feature = "ecc")]
impl Tpm2CommitCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_commit_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.sign_handle.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_sign_handle) = match TpmiDhObject::unmarshal(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{sign_handle: unmarshalled_sign_handle}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

#[cfg(feature = "ecc")]
const fn tpm2_commit_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiDhObject::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 162, table 103, TPM2_Commit_COMMAND_PARAMS structure
#[cfg(feature = "ecc")]
#[derive(Debug, PartialEq)]
pub struct Tpm2CommitCommandParams<'a> {
    pub p1: Tpm2bEccPoint<'a>,
    pub s2: Tpm2bSensitiveData<'a>,
    pub y2: Tpm2bEccParameter<'a>,
}

#[cfg(feature = "ecc")]
impl<'a> Tpm2CommitCommandParams<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2_commit_command_params_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let p1_size = match self.p1.marshalled_size() {
            Ok(p1_size) => p1_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(p1_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let s2_size = match self.s2.marshalled_size() {
            Ok(s2_size) => s2_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(s2_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let y2_size = match self.y2.marshalled_size() {
            Ok(y2_size) => y2_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(y2_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.p1.marshal(buf)?;

        let buf = self.s2.marshal(buf)?;

        let buf = self.y2.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_p1) = match Tpm2bEccPoint::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        let (buf, unmarshalled_s2) = match Tpm2bSensitiveData::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_y2) = match Tpm2bEccParameter::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{p1: unmarshalled_p1, s2: unmarshalled_s2, y2: unmarshalled_y2}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2CommitCommandParams<'static>, TpmErr> {
        Ok(Tpm2CommitCommandParams {
            p1: self.p1.try_clone_intern()?,
            s2: self.s2.try_clone_intern()?,
            y2: self.y2.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2CommitCommandParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2CommitCommandParams<'static>, TpmErr> {
        let Self {
            p1,
            s2,
            y2,
        } = self;

        let p1 = p1.into_bufs_owner_intern()?;
        let s2 = s2.into_bufs_owner_intern()?;
        let y2 = y2.into_bufs_owner_intern()?;

        Ok(Tpm2CommitCommandParams {
            p1,
            s2,
            y2,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2CommitCommandParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

#[cfg(feature = "ecc")]
fn tpm2_commit_command_params_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    let p1_size = match tpm2b_ecc_point_marshalled_max_size(limits) {
        Ok(p1_size) => p1_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(p1_size).ok_or(())?;

    let s2_size = match tpm2b_sensitive_data_marshalled_max_size(limits) {
        Ok(s2_size) => s2_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(s2_size).ok_or(())?;

    let y2_size = match tpm2b_ecc_parameter_marshalled_max_size(limits) {
        Ok(y2_size) => y2_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(y2_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 162, table 104, TPM2_Commit_RESPONSE_PARAMS structure
#[cfg(feature = "ecc")]
#[derive(Debug, PartialEq)]
pub struct Tpm2CommitResponseParams<'a> {
    pub k: Tpm2bEccPoint<'a>,
    pub l: Tpm2bEccPoint<'a>,
    pub e: Tpm2bEccPoint<'a>,
    pub counter: u16,
}

#[cfg(feature = "ecc")]
impl<'a> Tpm2CommitResponseParams<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2_commit_response_params_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let counter_size = mem::size_of::<u16>();
        size = match size.checked_add(counter_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let k_size = match self.k.marshalled_size() {
            Ok(k_size) => k_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(k_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let l_size = match self.l.marshalled_size() {
            Ok(l_size) => l_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(l_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let e_size = match self.e.marshalled_size() {
            Ok(e_size) => e_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(e_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.k.marshal(buf)?;

        let buf = self.l.marshal(buf)?;

        let buf = self.e.marshal(buf)?;

        let buf = marshal_u16(buf, self.counter)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_k) = match Tpm2bEccPoint::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        let (buf, unmarshalled_l) = match Tpm2bEccPoint::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_e) = match Tpm2bEccPoint::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_counter) = match unmarshal_u16(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{k: unmarshalled_k, l: unmarshalled_l, e: unmarshalled_e, counter: unmarshalled_counter}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2CommitResponseParams<'static>, TpmErr> {
        Ok(Tpm2CommitResponseParams {
            k: self.k.try_clone_intern()?,
            l: self.l.try_clone_intern()?,
            e: self.e.try_clone_intern()?,
            counter: self.counter,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2CommitResponseParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2CommitResponseParams<'static>, TpmErr> {
        let Self {
            k,
            l,
            e,
            counter,
        } = self;

        let k = k.into_bufs_owner_intern()?;
        let l = l.into_bufs_owner_intern()?;
        let e = e.into_bufs_owner_intern()?;

        Ok(Tpm2CommitResponseParams {
            k,
            l,
            e,
            counter,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2CommitResponseParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

#[cfg(feature = "ecc")]
fn tpm2_commit_response_params_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    size += mem::size_of::<u16>() as u32;

    let k_size = match tpm2b_ecc_point_marshalled_max_size(limits) {
        Ok(k_size) => k_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(k_size).ok_or(())?;

    let l_size = match tpm2b_ecc_point_marshalled_max_size(limits) {
        Ok(l_size) => l_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(l_size).ok_or(())?;

    let e_size = match tpm2b_ecc_point_marshalled_max_size(limits) {
        Ok(e_size) => e_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(e_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 164, table 105, TPM2_EC_Ephemeral_COMMAND_PARAMS structure
#[cfg(feature = "ecc")]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2EcEphemeralCommandParams {
    pub curve_id: TpmiEccCurve,
}

#[cfg(feature = "ecc")]
impl Tpm2EcEphemeralCommandParams {
    pub const fn marshalled_size() -> u16 {
        tpm2_ec_ephemeral_command_params_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.curve_id.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_curve_id) = match TpmiEccCurve::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{curve_id: unmarshalled_curve_id}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

#[cfg(feature = "ecc")]
const fn tpm2_ec_ephemeral_command_params_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiEccCurve::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 164, table 106, TPM2_EC_Ephemeral_RESPONSE_PARAMS structure
#[cfg(feature = "ecc")]
#[derive(Debug, PartialEq)]
pub struct Tpm2EcEphemeralResponseParams<'a> {
    pub q: Tpm2bEccPoint<'a>,
    pub counter: u16,
}

#[cfg(feature = "ecc")]
impl<'a> Tpm2EcEphemeralResponseParams<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2_ec_ephemeral_response_params_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let counter_size = mem::size_of::<u16>();
        size = match size.checked_add(counter_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let q_size = match self.q.marshalled_size() {
            Ok(q_size) => q_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(q_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.q.marshal(buf)?;

        let buf = marshal_u16(buf, self.counter)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_q) = match Tpm2bEccPoint::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        let (buf, unmarshalled_counter) = match unmarshal_u16(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{q: unmarshalled_q, counter: unmarshalled_counter}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2EcEphemeralResponseParams<'static>, TpmErr> {
        Ok(Tpm2EcEphemeralResponseParams {
            q: self.q.try_clone_intern()?,
            counter: self.counter,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2EcEphemeralResponseParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2EcEphemeralResponseParams<'static>, TpmErr> {
        let Self {
            q,
            counter,
        } = self;

        let q = q.into_bufs_owner_intern()?;

        Ok(Tpm2EcEphemeralResponseParams {
            q,
            counter,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2EcEphemeralResponseParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

#[cfg(feature = "ecc")]
fn tpm2_ec_ephemeral_response_params_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    size += mem::size_of::<u16>() as u32;

    let q_size = match tpm2b_ecc_point_marshalled_max_size(limits) {
        Ok(q_size) => q_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(q_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 166, table 107, TPM2_VerifySignature_COMMAND_HANDLES structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2VerifySignatureCommandHandles {
    pub key_handle: TpmiDhObject,
}

impl Tpm2VerifySignatureCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_verifysignature_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.key_handle.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_key_handle) = match TpmiDhObject::unmarshal(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{key_handle: unmarshalled_key_handle}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_verifysignature_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiDhObject::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 166, table 107, TPM2_VerifySignature_COMMAND_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2VerifySignatureCommandParams<'a> {
    pub digest: Tpm2bDigest<'a>,
    pub signature: TpmtSignature<'a>,
}

impl<'a> Tpm2VerifySignatureCommandParams<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2_verifysignature_command_params_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let digest_size = match self.digest.marshalled_size() {
            Ok(digest_size) => digest_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(digest_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let signature_size = match self.signature.marshalled_size() {
            Ok(signature_size) => signature_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(signature_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.digest.marshal(buf)?;

        let buf = self.signature.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_digest) = match Tpm2bDigest::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        let (buf, unmarshalled_signature) = match TpmtSignature::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{digest: unmarshalled_digest, signature: unmarshalled_signature}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2VerifySignatureCommandParams<'static>, TpmErr> {
        Ok(Tpm2VerifySignatureCommandParams {
            digest: self.digest.try_clone_intern()?,
            signature: self.signature.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2VerifySignatureCommandParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2VerifySignatureCommandParams<'static>, TpmErr> {
        let Self {
            digest,
            signature,
        } = self;

        let digest = digest.into_bufs_owner_intern()?;
        let signature = signature.into_bufs_owner_intern()?;

        Ok(Tpm2VerifySignatureCommandParams {
            digest,
            signature,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2VerifySignatureCommandParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpm2_verifysignature_command_params_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    size += tpm2b_digest_marshalled_max_size() as u32;

    let signature_size = match tpmt_signature_marshalled_max_size(limits) {
        Ok(signature_size) => signature_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(signature_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 166, table 108, TPM2_VerifySignature_RESPONSE_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2VerifySignatureResponseParams<'a> {
    pub validation: TpmtTkVerified<'a>,
}

impl<'a> Tpm2VerifySignatureResponseParams<'a> {
    pub const fn marshalled_max_size() -> u16 {
        tpm2_verifysignature_response_params_marshalled_max_size()
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let validation_size = match self.validation.marshalled_size() {
            Ok(validation_size) => validation_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(validation_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.validation.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_validation) = match TpmtTkVerified::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{validation: unmarshalled_validation}))
    }

    pub fn unmarshal(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2VerifySignatureResponseParams<'static>, TpmErr> {
        Ok(Tpm2VerifySignatureResponseParams {
            validation: self.validation.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2VerifySignatureResponseParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2VerifySignatureResponseParams<'static>, TpmErr> {
        let Self {
            validation,
        } = self;

        let validation = validation.into_bufs_owner_intern()?;

        Ok(Tpm2VerifySignatureResponseParams {
            validation,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2VerifySignatureResponseParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

const fn tpm2_verifysignature_response_params_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += tpmt_tk_verified_marshalled_max_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 168, table 109, TPM2_Sign_COMMAND_HANDLES structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2SignCommandHandles {
    pub key_handle: TpmiDhObject,
}

impl Tpm2SignCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_sign_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.key_handle.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_key_handle) = match TpmiDhObject::unmarshal(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{key_handle: unmarshalled_key_handle}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_sign_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiDhObject::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 168, table 109, TPM2_Sign_COMMAND_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2SignCommandParams<'a> {
    pub digest: Tpm2bDigest<'a>,
    pub in_scheme: TpmtSigSchemeWCV,
    pub validation: TpmtTkHashcheck<'a>,
}

impl<'a> Tpm2SignCommandParams<'a> {
    pub const fn marshalled_max_size() -> u16 {
        tpm2_sign_command_params_marshalled_max_size()
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let digest_size = match self.digest.marshalled_size() {
            Ok(digest_size) => digest_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(digest_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let in_scheme_size = match self.in_scheme.marshalled_size() {
            Ok(in_scheme_size) => in_scheme_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(in_scheme_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let validation_size = match self.validation.marshalled_size() {
            Ok(validation_size) => validation_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(validation_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.digest.marshal(buf)?;

        let buf = self.in_scheme.marshal(buf)?;

        let buf = self.validation.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_digest) = match Tpm2bDigest::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        let (buf, unmarshalled_in_scheme) = match TpmtSigSchemeWCV::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_validation) = match TpmtTkHashcheck::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{digest: unmarshalled_digest, in_scheme: unmarshalled_in_scheme, validation: unmarshalled_validation}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2SignCommandParams<'static>, TpmErr> {
        Ok(Tpm2SignCommandParams {
            digest: self.digest.try_clone_intern()?,
            in_scheme: self.in_scheme,
            validation: self.validation.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2SignCommandParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2SignCommandParams<'static>, TpmErr> {
        let Self {
            digest,
            in_scheme,
            validation,
        } = self;

        let digest = digest.into_bufs_owner_intern()?;
        let validation = validation.into_bufs_owner_intern()?;

        Ok(Tpm2SignCommandParams {
            digest,
            in_scheme,
            validation,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2SignCommandParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

const fn tpm2_sign_command_params_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += tpm2b_digest_marshalled_max_size();
    size += tpmt_sig_scheme_wcv_marshalled_max_size();
    size += tpmt_tk_hashcheck_marshalled_max_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 168, table 110, TPM2_Sign_RESPONSE_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2SignResponseParams<'a> {
    pub signature: TpmtSignature<'a>,
}

impl<'a> Tpm2SignResponseParams<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2_sign_response_params_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let signature_size = match self.signature.marshalled_size() {
            Ok(signature_size) => signature_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(signature_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.signature.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_signature) = match TpmtSignature::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{signature: unmarshalled_signature}))
    }

    pub fn unmarshal(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2SignResponseParams<'static>, TpmErr> {
        Ok(Tpm2SignResponseParams {
            signature: self.signature.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2SignResponseParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2SignResponseParams<'static>, TpmErr> {
        let Self {
            signature,
        } = self;

        let signature = signature.into_bufs_owner_intern()?;

        Ok(Tpm2SignResponseParams {
            signature,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2SignResponseParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpm2_sign_response_params_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    let signature_size = match tpmt_signature_marshalled_max_size(limits) {
        Ok(signature_size) => signature_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(signature_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 171, table 111, TPM2_SetCommandCodeAuditStatus_COMMAND_HANDLES structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2SetCommandCodeAuditStatusCommandHandles {
    pub auth: TpmiRhProvision,
}

impl Tpm2SetCommandCodeAuditStatusCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_setcommandcodeauditstatus_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.auth.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_auth) = match TpmiRhProvision::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{auth: unmarshalled_auth}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_setcommandcodeauditstatus_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiRhProvision::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 171, table 111, TPM2_SetCommandCodeAuditStatus_COMMAND_PARAMS structure
#[derive(Debug, PartialEq, Eq)]
pub struct Tpm2SetCommandCodeAuditStatusCommandParams {
    pub audit_alg: TpmiAlgHashWCV,
    pub set_list: TpmlCc,
    pub clear_list: TpmlCc,
}

impl Tpm2SetCommandCodeAuditStatusCommandParams {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2_setcommandcodeauditstatus_command_params_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let audit_alg_size = match usize::try_from(TpmiAlgHashWCV::marshalled_size()) {
            Ok(audit_alg_size) => audit_alg_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(audit_alg_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let set_list_size = match self.set_list.marshalled_size() {
            Ok(set_list_size) => set_list_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(set_list_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let clear_list_size = match self.clear_list.marshalled_size() {
            Ok(clear_list_size) => clear_list_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(clear_list_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.audit_alg.marshal(buf)?;

        let buf = self.set_list.marshal(buf)?;

        let buf = self.clear_list.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_audit_alg) = match TpmiAlgHashWCV::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_set_list) = match TpmlCc::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_clear_list) = match TpmlCc::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{audit_alg: unmarshalled_audit_alg, set_list: unmarshalled_set_list, clear_list: unmarshalled_clear_list}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2SetCommandCodeAuditStatusCommandParams, TpmErr> {
        Ok(Tpm2SetCommandCodeAuditStatusCommandParams {
            audit_alg: self.audit_alg,
            set_list: self.set_list.try_clone_intern()?,
            clear_list: self.clear_list.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2SetCommandCodeAuditStatusCommandParams>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpm2_setcommandcodeauditstatus_command_params_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    size += TpmiAlgHashWCV::marshalled_size() as u32;

    let set_list_size = match tpml_cc_marshalled_max_size(limits) {
        Ok(set_list_size) => set_list_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(set_list_size).ok_or(())?;

    let clear_list_size = match tpml_cc_marshalled_max_size(limits) {
        Ok(clear_list_size) => clear_list_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(clear_list_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 174, table 113, TPM2_PCR_Extend_COMMAND_HANDLES structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2PcrExtendCommandHandles {
    pub pcr_handle: TpmiDhPcrWCV,
}

impl Tpm2PcrExtendCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_pcr_extend_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.pcr_handle.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_pcr_handle) = match TpmiDhPcrWCV::unmarshal(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{pcr_handle: unmarshalled_pcr_handle}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_pcr_extend_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiDhPcrWCV::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 174, table 113, TPM2_PCR_Extend_COMMAND_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2PcrExtendCommandParams<'a> {
    pub digests: TpmlDigestValues<'a>,
}

impl<'a> Tpm2PcrExtendCommandParams<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2_pcr_extend_command_params_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let digests_size = match self.digests.marshalled_size() {
            Ok(digests_size) => digests_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(digests_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.digests.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_digests) = match TpmlDigestValues::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{digests: unmarshalled_digests}))
    }

    pub fn unmarshal(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2PcrExtendCommandParams<'static>, TpmErr> {
        Ok(Tpm2PcrExtendCommandParams {
            digests: self.digests.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2PcrExtendCommandParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2PcrExtendCommandParams<'static>, TpmErr> {
        let Self {
            digests,
        } = self;

        let digests = digests.into_bufs_owner_intern()?;

        Ok(Tpm2PcrExtendCommandParams {
            digests,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2PcrExtendCommandParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpm2_pcr_extend_command_params_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    let digests_size = match tpml_digest_values_marshalled_max_size(limits) {
        Ok(digests_size) => digests_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(digests_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 176, table 115, TPM2_PCR_Event_COMMAND_HANDLES structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2PcrEventCommandHandles {
    pub pcr_handle: TpmiDhPcrWCV,
}

impl Tpm2PcrEventCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_pcr_event_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.pcr_handle.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_pcr_handle) = match TpmiDhPcrWCV::unmarshal(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{pcr_handle: unmarshalled_pcr_handle}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_pcr_event_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiDhPcrWCV::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 176, table 115, TPM2_PCR_Event_COMMAND_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2PcrEventCommandParams<'a> {
    pub event_data: Tpm2bEvent<'a>,
}

impl<'a> Tpm2PcrEventCommandParams<'a> {
    pub const fn marshalled_max_size() -> u16 {
        tpm2_pcr_event_command_params_marshalled_max_size()
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let event_data_size = match self.event_data.marshalled_size() {
            Ok(event_data_size) => event_data_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(event_data_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.event_data.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_event_data) = match Tpm2bEvent::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        Ok((buf, Self{event_data: unmarshalled_event_data}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2PcrEventCommandParams<'static>, TpmErr> {
        Ok(Tpm2PcrEventCommandParams {
            event_data: self.event_data.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2PcrEventCommandParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2PcrEventCommandParams<'static>, TpmErr> {
        let Self {
            event_data,
        } = self;

        let event_data = event_data.into_bufs_owner_intern()?;

        Ok(Tpm2PcrEventCommandParams {
            event_data,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2PcrEventCommandParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

const fn tpm2_pcr_event_command_params_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += tpm2b_event_marshalled_max_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 176, table 116, TPM2_PCR_Event_RESPONSE_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2PcrEventResponseParams<'a> {
    pub digests: TpmlDigestValues<'a>,
}

impl<'a> Tpm2PcrEventResponseParams<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2_pcr_event_response_params_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let digests_size = match self.digests.marshalled_size() {
            Ok(digests_size) => digests_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(digests_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.digests.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_digests) = match TpmlDigestValues::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{digests: unmarshalled_digests}))
    }

    pub fn unmarshal(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2PcrEventResponseParams<'static>, TpmErr> {
        Ok(Tpm2PcrEventResponseParams {
            digests: self.digests.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2PcrEventResponseParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2PcrEventResponseParams<'static>, TpmErr> {
        let Self {
            digests,
        } = self;

        let digests = digests.into_bufs_owner_intern()?;

        Ok(Tpm2PcrEventResponseParams {
            digests,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2PcrEventResponseParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpm2_pcr_event_response_params_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    let digests_size = match tpml_digest_values_marshalled_max_size(limits) {
        Ok(digests_size) => digests_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(digests_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 178, table 117, TPM2_PCR_Read_COMMAND_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2PcrReadCommandParams<'a> {
    pub pcr_selection_in: TpmlPcrSelection<'a>,
}

impl<'a> Tpm2PcrReadCommandParams<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2_pcr_read_command_params_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let pcr_selection_in_size = match self.pcr_selection_in.marshalled_size() {
            Ok(pcr_selection_in_size) => pcr_selection_in_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(pcr_selection_in_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.pcr_selection_in.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_pcr_selection_in) = match TpmlPcrSelection::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{pcr_selection_in: unmarshalled_pcr_selection_in}))
    }

    pub fn unmarshal(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2PcrReadCommandParams<'static>, TpmErr> {
        Ok(Tpm2PcrReadCommandParams {
            pcr_selection_in: self.pcr_selection_in.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2PcrReadCommandParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2PcrReadCommandParams<'static>, TpmErr> {
        let Self {
            pcr_selection_in,
        } = self;

        let pcr_selection_in = pcr_selection_in.into_bufs_owner_intern()?;

        Ok(Tpm2PcrReadCommandParams {
            pcr_selection_in,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2PcrReadCommandParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpm2_pcr_read_command_params_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    let pcr_selection_in_size = match tpml_pcr_selection_marshalled_max_size(limits) {
        Ok(pcr_selection_in_size) => pcr_selection_in_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(pcr_selection_in_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 178, table 118, TPM2_PCR_Read_RESPONSE_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2PcrReadResponseParams<'a> {
    pub pcr_update_counter: u32,
    pub pcr_selection_out: TpmlPcrSelection<'a>,
    pub pcr_values: TpmlDigest<'a>,
}

impl<'a> Tpm2PcrReadResponseParams<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2_pcr_read_response_params_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let pcr_update_counter_size = mem::size_of::<u32>();
        size = match size.checked_add(pcr_update_counter_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let pcr_selection_out_size = match self.pcr_selection_out.marshalled_size() {
            Ok(pcr_selection_out_size) => pcr_selection_out_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(pcr_selection_out_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let pcr_values_size = match self.pcr_values.marshalled_size() {
            Ok(pcr_values_size) => pcr_values_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(pcr_values_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = marshal_u32(buf, self.pcr_update_counter)?;

        let buf = self.pcr_selection_out.marshal(buf)?;

        let buf = self.pcr_values.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_pcr_update_counter) = match unmarshal_u32(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_pcr_selection_out) = match TpmlPcrSelection::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_pcr_values) = match TpmlDigest::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{pcr_update_counter: unmarshalled_pcr_update_counter, pcr_selection_out: unmarshalled_pcr_selection_out, pcr_values: unmarshalled_pcr_values}))
    }

    pub fn unmarshal(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2PcrReadResponseParams<'static>, TpmErr> {
        Ok(Tpm2PcrReadResponseParams {
            pcr_update_counter: self.pcr_update_counter,
            pcr_selection_out: self.pcr_selection_out.try_clone_intern()?,
            pcr_values: self.pcr_values.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2PcrReadResponseParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2PcrReadResponseParams<'static>, TpmErr> {
        let Self {
            pcr_update_counter,
            pcr_selection_out,
            pcr_values,
        } = self;

        let pcr_selection_out = pcr_selection_out.into_bufs_owner_intern()?;
        let pcr_values = pcr_values.into_bufs_owner_intern()?;

        Ok(Tpm2PcrReadResponseParams {
            pcr_update_counter,
            pcr_selection_out,
            pcr_values,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2PcrReadResponseParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpm2_pcr_read_response_params_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    size += mem::size_of::<u32>() as u32;
    size += tpml_digest_marshalled_max_size() as u32;

    let pcr_selection_out_size = match tpml_pcr_selection_marshalled_max_size(limits) {
        Ok(pcr_selection_out_size) => pcr_selection_out_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(pcr_selection_out_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 181, table 119, TPM2_PCR_Allocate_COMMAND_HANDLES structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2PcrAllocateCommandHandles {
    pub auth_handle: TpmiRhPlatform,
}

impl Tpm2PcrAllocateCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_pcr_allocate_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.auth_handle.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_auth_handle) = match TpmiRhPlatform::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{auth_handle: unmarshalled_auth_handle}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_pcr_allocate_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiRhPlatform::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 181, table 119, TPM2_PCR_Allocate_COMMAND_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2PcrAllocateCommandParams<'a> {
    pub pcr_allocation: TpmlPcrSelection<'a>,
}

impl<'a> Tpm2PcrAllocateCommandParams<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2_pcr_allocate_command_params_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let pcr_allocation_size = match self.pcr_allocation.marshalled_size() {
            Ok(pcr_allocation_size) => pcr_allocation_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(pcr_allocation_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.pcr_allocation.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_pcr_allocation) = match TpmlPcrSelection::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{pcr_allocation: unmarshalled_pcr_allocation}))
    }

    pub fn unmarshal(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2PcrAllocateCommandParams<'static>, TpmErr> {
        Ok(Tpm2PcrAllocateCommandParams {
            pcr_allocation: self.pcr_allocation.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2PcrAllocateCommandParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2PcrAllocateCommandParams<'static>, TpmErr> {
        let Self {
            pcr_allocation,
        } = self;

        let pcr_allocation = pcr_allocation.into_bufs_owner_intern()?;

        Ok(Tpm2PcrAllocateCommandParams {
            pcr_allocation,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2PcrAllocateCommandParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpm2_pcr_allocate_command_params_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    let pcr_allocation_size = match tpml_pcr_selection_marshalled_max_size(limits) {
        Ok(pcr_allocation_size) => pcr_allocation_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(pcr_allocation_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 181, table 120, TPM2_PCR_Allocate_RESPONSE_PARAMS structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2PcrAllocateResponseParams {
    pub allocation_success: TpmiYesNo,
    pub max_pcr: u32,
    pub size_needed: u32,
    pub size_available: u32,
}

impl Tpm2PcrAllocateResponseParams {
    pub const fn marshalled_size() -> u16 {
        tpm2_pcr_allocate_response_params_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.allocation_success.marshal(buf)?;

        let buf = marshal_u32(buf, self.max_pcr)?;

        let buf = marshal_u32(buf, self.size_needed)?;

        let buf = marshal_u32(buf, self.size_available)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_allocation_success) = match TpmiYesNo::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_max_pcr) = match unmarshal_u32(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_size_needed) = match unmarshal_u32(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_size_available) = match unmarshal_u32(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{allocation_success: unmarshalled_allocation_success, max_pcr: unmarshalled_max_pcr, size_needed: unmarshalled_size_needed, size_available: unmarshalled_size_available}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_pcr_allocate_response_params_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiYesNo::marshalled_size();
    size += mem::size_of::<u32>() as u16;
    size += mem::size_of::<u32>() as u16;
    size += mem::size_of::<u32>() as u16;

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 183, table 121, TPM2_PCR_SetAuthPolicy_COMMAND_HANDLES structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2PcrSetAuthPolicyCommandHandles {
    pub auth_handle: TpmiRhPlatform,
}

impl Tpm2PcrSetAuthPolicyCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_pcr_setauthpolicy_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.auth_handle.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_auth_handle) = match TpmiRhPlatform::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{auth_handle: unmarshalled_auth_handle}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_pcr_setauthpolicy_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiRhPlatform::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 183, table 121, TPM2_PCR_SetAuthPolicy_COMMAND_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2PcrSetAuthPolicyCommandParams<'a> {
    pub auth_policy: Tpm2bDigest<'a>,
    pub hash_alg: TpmiAlgHashWCV,
    pub pcr_num: TpmiDhPcr,
}

impl<'a> Tpm2PcrSetAuthPolicyCommandParams<'a> {
    pub const fn marshalled_max_size() -> u16 {
        tpm2_pcr_setauthpolicy_command_params_marshalled_max_size()
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let hash_alg_size = match usize::try_from(TpmiAlgHashWCV::marshalled_size()) {
            Ok(hash_alg_size) => hash_alg_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(hash_alg_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let pcr_num_size = match usize::try_from(TpmiDhPcr::marshalled_size()) {
            Ok(pcr_num_size) => pcr_num_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(pcr_num_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let auth_policy_size = match self.auth_policy.marshalled_size() {
            Ok(auth_policy_size) => auth_policy_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(auth_policy_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.auth_policy.marshal(buf)?;

        let buf = self.hash_alg.marshal(buf)?;

        let buf = self.pcr_num.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_auth_policy) = match Tpm2bDigest::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        let (buf, unmarshalled_hash_alg) = match TpmiAlgHashWCV::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_pcr_num) = match TpmiDhPcr::unmarshal(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{auth_policy: unmarshalled_auth_policy, hash_alg: unmarshalled_hash_alg, pcr_num: unmarshalled_pcr_num}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2PcrSetAuthPolicyCommandParams<'static>, TpmErr> {
        Ok(Tpm2PcrSetAuthPolicyCommandParams {
            auth_policy: self.auth_policy.try_clone_intern()?,
            hash_alg: self.hash_alg,
            pcr_num: self.pcr_num,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2PcrSetAuthPolicyCommandParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2PcrSetAuthPolicyCommandParams<'static>, TpmErr> {
        let Self {
            auth_policy,
            hash_alg,
            pcr_num,
        } = self;

        let auth_policy = auth_policy.into_bufs_owner_intern()?;

        Ok(Tpm2PcrSetAuthPolicyCommandParams {
            auth_policy,
            hash_alg,
            pcr_num,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2PcrSetAuthPolicyCommandParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

const fn tpm2_pcr_setauthpolicy_command_params_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += tpm2b_digest_marshalled_max_size();
    size += TpmiAlgHashWCV::marshalled_size();
    size += TpmiDhPcr::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 185, table 123, TPM2_PCR_SetAuthValue_COMMAND_HANDLES structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2PcrSetAuthValueCommandHandles {
    pub pcr_handle: TpmiDhPcr,
}

impl Tpm2PcrSetAuthValueCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_pcr_setauthvalue_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.pcr_handle.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_pcr_handle) = match TpmiDhPcr::unmarshal(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{pcr_handle: unmarshalled_pcr_handle}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_pcr_setauthvalue_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiDhPcr::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 185, table 123, TPM2_PCR_SetAuthValue_COMMAND_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2PcrSetAuthValueCommandParams<'a> {
    pub auth: Tpm2bDigest<'a>,
}

impl<'a> Tpm2PcrSetAuthValueCommandParams<'a> {
    pub const fn marshalled_max_size() -> u16 {
        tpm2_pcr_setauthvalue_command_params_marshalled_max_size()
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let auth_size = match self.auth.marshalled_size() {
            Ok(auth_size) => auth_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(auth_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.auth.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_auth) = match Tpm2bDigest::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        Ok((buf, Self{auth: unmarshalled_auth}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2PcrSetAuthValueCommandParams<'static>, TpmErr> {
        Ok(Tpm2PcrSetAuthValueCommandParams {
            auth: self.auth.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2PcrSetAuthValueCommandParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2PcrSetAuthValueCommandParams<'static>, TpmErr> {
        let Self {
            auth,
        } = self;

        let auth = auth.into_bufs_owner_intern()?;

        Ok(Tpm2PcrSetAuthValueCommandParams {
            auth,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2PcrSetAuthValueCommandParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

const fn tpm2_pcr_setauthvalue_command_params_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += tpm2b_digest_marshalled_max_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 187, table 125, TPM2_PCR_Reset_COMMAND_HANDLES structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2PcrResetCommandHandles {
    pub pcr_handle: TpmiDhPcr,
}

impl Tpm2PcrResetCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_pcr_reset_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.pcr_handle.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_pcr_handle) = match TpmiDhPcr::unmarshal(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{pcr_handle: unmarshalled_pcr_handle}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_pcr_reset_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiDhPcr::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 196, table 127, TPM2_PolicySigned_COMMAND_HANDLES structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2PolicySignedCommandHandles {
    pub auth_object: TpmiDhObject,
    pub policy_session: TpmiShPolicy,
}

impl Tpm2PolicySignedCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_policysigned_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.auth_object.marshal(buf)?;

        let buf = self.policy_session.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_auth_object) = match TpmiDhObject::unmarshal(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_policy_session) = match TpmiShPolicy::unmarshal(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{auth_object: unmarshalled_auth_object, policy_session: unmarshalled_policy_session}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_policysigned_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiDhObject::marshalled_size();
    size += TpmiShPolicy::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 196, table 127, TPM2_PolicySigned_COMMAND_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2PolicySignedCommandParams<'a> {
    pub nonce_tpm: Tpm2bDigest<'a>,
    pub cp_hash_a: Tpm2bDigest<'a>,
    pub policy_ref: Tpm2bDigest<'a>,
    pub expiration: i32,
    pub auth: TpmtSignature<'a>,
}

impl<'a> Tpm2PolicySignedCommandParams<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2_policysigned_command_params_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let expiration_size = mem::size_of::<i32>();
        size = match size.checked_add(expiration_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let nonce_tpm_size = match self.nonce_tpm.marshalled_size() {
            Ok(nonce_tpm_size) => nonce_tpm_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(nonce_tpm_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let cp_hash_a_size = match self.cp_hash_a.marshalled_size() {
            Ok(cp_hash_a_size) => cp_hash_a_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(cp_hash_a_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let policy_ref_size = match self.policy_ref.marshalled_size() {
            Ok(policy_ref_size) => policy_ref_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(policy_ref_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let auth_size = match self.auth.marshalled_size() {
            Ok(auth_size) => auth_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(auth_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.nonce_tpm.marshal(buf)?;

        let buf = self.cp_hash_a.marshal(buf)?;

        let buf = self.policy_ref.marshal(buf)?;

        let buf = marshal_i32(buf, self.expiration)?;

        let buf = self.auth.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_nonce_tpm) = match Tpm2bDigest::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        let (buf, unmarshalled_cp_hash_a) = match Tpm2bDigest::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_policy_ref) = match Tpm2bDigest::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_expiration) = match unmarshal_i32(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_auth) = match TpmtSignature::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{nonce_tpm: unmarshalled_nonce_tpm, cp_hash_a: unmarshalled_cp_hash_a, policy_ref: unmarshalled_policy_ref, expiration: unmarshalled_expiration, auth: unmarshalled_auth}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2PolicySignedCommandParams<'static>, TpmErr> {
        Ok(Tpm2PolicySignedCommandParams {
            nonce_tpm: self.nonce_tpm.try_clone_intern()?,
            cp_hash_a: self.cp_hash_a.try_clone_intern()?,
            policy_ref: self.policy_ref.try_clone_intern()?,
            expiration: self.expiration,
            auth: self.auth.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2PolicySignedCommandParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2PolicySignedCommandParams<'static>, TpmErr> {
        let Self {
            nonce_tpm,
            cp_hash_a,
            policy_ref,
            expiration,
            auth,
        } = self;

        let nonce_tpm = nonce_tpm.into_bufs_owner_intern()?;
        let cp_hash_a = cp_hash_a.into_bufs_owner_intern()?;
        let policy_ref = policy_ref.into_bufs_owner_intern()?;
        let auth = auth.into_bufs_owner_intern()?;

        Ok(Tpm2PolicySignedCommandParams {
            nonce_tpm,
            cp_hash_a,
            policy_ref,
            expiration,
            auth,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2PolicySignedCommandParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpm2_policysigned_command_params_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    size += tpm2b_digest_marshalled_max_size() as u32;
    size += tpm2b_digest_marshalled_max_size() as u32;
    size += tpm2b_digest_marshalled_max_size() as u32;
    size += mem::size_of::<i32>() as u32;

    let auth_size = match tpmt_signature_marshalled_max_size(limits) {
        Ok(auth_size) => auth_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(auth_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 196, table 128, TPM2_PolicySigned_RESPONSE_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2PolicySignedResponseParams<'a> {
    pub timeout: Tpm2bTimeout<'a>,
    pub policy_ticket: TpmtTkAuth<'a>,
}

impl<'a> Tpm2PolicySignedResponseParams<'a> {
    pub const fn marshalled_max_size() -> u16 {
        tpm2_policysigned_response_params_marshalled_max_size()
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let timeout_size = match self.timeout.marshalled_size() {
            Ok(timeout_size) => timeout_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(timeout_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let policy_ticket_size = match self.policy_ticket.marshalled_size() {
            Ok(policy_ticket_size) => policy_ticket_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(policy_ticket_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.timeout.marshal(buf)?;

        let buf = self.policy_ticket.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_timeout) = match Tpm2bTimeout::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        let (buf, unmarshalled_policy_ticket) = match TpmtTkAuth::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{timeout: unmarshalled_timeout, policy_ticket: unmarshalled_policy_ticket}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2PolicySignedResponseParams<'static>, TpmErr> {
        Ok(Tpm2PolicySignedResponseParams {
            timeout: self.timeout.try_clone_intern()?,
            policy_ticket: self.policy_ticket.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2PolicySignedResponseParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2PolicySignedResponseParams<'static>, TpmErr> {
        let Self {
            timeout,
            policy_ticket,
        } = self;

        let timeout = timeout.into_bufs_owner_intern()?;
        let policy_ticket = policy_ticket.into_bufs_owner_intern()?;

        Ok(Tpm2PolicySignedResponseParams {
            timeout,
            policy_ticket,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2PolicySignedResponseParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

const fn tpm2_policysigned_response_params_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += tpm2b_timeout_marshalled_max_size();
    size += tpmt_tk_auth_marshalled_max_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 199, table 129, TPM2_PolicySecret_COMMAND_HANDLES structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2PolicySecretCommandHandles {
    pub auth_handle: TpmiDhEntity,
    pub policy_session: TpmiShPolicy,
}

impl Tpm2PolicySecretCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_policysecret_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.auth_handle.marshal(buf)?;

        let buf = self.policy_session.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_auth_handle) = match TpmiDhEntity::unmarshal(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_policy_session) = match TpmiShPolicy::unmarshal(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{auth_handle: unmarshalled_auth_handle, policy_session: unmarshalled_policy_session}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_policysecret_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiDhEntity::marshalled_size();
    size += TpmiShPolicy::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 199, table 129, TPM2_PolicySecret_COMMAND_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2PolicySecretCommandParams<'a> {
    pub nonce_tpm: Tpm2bDigest<'a>,
    pub cp_hash_a: Tpm2bDigest<'a>,
    pub policy_ref: Tpm2bDigest<'a>,
    pub expiration: i32,
}

impl<'a> Tpm2PolicySecretCommandParams<'a> {
    pub const fn marshalled_max_size() -> u16 {
        tpm2_policysecret_command_params_marshalled_max_size()
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let expiration_size = mem::size_of::<i32>();
        size = match size.checked_add(expiration_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let nonce_tpm_size = match self.nonce_tpm.marshalled_size() {
            Ok(nonce_tpm_size) => nonce_tpm_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(nonce_tpm_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let cp_hash_a_size = match self.cp_hash_a.marshalled_size() {
            Ok(cp_hash_a_size) => cp_hash_a_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(cp_hash_a_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let policy_ref_size = match self.policy_ref.marshalled_size() {
            Ok(policy_ref_size) => policy_ref_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(policy_ref_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.nonce_tpm.marshal(buf)?;

        let buf = self.cp_hash_a.marshal(buf)?;

        let buf = self.policy_ref.marshal(buf)?;

        let buf = marshal_i32(buf, self.expiration)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_nonce_tpm) = match Tpm2bDigest::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        let (buf, unmarshalled_cp_hash_a) = match Tpm2bDigest::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_policy_ref) = match Tpm2bDigest::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_expiration) = match unmarshal_i32(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{nonce_tpm: unmarshalled_nonce_tpm, cp_hash_a: unmarshalled_cp_hash_a, policy_ref: unmarshalled_policy_ref, expiration: unmarshalled_expiration}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2PolicySecretCommandParams<'static>, TpmErr> {
        Ok(Tpm2PolicySecretCommandParams {
            nonce_tpm: self.nonce_tpm.try_clone_intern()?,
            cp_hash_a: self.cp_hash_a.try_clone_intern()?,
            policy_ref: self.policy_ref.try_clone_intern()?,
            expiration: self.expiration,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2PolicySecretCommandParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2PolicySecretCommandParams<'static>, TpmErr> {
        let Self {
            nonce_tpm,
            cp_hash_a,
            policy_ref,
            expiration,
        } = self;

        let nonce_tpm = nonce_tpm.into_bufs_owner_intern()?;
        let cp_hash_a = cp_hash_a.into_bufs_owner_intern()?;
        let policy_ref = policy_ref.into_bufs_owner_intern()?;

        Ok(Tpm2PolicySecretCommandParams {
            nonce_tpm,
            cp_hash_a,
            policy_ref,
            expiration,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2PolicySecretCommandParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

const fn tpm2_policysecret_command_params_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += tpm2b_digest_marshalled_max_size();
    size += tpm2b_digest_marshalled_max_size();
    size += tpm2b_digest_marshalled_max_size();
    size += mem::size_of::<i32>() as u16;

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 199, table 130, TPM2_PolicySecret_RESPONSE_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2PolicySecretResponseParams<'a> {
    pub timeout: Tpm2bTimeout<'a>,
    pub policy_ticket: TpmtTkAuth<'a>,
}

impl<'a> Tpm2PolicySecretResponseParams<'a> {
    pub const fn marshalled_max_size() -> u16 {
        tpm2_policysecret_response_params_marshalled_max_size()
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let timeout_size = match self.timeout.marshalled_size() {
            Ok(timeout_size) => timeout_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(timeout_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let policy_ticket_size = match self.policy_ticket.marshalled_size() {
            Ok(policy_ticket_size) => policy_ticket_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(policy_ticket_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.timeout.marshal(buf)?;

        let buf = self.policy_ticket.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_timeout) = match Tpm2bTimeout::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        let (buf, unmarshalled_policy_ticket) = match TpmtTkAuth::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{timeout: unmarshalled_timeout, policy_ticket: unmarshalled_policy_ticket}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2PolicySecretResponseParams<'static>, TpmErr> {
        Ok(Tpm2PolicySecretResponseParams {
            timeout: self.timeout.try_clone_intern()?,
            policy_ticket: self.policy_ticket.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2PolicySecretResponseParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2PolicySecretResponseParams<'static>, TpmErr> {
        let Self {
            timeout,
            policy_ticket,
        } = self;

        let timeout = timeout.into_bufs_owner_intern()?;
        let policy_ticket = policy_ticket.into_bufs_owner_intern()?;

        Ok(Tpm2PolicySecretResponseParams {
            timeout,
            policy_ticket,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2PolicySecretResponseParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

const fn tpm2_policysecret_response_params_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += tpm2b_timeout_marshalled_max_size();
    size += tpmt_tk_auth_marshalled_max_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 202, table 131, TPM2_PolicyTicket_COMMAND_HANDLES structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2PolicyTicketCommandHandles {
    pub policy_session: TpmiShPolicy,
}

impl Tpm2PolicyTicketCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_policyticket_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.policy_session.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_policy_session) = match TpmiShPolicy::unmarshal(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{policy_session: unmarshalled_policy_session}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_policyticket_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiShPolicy::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 202, table 131, TPM2_PolicyTicket_COMMAND_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2PolicyTicketCommandParams<'a> {
    pub timeout: Tpm2bTimeout<'a>,
    pub cp_hash_a: Tpm2bDigest<'a>,
    pub policy_ref: Tpm2bDigest<'a>,
    pub auth_name: Tpm2bName<'a>,
    pub ticket: TpmtTkAuth<'a>,
}

impl<'a> Tpm2PolicyTicketCommandParams<'a> {
    pub const fn marshalled_max_size() -> u16 {
        tpm2_policyticket_command_params_marshalled_max_size()
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let timeout_size = match self.timeout.marshalled_size() {
            Ok(timeout_size) => timeout_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(timeout_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let cp_hash_a_size = match self.cp_hash_a.marshalled_size() {
            Ok(cp_hash_a_size) => cp_hash_a_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(cp_hash_a_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let policy_ref_size = match self.policy_ref.marshalled_size() {
            Ok(policy_ref_size) => policy_ref_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(policy_ref_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let auth_name_size = match self.auth_name.marshalled_size() {
            Ok(auth_name_size) => auth_name_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(auth_name_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let ticket_size = match self.ticket.marshalled_size() {
            Ok(ticket_size) => ticket_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(ticket_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.timeout.marshal(buf)?;

        let buf = self.cp_hash_a.marshal(buf)?;

        let buf = self.policy_ref.marshal(buf)?;

        let buf = self.auth_name.marshal(buf)?;

        let buf = self.ticket.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_timeout) = match Tpm2bTimeout::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        let (buf, unmarshalled_cp_hash_a) = match Tpm2bDigest::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_policy_ref) = match Tpm2bDigest::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_auth_name) = match Tpm2bName::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_ticket) = match TpmtTkAuth::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{timeout: unmarshalled_timeout, cp_hash_a: unmarshalled_cp_hash_a, policy_ref: unmarshalled_policy_ref, auth_name: unmarshalled_auth_name, ticket: unmarshalled_ticket}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2PolicyTicketCommandParams<'static>, TpmErr> {
        Ok(Tpm2PolicyTicketCommandParams {
            timeout: self.timeout.try_clone_intern()?,
            cp_hash_a: self.cp_hash_a.try_clone_intern()?,
            policy_ref: self.policy_ref.try_clone_intern()?,
            auth_name: self.auth_name.try_clone_intern()?,
            ticket: self.ticket.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2PolicyTicketCommandParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2PolicyTicketCommandParams<'static>, TpmErr> {
        let Self {
            timeout,
            cp_hash_a,
            policy_ref,
            auth_name,
            ticket,
        } = self;

        let timeout = timeout.into_bufs_owner_intern()?;
        let cp_hash_a = cp_hash_a.into_bufs_owner_intern()?;
        let policy_ref = policy_ref.into_bufs_owner_intern()?;
        let auth_name = auth_name.into_bufs_owner_intern()?;
        let ticket = ticket.into_bufs_owner_intern()?;

        Ok(Tpm2PolicyTicketCommandParams {
            timeout,
            cp_hash_a,
            policy_ref,
            auth_name,
            ticket,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2PolicyTicketCommandParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

const fn tpm2_policyticket_command_params_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += tpm2b_timeout_marshalled_max_size();
    size += tpm2b_digest_marshalled_max_size();
    size += tpm2b_digest_marshalled_max_size();
    size += tpm2b_name_marshalled_max_size();
    size += tpmt_tk_auth_marshalled_max_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 204, table 133, TPM2_PolicyOR_COMMAND_HANDLES structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2PolicyORCommandHandles {
    pub policy_session: TpmiShPolicy,
}

impl Tpm2PolicyORCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_policyor_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.policy_session.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_policy_session) = match TpmiShPolicy::unmarshal(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{policy_session: unmarshalled_policy_session}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_policyor_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiShPolicy::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 204, table 133, TPM2_PolicyOR_COMMAND_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2PolicyORCommandParams<'a> {
    pub p_hash_list: TpmlDigest<'a>,
}

impl<'a> Tpm2PolicyORCommandParams<'a> {
    pub const fn marshalled_max_size() -> u16 {
        tpm2_policyor_command_params_marshalled_max_size()
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let p_hash_list_size = match self.p_hash_list.marshalled_size() {
            Ok(p_hash_list_size) => p_hash_list_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(p_hash_list_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.p_hash_list.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_p_hash_list) = match TpmlDigest::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{p_hash_list: unmarshalled_p_hash_list}))
    }

    pub fn unmarshal(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2PolicyORCommandParams<'static>, TpmErr> {
        Ok(Tpm2PolicyORCommandParams {
            p_hash_list: self.p_hash_list.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2PolicyORCommandParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2PolicyORCommandParams<'static>, TpmErr> {
        let Self {
            p_hash_list,
        } = self;

        let p_hash_list = p_hash_list.into_bufs_owner_intern()?;

        Ok(Tpm2PolicyORCommandParams {
            p_hash_list,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2PolicyORCommandParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

const fn tpm2_policyor_command_params_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += tpml_digest_marshalled_max_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 207, table 135, TPM2_PolicyPCR_COMMAND_HANDLES structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2PolicyPCRCommandHandles {
    pub policy_session: TpmiShPolicy,
}

impl Tpm2PolicyPCRCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_policypcr_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.policy_session.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_policy_session) = match TpmiShPolicy::unmarshal(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{policy_session: unmarshalled_policy_session}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_policypcr_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiShPolicy::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 207, table 135, TPM2_PolicyPCR_COMMAND_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2PolicyPCRCommandParams<'a> {
    pub pcr_digest: Tpm2bDigest<'a>,
    pub pcrs: TpmlPcrSelection<'a>,
}

impl<'a> Tpm2PolicyPCRCommandParams<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2_policypcr_command_params_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let pcr_digest_size = match self.pcr_digest.marshalled_size() {
            Ok(pcr_digest_size) => pcr_digest_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(pcr_digest_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let pcrs_size = match self.pcrs.marshalled_size() {
            Ok(pcrs_size) => pcrs_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(pcrs_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.pcr_digest.marshal(buf)?;

        let buf = self.pcrs.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_pcr_digest) = match Tpm2bDigest::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        let (buf, unmarshalled_pcrs) = match TpmlPcrSelection::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{pcr_digest: unmarshalled_pcr_digest, pcrs: unmarshalled_pcrs}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2PolicyPCRCommandParams<'static>, TpmErr> {
        Ok(Tpm2PolicyPCRCommandParams {
            pcr_digest: self.pcr_digest.try_clone_intern()?,
            pcrs: self.pcrs.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2PolicyPCRCommandParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2PolicyPCRCommandParams<'static>, TpmErr> {
        let Self {
            pcr_digest,
            pcrs,
        } = self;

        let pcr_digest = pcr_digest.into_bufs_owner_intern()?;
        let pcrs = pcrs.into_bufs_owner_intern()?;

        Ok(Tpm2PolicyPCRCommandParams {
            pcr_digest,
            pcrs,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2PolicyPCRCommandParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpm2_policypcr_command_params_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    size += tpm2b_digest_marshalled_max_size() as u32;

    let pcrs_size = match tpml_pcr_selection_marshalled_max_size(limits) {
        Ok(pcrs_size) => pcrs_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(pcrs_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 209, table 137, TPM2_PolicyLocality_COMMAND_HANDLES structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2PolicyLocalityCommandHandles {
    pub policy_session: TpmiShPolicy,
}

impl Tpm2PolicyLocalityCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_policylocality_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.policy_session.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_policy_session) = match TpmiShPolicy::unmarshal(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{policy_session: unmarshalled_policy_session}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_policylocality_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiShPolicy::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 209, table 137, TPM2_PolicyLocality_COMMAND_PARAMS structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2PolicyLocalityCommandParams {
    pub locality: TpmaLocality,
}

impl Tpm2PolicyLocalityCommandParams {
    pub const fn marshalled_size() -> u16 {
        tpm2_policylocality_command_params_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.locality.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_locality) = match TpmaLocality::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{locality: unmarshalled_locality}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_policylocality_command_params_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmaLocality::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 212, table 139, TPM2_PolicyNV_COMMAND_HANDLES structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2PolicyNVCommandHandles {
    pub auth_handle: TpmiRhNvAuth,
    pub nv_index: TpmiRhNvIndex,
    pub policy_session: TpmiShPolicy,
}

impl Tpm2PolicyNVCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_policynv_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.auth_handle.marshal(buf)?;

        let buf = self.nv_index.marshal(buf)?;

        let buf = self.policy_session.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_auth_handle) = match TpmiRhNvAuth::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_nv_index) = match TpmiRhNvIndex::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_policy_session) = match TpmiShPolicy::unmarshal(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{auth_handle: unmarshalled_auth_handle, nv_index: unmarshalled_nv_index, policy_session: unmarshalled_policy_session}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_policynv_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiRhNvAuth::marshalled_size();
    size += TpmiRhNvIndex::marshalled_size();
    size += TpmiShPolicy::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 212, table 139, TPM2_PolicyNV_COMMAND_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2PolicyNVCommandParams<'a> {
    pub operand_b: Tpm2bDigest<'a>,
    pub offset: u16,
    pub operation: TpmEo,
}

impl<'a> Tpm2PolicyNVCommandParams<'a> {
    pub const fn marshalled_max_size() -> u16 {
        tpm2_policynv_command_params_marshalled_max_size()
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let offset_size = mem::size_of::<u16>();
        size = match size.checked_add(offset_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let operation_size = match usize::try_from(TpmEo::marshalled_size()) {
            Ok(operation_size) => operation_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(operation_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let operand_b_size = match self.operand_b.marshalled_size() {
            Ok(operand_b_size) => operand_b_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(operand_b_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.operand_b.marshal(buf)?;

        let buf = marshal_u16(buf, self.offset)?;

        let buf = self.operation.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_operand_b) = match Tpm2bDigest::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        let (buf, unmarshalled_offset) = match unmarshal_u16(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_operation) = match TpmEo::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{operand_b: unmarshalled_operand_b, offset: unmarshalled_offset, operation: unmarshalled_operation}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2PolicyNVCommandParams<'static>, TpmErr> {
        Ok(Tpm2PolicyNVCommandParams {
            operand_b: self.operand_b.try_clone_intern()?,
            offset: self.offset,
            operation: self.operation,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2PolicyNVCommandParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2PolicyNVCommandParams<'static>, TpmErr> {
        let Self {
            operand_b,
            offset,
            operation,
        } = self;

        let operand_b = operand_b.into_bufs_owner_intern()?;

        Ok(Tpm2PolicyNVCommandParams {
            operand_b,
            offset,
            operation,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2PolicyNVCommandParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

const fn tpm2_policynv_command_params_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += tpm2b_digest_marshalled_max_size();
    size += mem::size_of::<u16>() as u16;
    size += TpmEo::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 215, table 141, TPM2_PolicyCounterTimer_COMMAND_HANDLES structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2PolicyCounterTimerCommandHandles {
    pub policy_session: TpmiShPolicy,
}

impl Tpm2PolicyCounterTimerCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_policycountertimer_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.policy_session.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_policy_session) = match TpmiShPolicy::unmarshal(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{policy_session: unmarshalled_policy_session}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_policycountertimer_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiShPolicy::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 215, table 141, TPM2_PolicyCounterTimer_COMMAND_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2PolicyCounterTimerCommandParams<'a> {
    pub operand_b: Tpm2bDigest<'a>,
    pub offset: u16,
    pub operation: TpmEo,
}

impl<'a> Tpm2PolicyCounterTimerCommandParams<'a> {
    pub const fn marshalled_max_size() -> u16 {
        tpm2_policycountertimer_command_params_marshalled_max_size()
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let offset_size = mem::size_of::<u16>();
        size = match size.checked_add(offset_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let operation_size = match usize::try_from(TpmEo::marshalled_size()) {
            Ok(operation_size) => operation_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(operation_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let operand_b_size = match self.operand_b.marshalled_size() {
            Ok(operand_b_size) => operand_b_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(operand_b_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.operand_b.marshal(buf)?;

        let buf = marshal_u16(buf, self.offset)?;

        let buf = self.operation.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_operand_b) = match Tpm2bDigest::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        let (buf, unmarshalled_offset) = match unmarshal_u16(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_operation) = match TpmEo::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{operand_b: unmarshalled_operand_b, offset: unmarshalled_offset, operation: unmarshalled_operation}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2PolicyCounterTimerCommandParams<'static>, TpmErr> {
        Ok(Tpm2PolicyCounterTimerCommandParams {
            operand_b: self.operand_b.try_clone_intern()?,
            offset: self.offset,
            operation: self.operation,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2PolicyCounterTimerCommandParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2PolicyCounterTimerCommandParams<'static>, TpmErr> {
        let Self {
            operand_b,
            offset,
            operation,
        } = self;

        let operand_b = operand_b.into_bufs_owner_intern()?;

        Ok(Tpm2PolicyCounterTimerCommandParams {
            operand_b,
            offset,
            operation,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2PolicyCounterTimerCommandParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

const fn tpm2_policycountertimer_command_params_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += tpm2b_digest_marshalled_max_size();
    size += mem::size_of::<u16>() as u16;
    size += TpmEo::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 217, table 143, TPM2_PolicyCommandCode_COMMAND_HANDLES structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2PolicyCommandCodeCommandHandles {
    pub policy_session: TpmiShPolicy,
}

impl Tpm2PolicyCommandCodeCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_policycommandcode_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.policy_session.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_policy_session) = match TpmiShPolicy::unmarshal(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{policy_session: unmarshalled_policy_session}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_policycommandcode_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiShPolicy::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 217, table 143, TPM2_PolicyCommandCode_COMMAND_PARAMS structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2PolicyCommandCodeCommandParams {
    pub code: TpmCc,
}

impl Tpm2PolicyCommandCodeCommandParams {
    pub const fn marshalled_size() -> u16 {
        tpm2_policycommandcode_command_params_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.code.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_code) = match TpmCc::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{code: unmarshalled_code}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_policycommandcode_command_params_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmCc::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 219, table 145, TPM2_PolicyPhysicalPresence_COMMAND_HANDLES structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2PolicyPhysicalPresenceCommandHandles {
    pub policy_session: TpmiShPolicy,
}

impl Tpm2PolicyPhysicalPresenceCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_policyphysicalpresence_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.policy_session.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_policy_session) = match TpmiShPolicy::unmarshal(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{policy_session: unmarshalled_policy_session}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_policyphysicalpresence_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiShPolicy::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 221, table 147, TPM2_PolicyCpHash_COMMAND_HANDLES structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2PolicyCpHashCommandHandles {
    pub policy_session: TpmiShPolicy,
}

impl Tpm2PolicyCpHashCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_policycphash_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.policy_session.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_policy_session) = match TpmiShPolicy::unmarshal(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{policy_session: unmarshalled_policy_session}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_policycphash_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiShPolicy::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 221, table 147, TPM2_PolicyCpHash_COMMAND_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2PolicyCpHashCommandParams<'a> {
    pub cp_hash_a: Tpm2bDigest<'a>,
}

impl<'a> Tpm2PolicyCpHashCommandParams<'a> {
    pub const fn marshalled_max_size() -> u16 {
        tpm2_policycphash_command_params_marshalled_max_size()
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let cp_hash_a_size = match self.cp_hash_a.marshalled_size() {
            Ok(cp_hash_a_size) => cp_hash_a_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(cp_hash_a_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.cp_hash_a.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_cp_hash_a) = match Tpm2bDigest::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        Ok((buf, Self{cp_hash_a: unmarshalled_cp_hash_a}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2PolicyCpHashCommandParams<'static>, TpmErr> {
        Ok(Tpm2PolicyCpHashCommandParams {
            cp_hash_a: self.cp_hash_a.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2PolicyCpHashCommandParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2PolicyCpHashCommandParams<'static>, TpmErr> {
        let Self {
            cp_hash_a,
        } = self;

        let cp_hash_a = cp_hash_a.into_bufs_owner_intern()?;

        Ok(Tpm2PolicyCpHashCommandParams {
            cp_hash_a,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2PolicyCpHashCommandParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

const fn tpm2_policycphash_command_params_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += tpm2b_digest_marshalled_max_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 223, table 149, TPM2_PolicyNameHash_COMMAND_HANDLES structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2PolicyNameHashCommandHandles {
    pub policy_session: TpmiShPolicy,
}

impl Tpm2PolicyNameHashCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_policynamehash_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.policy_session.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_policy_session) = match TpmiShPolicy::unmarshal(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{policy_session: unmarshalled_policy_session}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_policynamehash_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiShPolicy::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 223, table 149, TPM2_PolicyNameHash_COMMAND_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2PolicyNameHashCommandParams<'a> {
    pub name_hash: Tpm2bDigest<'a>,
}

impl<'a> Tpm2PolicyNameHashCommandParams<'a> {
    pub const fn marshalled_max_size() -> u16 {
        tpm2_policynamehash_command_params_marshalled_max_size()
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let name_hash_size = match self.name_hash.marshalled_size() {
            Ok(name_hash_size) => name_hash_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(name_hash_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.name_hash.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_name_hash) = match Tpm2bDigest::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        Ok((buf, Self{name_hash: unmarshalled_name_hash}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2PolicyNameHashCommandParams<'static>, TpmErr> {
        Ok(Tpm2PolicyNameHashCommandParams {
            name_hash: self.name_hash.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2PolicyNameHashCommandParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2PolicyNameHashCommandParams<'static>, TpmErr> {
        let Self {
            name_hash,
        } = self;

        let name_hash = name_hash.into_bufs_owner_intern()?;

        Ok(Tpm2PolicyNameHashCommandParams {
            name_hash,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2PolicyNameHashCommandParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

const fn tpm2_policynamehash_command_params_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += tpm2b_digest_marshalled_max_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 226, table 151, TPM2_PolicyDuplicationSelect_COMMAND_HANDLES structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2PolicyDuplicationSelectCommandHandles {
    pub policy_session: TpmiShPolicy,
}

impl Tpm2PolicyDuplicationSelectCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_policyduplicationselect_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.policy_session.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_policy_session) = match TpmiShPolicy::unmarshal(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{policy_session: unmarshalled_policy_session}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_policyduplicationselect_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiShPolicy::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 226, table 151, TPM2_PolicyDuplicationSelect_COMMAND_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2PolicyDuplicationSelectCommandParams<'a> {
    pub object_name: Tpm2bName<'a>,
    pub new_parent_name: Tpm2bName<'a>,
    pub include_object: TpmiYesNo,
}

impl<'a> Tpm2PolicyDuplicationSelectCommandParams<'a> {
    pub const fn marshalled_max_size() -> u16 {
        tpm2_policyduplicationselect_command_params_marshalled_max_size()
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let include_object_size = match usize::try_from(TpmiYesNo::marshalled_size()) {
            Ok(include_object_size) => include_object_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(include_object_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let object_name_size = match self.object_name.marshalled_size() {
            Ok(object_name_size) => object_name_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(object_name_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let new_parent_name_size = match self.new_parent_name.marshalled_size() {
            Ok(new_parent_name_size) => new_parent_name_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(new_parent_name_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.object_name.marshal(buf)?;

        let buf = self.new_parent_name.marshal(buf)?;

        let buf = self.include_object.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_object_name) = match Tpm2bName::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        let (buf, unmarshalled_new_parent_name) = match Tpm2bName::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_include_object) = match TpmiYesNo::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{object_name: unmarshalled_object_name, new_parent_name: unmarshalled_new_parent_name, include_object: unmarshalled_include_object}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2PolicyDuplicationSelectCommandParams<'static>, TpmErr> {
        Ok(Tpm2PolicyDuplicationSelectCommandParams {
            object_name: self.object_name.try_clone_intern()?,
            new_parent_name: self.new_parent_name.try_clone_intern()?,
            include_object: self.include_object,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2PolicyDuplicationSelectCommandParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2PolicyDuplicationSelectCommandParams<'static>, TpmErr> {
        let Self {
            object_name,
            new_parent_name,
            include_object,
        } = self;

        let object_name = object_name.into_bufs_owner_intern()?;
        let new_parent_name = new_parent_name.into_bufs_owner_intern()?;

        Ok(Tpm2PolicyDuplicationSelectCommandParams {
            object_name,
            new_parent_name,
            include_object,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2PolicyDuplicationSelectCommandParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

const fn tpm2_policyduplicationselect_command_params_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += tpm2b_name_marshalled_max_size();
    size += tpm2b_name_marshalled_max_size();
    size += TpmiYesNo::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 228, table 153, TPM2_PolicyAuthorize_COMMAND_HANDLES structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2PolicyAuthorizeCommandHandles {
    pub policy_session: TpmiShPolicy,
}

impl Tpm2PolicyAuthorizeCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_policyauthorize_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.policy_session.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_policy_session) = match TpmiShPolicy::unmarshal(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{policy_session: unmarshalled_policy_session}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_policyauthorize_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiShPolicy::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 228, table 153, TPM2_PolicyAuthorize_COMMAND_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2PolicyAuthorizeCommandParams<'a> {
    pub approved_policy: Tpm2bDigest<'a>,
    pub policy_ref: Tpm2bDigest<'a>,
    pub key_sign: Tpm2bName<'a>,
    pub check_ticket: TpmtTkVerified<'a>,
}

impl<'a> Tpm2PolicyAuthorizeCommandParams<'a> {
    pub const fn marshalled_max_size() -> u16 {
        tpm2_policyauthorize_command_params_marshalled_max_size()
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let approved_policy_size = match self.approved_policy.marshalled_size() {
            Ok(approved_policy_size) => approved_policy_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(approved_policy_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let policy_ref_size = match self.policy_ref.marshalled_size() {
            Ok(policy_ref_size) => policy_ref_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(policy_ref_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let key_sign_size = match self.key_sign.marshalled_size() {
            Ok(key_sign_size) => key_sign_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(key_sign_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let check_ticket_size = match self.check_ticket.marshalled_size() {
            Ok(check_ticket_size) => check_ticket_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(check_ticket_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.approved_policy.marshal(buf)?;

        let buf = self.policy_ref.marshal(buf)?;

        let buf = self.key_sign.marshal(buf)?;

        let buf = self.check_ticket.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_approved_policy) = match Tpm2bDigest::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        let (buf, unmarshalled_policy_ref) = match Tpm2bDigest::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_key_sign) = match Tpm2bName::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_check_ticket) = match TpmtTkVerified::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{approved_policy: unmarshalled_approved_policy, policy_ref: unmarshalled_policy_ref, key_sign: unmarshalled_key_sign, check_ticket: unmarshalled_check_ticket}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2PolicyAuthorizeCommandParams<'static>, TpmErr> {
        Ok(Tpm2PolicyAuthorizeCommandParams {
            approved_policy: self.approved_policy.try_clone_intern()?,
            policy_ref: self.policy_ref.try_clone_intern()?,
            key_sign: self.key_sign.try_clone_intern()?,
            check_ticket: self.check_ticket.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2PolicyAuthorizeCommandParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2PolicyAuthorizeCommandParams<'static>, TpmErr> {
        let Self {
            approved_policy,
            policy_ref,
            key_sign,
            check_ticket,
        } = self;

        let approved_policy = approved_policy.into_bufs_owner_intern()?;
        let policy_ref = policy_ref.into_bufs_owner_intern()?;
        let key_sign = key_sign.into_bufs_owner_intern()?;
        let check_ticket = check_ticket.into_bufs_owner_intern()?;

        Ok(Tpm2PolicyAuthorizeCommandParams {
            approved_policy,
            policy_ref,
            key_sign,
            check_ticket,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2PolicyAuthorizeCommandParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

const fn tpm2_policyauthorize_command_params_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += tpm2b_digest_marshalled_max_size();
    size += tpm2b_digest_marshalled_max_size();
    size += tpm2b_name_marshalled_max_size();
    size += tpmt_tk_verified_marshalled_max_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 230, table 155, TPM2_PolicyAuthValue_COMMAND_HANDLES structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2PolicyAuthValueCommandHandles {
    pub policy_session: TpmiShPolicy,
}

impl Tpm2PolicyAuthValueCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_policyauthvalue_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.policy_session.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_policy_session) = match TpmiShPolicy::unmarshal(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{policy_session: unmarshalled_policy_session}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_policyauthvalue_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiShPolicy::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 232, table 157, TPM2_PolicyPassword_COMMAND_HANDLES structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2PolicyPasswordCommandHandles {
    pub policy_session: TpmiShPolicy,
}

impl Tpm2PolicyPasswordCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_policypassword_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.policy_session.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_policy_session) = match TpmiShPolicy::unmarshal(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{policy_session: unmarshalled_policy_session}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_policypassword_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiShPolicy::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 234, table 159, TPM2_PolicyGetDigest_COMMAND_HANDLES structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2PolicyGetDigestCommandHandles {
    pub policy_session: TpmiShPolicy,
}

impl Tpm2PolicyGetDigestCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_policygetdigest_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.policy_session.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_policy_session) = match TpmiShPolicy::unmarshal(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{policy_session: unmarshalled_policy_session}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_policygetdigest_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiShPolicy::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 234, table 160, TPM2_PolicyGetDigest_RESPONSE_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2PolicyGetDigestResponseParams<'a> {
    pub policy_digest: Tpm2bDigest<'a>,
}

impl<'a> Tpm2PolicyGetDigestResponseParams<'a> {
    pub const fn marshalled_max_size() -> u16 {
        tpm2_policygetdigest_response_params_marshalled_max_size()
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let policy_digest_size = match self.policy_digest.marshalled_size() {
            Ok(policy_digest_size) => policy_digest_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(policy_digest_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.policy_digest.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_policy_digest) = match Tpm2bDigest::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        Ok((buf, Self{policy_digest: unmarshalled_policy_digest}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2PolicyGetDigestResponseParams<'static>, TpmErr> {
        Ok(Tpm2PolicyGetDigestResponseParams {
            policy_digest: self.policy_digest.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2PolicyGetDigestResponseParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2PolicyGetDigestResponseParams<'static>, TpmErr> {
        let Self {
            policy_digest,
        } = self;

        let policy_digest = policy_digest.into_bufs_owner_intern()?;

        Ok(Tpm2PolicyGetDigestResponseParams {
            policy_digest,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2PolicyGetDigestResponseParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

const fn tpm2_policygetdigest_response_params_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += tpm2b_digest_marshalled_max_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 236, table 161, TPM2_PolicyNvWritten_COMMAND_HANDLES structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2PolicyNvWrittenCommandHandles {
    pub policy_session: TpmiShPolicy,
}

impl Tpm2PolicyNvWrittenCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_policynvwritten_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.policy_session.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_policy_session) = match TpmiShPolicy::unmarshal(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{policy_session: unmarshalled_policy_session}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_policynvwritten_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiShPolicy::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 236, table 161, TPM2_PolicyNvWritten_COMMAND_PARAMS structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2PolicyNvWrittenCommandParams {
    pub written_set: TpmiYesNo,
}

impl Tpm2PolicyNvWrittenCommandParams {
    pub const fn marshalled_size() -> u16 {
        tpm2_policynvwritten_command_params_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.written_set.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_written_set) = match TpmiYesNo::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{written_set: unmarshalled_written_set}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_policynvwritten_command_params_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiYesNo::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 238, table 163, TPM2_PolicyTemplate_COMMAND_HANDLES structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2PolicyTemplateCommandHandles {
    pub policy_session: TpmiShPolicy,
}

impl Tpm2PolicyTemplateCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_policytemplate_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.policy_session.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_policy_session) = match TpmiShPolicy::unmarshal(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{policy_session: unmarshalled_policy_session}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_policytemplate_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiShPolicy::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 238, table 163, TPM2_PolicyTemplate_COMMAND_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2PolicyTemplateCommandParams<'a> {
    pub template_hash: Tpm2bDigest<'a>,
}

impl<'a> Tpm2PolicyTemplateCommandParams<'a> {
    pub const fn marshalled_max_size() -> u16 {
        tpm2_policytemplate_command_params_marshalled_max_size()
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let template_hash_size = match self.template_hash.marshalled_size() {
            Ok(template_hash_size) => template_hash_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(template_hash_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.template_hash.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_template_hash) = match Tpm2bDigest::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        Ok((buf, Self{template_hash: unmarshalled_template_hash}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2PolicyTemplateCommandParams<'static>, TpmErr> {
        Ok(Tpm2PolicyTemplateCommandParams {
            template_hash: self.template_hash.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2PolicyTemplateCommandParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2PolicyTemplateCommandParams<'static>, TpmErr> {
        let Self {
            template_hash,
        } = self;

        let template_hash = template_hash.into_bufs_owner_intern()?;

        Ok(Tpm2PolicyTemplateCommandParams {
            template_hash,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2PolicyTemplateCommandParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

const fn tpm2_policytemplate_command_params_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += tpm2b_digest_marshalled_max_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 241, table 165, TPM2_PolicyAuthorizeNV_COMMAND_HANDLES structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2PolicyAuthorizeNVCommandHandles {
    pub auth_handle: TpmiRhNvAuth,
    pub nv_index: TpmiRhNvIndex,
    pub policy_session: TpmiShPolicy,
}

impl Tpm2PolicyAuthorizeNVCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_policyauthorizenv_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.auth_handle.marshal(buf)?;

        let buf = self.nv_index.marshal(buf)?;

        let buf = self.policy_session.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_auth_handle) = match TpmiRhNvAuth::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_nv_index) = match TpmiRhNvIndex::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_policy_session) = match TpmiShPolicy::unmarshal(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{auth_handle: unmarshalled_auth_handle, nv_index: unmarshalled_nv_index, policy_session: unmarshalled_policy_session}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_policyauthorizenv_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiRhNvAuth::marshalled_size();
    size += TpmiRhNvIndex::marshalled_size();
    size += TpmiShPolicy::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 244, table 168, TPM2_PolicyCapability_COMMAND_HANDLES structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2PolicyCapabilityCommandHandles {
    pub policy_session: TpmiShPolicy,
}

impl Tpm2PolicyCapabilityCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_policycapability_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.policy_session.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_policy_session) = match TpmiShPolicy::unmarshal(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{policy_session: unmarshalled_policy_session}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_policycapability_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiShPolicy::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 244, table 168, TPM2_PolicyCapability_COMMAND_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2PolicyCapabilityCommandParams<'a> {
    pub operand_b: Tpm2bDigest<'a>,
    pub offset: u16,
    pub operation: TpmEo,
    pub capability: TpmCap,
    pub property: u32,
}

impl<'a> Tpm2PolicyCapabilityCommandParams<'a> {
    pub const fn marshalled_max_size() -> u16 {
        tpm2_policycapability_command_params_marshalled_max_size()
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let offset_size = mem::size_of::<u16>();
        size = match size.checked_add(offset_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let operation_size = match usize::try_from(TpmEo::marshalled_size()) {
            Ok(operation_size) => operation_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(operation_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let capability_size = match usize::try_from(TpmCap::marshalled_size()) {
            Ok(capability_size) => capability_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(capability_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let property_size = mem::size_of::<u32>();
        size = match size.checked_add(property_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let operand_b_size = match self.operand_b.marshalled_size() {
            Ok(operand_b_size) => operand_b_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(operand_b_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.operand_b.marshal(buf)?;

        let buf = marshal_u16(buf, self.offset)?;

        let buf = self.operation.marshal(buf)?;

        let buf = self.capability.marshal(buf)?;

        let buf = marshal_u32(buf, self.property)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_operand_b) = match Tpm2bDigest::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        let (buf, unmarshalled_offset) = match unmarshal_u16(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_operation) = match TpmEo::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_capability) = match TpmCap::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_property) = match unmarshal_u32(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{operand_b: unmarshalled_operand_b, offset: unmarshalled_offset, operation: unmarshalled_operation, capability: unmarshalled_capability, property: unmarshalled_property}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2PolicyCapabilityCommandParams<'static>, TpmErr> {
        Ok(Tpm2PolicyCapabilityCommandParams {
            operand_b: self.operand_b.try_clone_intern()?,
            offset: self.offset,
            operation: self.operation,
            capability: self.capability,
            property: self.property,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2PolicyCapabilityCommandParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2PolicyCapabilityCommandParams<'static>, TpmErr> {
        let Self {
            operand_b,
            offset,
            operation,
            capability,
            property,
        } = self;

        let operand_b = operand_b.into_bufs_owner_intern()?;

        Ok(Tpm2PolicyCapabilityCommandParams {
            operand_b,
            offset,
            operation,
            capability,
            property,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2PolicyCapabilityCommandParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

const fn tpm2_policycapability_command_params_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += tpm2b_digest_marshalled_max_size();
    size += mem::size_of::<u16>() as u16;
    size += TpmEo::marshalled_size();
    size += TpmCap::marshalled_size();
    size += mem::size_of::<u32>() as u16;

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 246, table 170, TPM2_PolicyParameters_COMMAND_HANDLES structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2PolicyParametersCommandHandles {
    pub policy_session: TpmiShPolicy,
}

impl Tpm2PolicyParametersCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_policyparameters_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.policy_session.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_policy_session) = match TpmiShPolicy::unmarshal(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{policy_session: unmarshalled_policy_session}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_policyparameters_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiShPolicy::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 246, table 170, TPM2_PolicyParameters_COMMAND_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2PolicyParametersCommandParams<'a> {
    pub p_hash: Tpm2bDigest<'a>,
}

impl<'a> Tpm2PolicyParametersCommandParams<'a> {
    pub const fn marshalled_max_size() -> u16 {
        tpm2_policyparameters_command_params_marshalled_max_size()
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let p_hash_size = match self.p_hash.marshalled_size() {
            Ok(p_hash_size) => p_hash_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(p_hash_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.p_hash.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_p_hash) = match Tpm2bDigest::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        Ok((buf, Self{p_hash: unmarshalled_p_hash}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2PolicyParametersCommandParams<'static>, TpmErr> {
        Ok(Tpm2PolicyParametersCommandParams {
            p_hash: self.p_hash.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2PolicyParametersCommandParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2PolicyParametersCommandParams<'static>, TpmErr> {
        let Self {
            p_hash,
        } = self;

        let p_hash = p_hash.into_bufs_owner_intern()?;

        Ok(Tpm2PolicyParametersCommandParams {
            p_hash,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2PolicyParametersCommandParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

const fn tpm2_policyparameters_command_params_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += tpm2b_digest_marshalled_max_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 249, table 172, TPM2_PolicyTransportSPDM_COMMAND_HANDLES structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2PolicyTransportSPDMCommandHandles {
    pub policy_session: TpmiShPolicy,
}

impl Tpm2PolicyTransportSPDMCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_policytransportspdm_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.policy_session.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_policy_session) = match TpmiShPolicy::unmarshal(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{policy_session: unmarshalled_policy_session}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_policytransportspdm_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiShPolicy::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 249, table 172, TPM2_PolicyTransportSPDM_COMMAND_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2PolicyTransportSPDMCommandParams<'a> {
    pub req_key_name: Tpm2bName<'a>,
    pub tpm_key_name: Tpm2bName<'a>,
}

impl<'a> Tpm2PolicyTransportSPDMCommandParams<'a> {
    pub const fn marshalled_max_size() -> u16 {
        tpm2_policytransportspdm_command_params_marshalled_max_size()
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let req_key_name_size = match self.req_key_name.marshalled_size() {
            Ok(req_key_name_size) => req_key_name_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(req_key_name_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let tpm_key_name_size = match self.tpm_key_name.marshalled_size() {
            Ok(tpm_key_name_size) => tpm_key_name_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(tpm_key_name_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.req_key_name.marshal(buf)?;

        let buf = self.tpm_key_name.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_req_key_name) = match Tpm2bName::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        let (buf, unmarshalled_tpm_key_name) = match Tpm2bName::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{req_key_name: unmarshalled_req_key_name, tpm_key_name: unmarshalled_tpm_key_name}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2PolicyTransportSPDMCommandParams<'static>, TpmErr> {
        Ok(Tpm2PolicyTransportSPDMCommandParams {
            req_key_name: self.req_key_name.try_clone_intern()?,
            tpm_key_name: self.tpm_key_name.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2PolicyTransportSPDMCommandParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2PolicyTransportSPDMCommandParams<'static>, TpmErr> {
        let Self {
            req_key_name,
            tpm_key_name,
        } = self;

        let req_key_name = req_key_name.into_bufs_owner_intern()?;
        let tpm_key_name = tpm_key_name.into_bufs_owner_intern()?;

        Ok(Tpm2PolicyTransportSPDMCommandParams {
            req_key_name,
            tpm_key_name,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2PolicyTransportSPDMCommandParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

const fn tpm2_policytransportspdm_command_params_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += tpm2b_name_marshalled_max_size();
    size += tpm2b_name_marshalled_max_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 252, table 174, TPM2_CreatePrimary_COMMAND_HANDLES structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2CreatePrimaryCommandHandles {
    pub primary_handle: TpmiRhHierarchy,
}

impl Tpm2CreatePrimaryCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_createprimary_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.primary_handle.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_primary_handle) = match TpmiRhHierarchy::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{primary_handle: unmarshalled_primary_handle}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_createprimary_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiRhHierarchy::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 252, table 174, TPM2_CreatePrimary_COMMAND_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2CreatePrimaryCommandParams<'a> {
    pub in_sensitive: Tpm2bSensitiveCreate<'a>,
    pub in_public: Tpm2bPublic<'a>,
    pub outside_info: Tpm2bData<'a>,
    pub creation_pcr: TpmlPcrSelection<'a>,
}

impl<'a> Tpm2CreatePrimaryCommandParams<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2_createprimary_command_params_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let in_sensitive_size = match self.in_sensitive.marshalled_size() {
            Ok(in_sensitive_size) => in_sensitive_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(in_sensitive_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let in_public_size = match self.in_public.marshalled_size() {
            Ok(in_public_size) => in_public_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(in_public_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let outside_info_size = match self.outside_info.marshalled_size() {
            Ok(outside_info_size) => outside_info_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(outside_info_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let creation_pcr_size = match self.creation_pcr.marshalled_size() {
            Ok(creation_pcr_size) => creation_pcr_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(creation_pcr_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.in_sensitive.marshal(buf)?;

        let buf = self.in_public.marshal(buf)?;

        let buf = self.outside_info.marshal(buf)?;

        let buf = self.creation_pcr.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_in_sensitive) = match Tpm2bSensitiveCreate::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        let (buf, unmarshalled_in_public) = match Tpm2bPublic::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_outside_info) = match Tpm2bData::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_creation_pcr) = match TpmlPcrSelection::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{in_sensitive: unmarshalled_in_sensitive, in_public: unmarshalled_in_public, outside_info: unmarshalled_outside_info, creation_pcr: unmarshalled_creation_pcr}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2CreatePrimaryCommandParams<'static>, TpmErr> {
        Ok(Tpm2CreatePrimaryCommandParams {
            in_sensitive: self.in_sensitive.try_clone_intern()?,
            in_public: self.in_public.try_clone_intern()?,
            outside_info: self.outside_info.try_clone_intern()?,
            creation_pcr: self.creation_pcr.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2CreatePrimaryCommandParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2CreatePrimaryCommandParams<'static>, TpmErr> {
        let Self {
            in_sensitive,
            in_public,
            outside_info,
            creation_pcr,
        } = self;

        let in_sensitive = in_sensitive.into_bufs_owner_intern()?;
        let in_public = in_public.into_bufs_owner_intern()?;
        let outside_info = outside_info.into_bufs_owner_intern()?;
        let creation_pcr = creation_pcr.into_bufs_owner_intern()?;

        Ok(Tpm2CreatePrimaryCommandParams {
            in_sensitive,
            in_public,
            outside_info,
            creation_pcr,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2CreatePrimaryCommandParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpm2_createprimary_command_params_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    size += tpm2b_data_marshalled_max_size() as u32;

    let in_sensitive_size = match tpm2b_sensitive_create_marshalled_max_size(limits) {
        Ok(in_sensitive_size) => in_sensitive_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(in_sensitive_size).ok_or(())?;

    let in_public_size = match tpm2b_public_marshalled_max_size(limits) {
        Ok(in_public_size) => in_public_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(in_public_size).ok_or(())?;

    let creation_pcr_size = match tpml_pcr_selection_marshalled_max_size(limits) {
        Ok(creation_pcr_size) => creation_pcr_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(creation_pcr_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 252, table 175, TPM2_CreatePrimary_RESPONSE_HANDLES structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2CreatePrimaryResponseHandles {
    pub object_handle: u32,
}

impl Tpm2CreatePrimaryResponseHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_createprimary_response_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = marshal_u32(buf, self.object_handle)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_object_handle) = match unmarshal_u32(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{object_handle: unmarshalled_object_handle}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_createprimary_response_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += mem::size_of::<u32>() as u16;

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 252, table 175, TPM2_CreatePrimary_RESPONSE_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2CreatePrimaryResponseParams<'a> {
    pub out_public: Tpm2bPublic<'a>,
    pub creation_data: Tpm2bCreationData<'a>,
    pub creation_hash: Tpm2bDigest<'a>,
    pub creation_ticket: TpmtTkCreation<'a>,
    pub name: Tpm2bName<'a>,
}

impl<'a> Tpm2CreatePrimaryResponseParams<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2_createprimary_response_params_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let out_public_size = match self.out_public.marshalled_size() {
            Ok(out_public_size) => out_public_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(out_public_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let creation_data_size = match self.creation_data.marshalled_size() {
            Ok(creation_data_size) => creation_data_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(creation_data_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let creation_hash_size = match self.creation_hash.marshalled_size() {
            Ok(creation_hash_size) => creation_hash_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(creation_hash_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let creation_ticket_size = match self.creation_ticket.marshalled_size() {
            Ok(creation_ticket_size) => creation_ticket_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(creation_ticket_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let name_size = match self.name.marshalled_size() {
            Ok(name_size) => name_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(name_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.out_public.marshal(buf)?;

        let buf = self.creation_data.marshal(buf)?;

        let buf = self.creation_hash.marshal(buf)?;

        let buf = self.creation_ticket.marshal(buf)?;

        let buf = self.name.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_out_public) = match Tpm2bPublic::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        let (buf, unmarshalled_creation_data) = match Tpm2bCreationData::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_creation_hash) = match Tpm2bDigest::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_creation_ticket) = match TpmtTkCreation::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_name) = match Tpm2bName::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{out_public: unmarshalled_out_public, creation_data: unmarshalled_creation_data, creation_hash: unmarshalled_creation_hash, creation_ticket: unmarshalled_creation_ticket, name: unmarshalled_name}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2CreatePrimaryResponseParams<'static>, TpmErr> {
        Ok(Tpm2CreatePrimaryResponseParams {
            out_public: self.out_public.try_clone_intern()?,
            creation_data: self.creation_data.try_clone_intern()?,
            creation_hash: self.creation_hash.try_clone_intern()?,
            creation_ticket: self.creation_ticket.try_clone_intern()?,
            name: self.name.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2CreatePrimaryResponseParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2CreatePrimaryResponseParams<'static>, TpmErr> {
        let Self {
            out_public,
            creation_data,
            creation_hash,
            creation_ticket,
            name,
        } = self;

        let out_public = out_public.into_bufs_owner_intern()?;
        let creation_data = creation_data.into_bufs_owner_intern()?;
        let creation_hash = creation_hash.into_bufs_owner_intern()?;
        let creation_ticket = creation_ticket.into_bufs_owner_intern()?;
        let name = name.into_bufs_owner_intern()?;

        Ok(Tpm2CreatePrimaryResponseParams {
            out_public,
            creation_data,
            creation_hash,
            creation_ticket,
            name,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2CreatePrimaryResponseParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpm2_createprimary_response_params_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    size += tpm2b_digest_marshalled_max_size() as u32;
    size += tpmt_tk_creation_marshalled_max_size() as u32;
    size += tpm2b_name_marshalled_max_size() as u32;

    let out_public_size = match tpm2b_public_marshalled_max_size(limits) {
        Ok(out_public_size) => out_public_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(out_public_size).ok_or(())?;

    let creation_data_size = match tpm2b_creation_data_marshalled_max_size(limits) {
        Ok(creation_data_size) => creation_data_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(creation_data_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 255, table 176, TPM2_HierarchyControl_COMMAND_HANDLES structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2HierarchyControlCommandHandles {
    pub auth_handle: TpmiRhBaseHierarchy,
}

impl Tpm2HierarchyControlCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_hierarchycontrol_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.auth_handle.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_auth_handle) = match TpmiRhBaseHierarchy::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{auth_handle: unmarshalled_auth_handle}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_hierarchycontrol_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiRhBaseHierarchy::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 255, table 176, TPM2_HierarchyControl_COMMAND_PARAMS structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2HierarchyControlCommandParams {
    pub enable: TpmiRhEnables,
    pub state: TpmiYesNo,
}

impl Tpm2HierarchyControlCommandParams {
    pub const fn marshalled_size() -> u16 {
        tpm2_hierarchycontrol_command_params_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.enable.marshal(buf)?;

        let buf = self.state.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_enable) = match TpmiRhEnables::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_state) = match TpmiYesNo::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{enable: unmarshalled_enable, state: unmarshalled_state}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_hierarchycontrol_command_params_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiRhEnables::marshalled_size();
    size += TpmiYesNo::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 257, table 178, TPM2_SetPrimaryPolicy_COMMAND_HANDLES structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2SetPrimaryPolicyCommandHandles {
    pub auth_handle: TpmiRhHierarchyPolicy,
}

impl Tpm2SetPrimaryPolicyCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_setprimarypolicy_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.auth_handle.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_auth_handle) = match TpmiRhHierarchyPolicy::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{auth_handle: unmarshalled_auth_handle}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_setprimarypolicy_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiRhHierarchyPolicy::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 257, table 178, TPM2_SetPrimaryPolicy_COMMAND_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2SetPrimaryPolicyCommandParams<'a> {
    pub auth_policy: Tpm2bDigest<'a>,
    pub hash_alg: TpmiAlgHashWCV,
}

impl<'a> Tpm2SetPrimaryPolicyCommandParams<'a> {
    pub const fn marshalled_max_size() -> u16 {
        tpm2_setprimarypolicy_command_params_marshalled_max_size()
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let hash_alg_size = match usize::try_from(TpmiAlgHashWCV::marshalled_size()) {
            Ok(hash_alg_size) => hash_alg_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(hash_alg_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let auth_policy_size = match self.auth_policy.marshalled_size() {
            Ok(auth_policy_size) => auth_policy_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(auth_policy_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.auth_policy.marshal(buf)?;

        let buf = self.hash_alg.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_auth_policy) = match Tpm2bDigest::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        let (buf, unmarshalled_hash_alg) = match TpmiAlgHashWCV::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{auth_policy: unmarshalled_auth_policy, hash_alg: unmarshalled_hash_alg}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2SetPrimaryPolicyCommandParams<'static>, TpmErr> {
        Ok(Tpm2SetPrimaryPolicyCommandParams {
            auth_policy: self.auth_policy.try_clone_intern()?,
            hash_alg: self.hash_alg,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2SetPrimaryPolicyCommandParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2SetPrimaryPolicyCommandParams<'static>, TpmErr> {
        let Self {
            auth_policy,
            hash_alg,
        } = self;

        let auth_policy = auth_policy.into_bufs_owner_intern()?;

        Ok(Tpm2SetPrimaryPolicyCommandParams {
            auth_policy,
            hash_alg,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2SetPrimaryPolicyCommandParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

const fn tpm2_setprimarypolicy_command_params_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += tpm2b_digest_marshalled_max_size();
    size += TpmiAlgHashWCV::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 259, table 180, TPM2_ChangePPS_COMMAND_HANDLES structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2ChangePPSCommandHandles {
    pub auth_handle: TpmiRhPlatform,
}

impl Tpm2ChangePPSCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_changepps_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.auth_handle.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_auth_handle) = match TpmiRhPlatform::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{auth_handle: unmarshalled_auth_handle}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_changepps_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiRhPlatform::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 261, table 182, TPM2_ChangeEPS_COMMAND_HANDLES structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2ChangeEPSCommandHandles {
    pub auth_handle: TpmiRhPlatform,
}

impl Tpm2ChangeEPSCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_changeeps_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.auth_handle.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_auth_handle) = match TpmiRhPlatform::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{auth_handle: unmarshalled_auth_handle}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_changeeps_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiRhPlatform::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 263, table 184, TPM2_Clear_COMMAND_HANDLES structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2ClearCommandHandles {
    pub auth_handle: TpmiRhClear,
}

impl Tpm2ClearCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_clear_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.auth_handle.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_auth_handle) = match TpmiRhClear::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{auth_handle: unmarshalled_auth_handle}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_clear_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiRhClear::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 265, table 186, TPM2_ClearControl_COMMAND_HANDLES structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2ClearControlCommandHandles {
    pub auth: TpmiRhClear,
}

impl Tpm2ClearControlCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_clearcontrol_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.auth.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_auth) = match TpmiRhClear::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{auth: unmarshalled_auth}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_clearcontrol_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiRhClear::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 265, table 186, TPM2_ClearControl_COMMAND_PARAMS structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2ClearControlCommandParams {
    pub disable: TpmiYesNo,
}

impl Tpm2ClearControlCommandParams {
    pub const fn marshalled_size() -> u16 {
        tpm2_clearcontrol_command_params_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.disable.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_disable) = match TpmiYesNo::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{disable: unmarshalled_disable}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_clearcontrol_command_params_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiYesNo::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 267, table 188, TPM2_HierarchyChangeAuth_COMMAND_HANDLES structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2HierarchyChangeAuthCommandHandles {
    pub auth_handle: TpmiRhHierarchyAuth,
}

impl Tpm2HierarchyChangeAuthCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_hierarchychangeauth_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.auth_handle.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_auth_handle) = match TpmiRhHierarchyAuth::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{auth_handle: unmarshalled_auth_handle}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_hierarchychangeauth_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiRhHierarchyAuth::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 267, table 188, TPM2_HierarchyChangeAuth_COMMAND_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2HierarchyChangeAuthCommandParams<'a> {
    pub new_auth: Tpm2bDigest<'a>,
}

impl<'a> Tpm2HierarchyChangeAuthCommandParams<'a> {
    pub const fn marshalled_max_size() -> u16 {
        tpm2_hierarchychangeauth_command_params_marshalled_max_size()
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let new_auth_size = match self.new_auth.marshalled_size() {
            Ok(new_auth_size) => new_auth_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(new_auth_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.new_auth.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_new_auth) = match Tpm2bDigest::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        Ok((buf, Self{new_auth: unmarshalled_new_auth}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2HierarchyChangeAuthCommandParams<'static>, TpmErr> {
        Ok(Tpm2HierarchyChangeAuthCommandParams {
            new_auth: self.new_auth.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2HierarchyChangeAuthCommandParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2HierarchyChangeAuthCommandParams<'static>, TpmErr> {
        let Self {
            new_auth,
        } = self;

        let new_auth = new_auth.into_bufs_owner_intern()?;

        Ok(Tpm2HierarchyChangeAuthCommandParams {
            new_auth,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2HierarchyChangeAuthCommandParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

const fn tpm2_hierarchychangeauth_command_params_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += tpm2b_digest_marshalled_max_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 273, table 191, TPM2_ReadOnlyControl_COMMAND_HANDLES structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2ReadOnlyControlCommandHandles {
    pub auth_handle: TpmiRhPlatform,
}

impl Tpm2ReadOnlyControlCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_readonlycontrol_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.auth_handle.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_auth_handle) = match TpmiRhPlatform::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{auth_handle: unmarshalled_auth_handle}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_readonlycontrol_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiRhPlatform::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 273, table 191, TPM2_ReadOnlyControl_COMMAND_PARAMS structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2ReadOnlyControlCommandParams {
    pub state: TpmiYesNo,
}

impl Tpm2ReadOnlyControlCommandParams {
    pub const fn marshalled_size() -> u16 {
        tpm2_readonlycontrol_command_params_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.state.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_state) = match TpmiYesNo::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{state: unmarshalled_state}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_readonlycontrol_command_params_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiYesNo::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 276, table 193, TPM2_DictionaryAttackLockReset_COMMAND_HANDLES structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2DictionaryAttackLockResetCommandHandles {
    pub lock_handle: TpmiRhLockout,
}

impl Tpm2DictionaryAttackLockResetCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_dictionaryattacklockreset_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.lock_handle.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_lock_handle) = match TpmiRhLockout::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{lock_handle: unmarshalled_lock_handle}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_dictionaryattacklockreset_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiRhLockout::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 278, table 195, TPM2_DictionaryAttackParameters_COMMAND_HANDLES structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2DictionaryAttackParametersCommandHandles {
    pub lock_handle: TpmiRhLockout,
}

impl Tpm2DictionaryAttackParametersCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_dictionaryattackparameters_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.lock_handle.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_lock_handle) = match TpmiRhLockout::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{lock_handle: unmarshalled_lock_handle}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_dictionaryattackparameters_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiRhLockout::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 278, table 195, TPM2_DictionaryAttackParameters_COMMAND_PARAMS structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2DictionaryAttackParametersCommandParams {
    pub new_max_tries: u32,
    pub new_recovery_time: u32,
    pub lockout_recovery: u32,
}

impl Tpm2DictionaryAttackParametersCommandParams {
    pub const fn marshalled_size() -> u16 {
        tpm2_dictionaryattackparameters_command_params_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = marshal_u32(buf, self.new_max_tries)?;

        let buf = marshal_u32(buf, self.new_recovery_time)?;

        let buf = marshal_u32(buf, self.lockout_recovery)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_new_max_tries) = match unmarshal_u32(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_new_recovery_time) = match unmarshal_u32(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_lockout_recovery) = match unmarshal_u32(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{new_max_tries: unmarshalled_new_max_tries, new_recovery_time: unmarshalled_new_recovery_time, lockout_recovery: unmarshalled_lockout_recovery}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_dictionaryattackparameters_command_params_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += mem::size_of::<u32>() as u16;
    size += mem::size_of::<u32>() as u16;
    size += mem::size_of::<u32>() as u16;

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 281, table 197, TPM2_PP_Commands_COMMAND_HANDLES structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2PpCommandsCommandHandles {
    pub auth: TpmiRhPlatform,
}

impl Tpm2PpCommandsCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_pp_commands_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.auth.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_auth) = match TpmiRhPlatform::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{auth: unmarshalled_auth}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_pp_commands_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiRhPlatform::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 281, table 197, TPM2_PP_Commands_COMMAND_PARAMS structure
#[derive(Debug, PartialEq, Eq)]
pub struct Tpm2PpCommandsCommandParams {
    pub set_list: TpmlCc,
    pub clear_list: TpmlCc,
}

impl Tpm2PpCommandsCommandParams {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2_pp_commands_command_params_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let set_list_size = match self.set_list.marshalled_size() {
            Ok(set_list_size) => set_list_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(set_list_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let clear_list_size = match self.clear_list.marshalled_size() {
            Ok(clear_list_size) => clear_list_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(clear_list_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.set_list.marshal(buf)?;

        let buf = self.clear_list.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_set_list) = match TpmlCc::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_clear_list) = match TpmlCc::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{set_list: unmarshalled_set_list, clear_list: unmarshalled_clear_list}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2PpCommandsCommandParams, TpmErr> {
        Ok(Tpm2PpCommandsCommandParams {
            set_list: self.set_list.try_clone_intern()?,
            clear_list: self.clear_list.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2PpCommandsCommandParams>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpm2_pp_commands_command_params_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    let set_list_size = match tpml_cc_marshalled_max_size(limits) {
        Ok(set_list_size) => set_list_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(set_list_size).ok_or(())?;

    let clear_list_size = match tpml_cc_marshalled_max_size(limits) {
        Ok(clear_list_size) => clear_list_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(clear_list_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 283, table 199, TPM2_SetAlgorithmSet_COMMAND_HANDLES structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2SetAlgorithmSetCommandHandles {
    pub auth_handle: TpmiRhPlatform,
}

impl Tpm2SetAlgorithmSetCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_setalgorithmset_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.auth_handle.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_auth_handle) = match TpmiRhPlatform::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{auth_handle: unmarshalled_auth_handle}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_setalgorithmset_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiRhPlatform::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 283, table 199, TPM2_SetAlgorithmSet_COMMAND_PARAMS structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2SetAlgorithmSetCommandParams {
    pub algorithm_set: u32,
}

impl Tpm2SetAlgorithmSetCommandParams {
    pub const fn marshalled_size() -> u16 {
        tpm2_setalgorithmset_command_params_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = marshal_u32(buf, self.algorithm_set)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_algorithm_set) = match unmarshal_u32(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{algorithm_set: unmarshalled_algorithm_set}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_setalgorithmset_command_params_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += mem::size_of::<u32>() as u16;

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 287, table 201, TPM2_FieldUpgradeStart_COMMAND_HANDLES structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2FieldUpgradeStartCommandHandles {
    pub authorization: TpmiRhPlatform,
    pub key_handle: TpmiDhObject,
}

impl Tpm2FieldUpgradeStartCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_fieldupgradestart_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.authorization.marshal(buf)?;

        let buf = self.key_handle.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_authorization) = match TpmiRhPlatform::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_key_handle) = match TpmiDhObject::unmarshal(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{authorization: unmarshalled_authorization, key_handle: unmarshalled_key_handle}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_fieldupgradestart_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiRhPlatform::marshalled_size();
    size += TpmiDhObject::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 287, table 201, TPM2_FieldUpgradeStart_COMMAND_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2FieldUpgradeStartCommandParams<'a> {
    pub fu_digest: Tpm2bDigest<'a>,
    pub manifest_signature: TpmtSignature<'a>,
}

impl<'a> Tpm2FieldUpgradeStartCommandParams<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2_fieldupgradestart_command_params_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let fu_digest_size = match self.fu_digest.marshalled_size() {
            Ok(fu_digest_size) => fu_digest_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(fu_digest_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let manifest_signature_size = match self.manifest_signature.marshalled_size() {
            Ok(manifest_signature_size) => manifest_signature_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(manifest_signature_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.fu_digest.marshal(buf)?;

        let buf = self.manifest_signature.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_fu_digest) = match Tpm2bDigest::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        let (buf, unmarshalled_manifest_signature) = match TpmtSignature::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{fu_digest: unmarshalled_fu_digest, manifest_signature: unmarshalled_manifest_signature}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2FieldUpgradeStartCommandParams<'static>, TpmErr> {
        Ok(Tpm2FieldUpgradeStartCommandParams {
            fu_digest: self.fu_digest.try_clone_intern()?,
            manifest_signature: self.manifest_signature.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2FieldUpgradeStartCommandParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2FieldUpgradeStartCommandParams<'static>, TpmErr> {
        let Self {
            fu_digest,
            manifest_signature,
        } = self;

        let fu_digest = fu_digest.into_bufs_owner_intern()?;
        let manifest_signature = manifest_signature.into_bufs_owner_intern()?;

        Ok(Tpm2FieldUpgradeStartCommandParams {
            fu_digest,
            manifest_signature,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2FieldUpgradeStartCommandParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpm2_fieldupgradestart_command_params_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    size += tpm2b_digest_marshalled_max_size() as u32;

    let manifest_signature_size = match tpmt_signature_marshalled_max_size(limits) {
        Ok(manifest_signature_size) => manifest_signature_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(manifest_signature_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 289, table 203, TPM2_FieldUpgradeData_COMMAND_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2FieldUpgradeDataCommandParams<'a> {
    pub fu_data: Tpm2bMaxBuffer<'a>,
}

impl<'a> Tpm2FieldUpgradeDataCommandParams<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2_fieldupgradedata_command_params_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let fu_data_size = match self.fu_data.marshalled_size() {
            Ok(fu_data_size) => fu_data_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(fu_data_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.fu_data.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_fu_data) = match Tpm2bMaxBuffer::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        Ok((buf, Self{fu_data: unmarshalled_fu_data}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2FieldUpgradeDataCommandParams<'static>, TpmErr> {
        Ok(Tpm2FieldUpgradeDataCommandParams {
            fu_data: self.fu_data.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2FieldUpgradeDataCommandParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2FieldUpgradeDataCommandParams<'static>, TpmErr> {
        let Self {
            fu_data,
        } = self;

        let fu_data = fu_data.into_bufs_owner_intern()?;

        Ok(Tpm2FieldUpgradeDataCommandParams {
            fu_data,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2FieldUpgradeDataCommandParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpm2_fieldupgradedata_command_params_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    let fu_data_size = match tpm2b_max_buffer_marshalled_max_size(limits) {
        Ok(fu_data_size) => fu_data_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(fu_data_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 289, table 204, TPM2_FieldUpgradeData_RESPONSE_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2FieldUpgradeDataResponseParams<'a> {
    pub next_digest: TpmtHaWCV<'a>,
    pub first_digest: TpmtHa<'a>,
}

impl<'a> Tpm2FieldUpgradeDataResponseParams<'a> {
    pub const fn marshalled_max_size() -> u16 {
        tpm2_fieldupgradedata_response_params_marshalled_max_size()
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let next_digest_size = match self.next_digest.marshalled_size() {
            Ok(next_digest_size) => next_digest_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(next_digest_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let first_digest_size = match self.first_digest.marshalled_size() {
            Ok(first_digest_size) => first_digest_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(first_digest_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.next_digest.marshal(buf)?;

        let buf = self.first_digest.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_next_digest) = match TpmtHaWCV::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_first_digest) = match TpmtHa::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{next_digest: unmarshalled_next_digest, first_digest: unmarshalled_first_digest}))
    }

    pub fn unmarshal(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2FieldUpgradeDataResponseParams<'static>, TpmErr> {
        Ok(Tpm2FieldUpgradeDataResponseParams {
            next_digest: self.next_digest.try_clone_intern()?,
            first_digest: self.first_digest.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2FieldUpgradeDataResponseParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2FieldUpgradeDataResponseParams<'static>, TpmErr> {
        let Self {
            next_digest,
            first_digest,
        } = self;

        let next_digest = next_digest.into_bufs_owner_intern()?;
        let first_digest = first_digest.into_bufs_owner_intern()?;

        Ok(Tpm2FieldUpgradeDataResponseParams {
            next_digest,
            first_digest,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2FieldUpgradeDataResponseParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

const fn tpm2_fieldupgradedata_response_params_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += tpmt_ha_wcv_marshalled_max_size();
    size += tpmt_ha_marshalled_max_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 291, table 205, TPM2_FirmwareRead_COMMAND_PARAMS structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2FirmwareReadCommandParams {
    pub sequence_number: u32,
}

impl Tpm2FirmwareReadCommandParams {
    pub const fn marshalled_size() -> u16 {
        tpm2_firmwareread_command_params_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = marshal_u32(buf, self.sequence_number)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_sequence_number) = match unmarshal_u32(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{sequence_number: unmarshalled_sequence_number}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_firmwareread_command_params_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += mem::size_of::<u32>() as u16;

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 291, table 206, TPM2_FirmwareRead_RESPONSE_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2FirmwareReadResponseParams<'a> {
    pub fu_data: Tpm2bMaxBuffer<'a>,
}

impl<'a> Tpm2FirmwareReadResponseParams<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2_firmwareread_response_params_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let fu_data_size = match self.fu_data.marshalled_size() {
            Ok(fu_data_size) => fu_data_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(fu_data_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.fu_data.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_fu_data) = match Tpm2bMaxBuffer::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        Ok((buf, Self{fu_data: unmarshalled_fu_data}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2FirmwareReadResponseParams<'static>, TpmErr> {
        Ok(Tpm2FirmwareReadResponseParams {
            fu_data: self.fu_data.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2FirmwareReadResponseParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2FirmwareReadResponseParams<'static>, TpmErr> {
        let Self {
            fu_data,
        } = self;

        let fu_data = fu_data.into_bufs_owner_intern()?;

        Ok(Tpm2FirmwareReadResponseParams {
            fu_data,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2FirmwareReadResponseParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpm2_firmwareread_response_params_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    let fu_data_size = match tpm2b_max_buffer_marshalled_max_size(limits) {
        Ok(fu_data_size) => fu_data_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(fu_data_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 294, table 207, TPM2_ContextSave_COMMAND_HANDLES structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2ContextSaveCommandHandles {
    pub save_handle: TpmiDhContext,
}

impl Tpm2ContextSaveCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_contextsave_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.save_handle.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_save_handle) = match TpmiDhContext::unmarshal(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{save_handle: unmarshalled_save_handle}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_contextsave_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiDhContext::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 294, table 208, TPM2_ContextSave_RESPONSE_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2ContextSaveResponseParams<'a> {
    pub context: TpmsContext<'a>,
}

impl<'a> Tpm2ContextSaveResponseParams<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2_contextsave_response_params_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let context_size = match self.context.marshalled_size() {
            Ok(context_size) => context_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(context_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.context.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_context) = match TpmsContext::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{context: unmarshalled_context}))
    }

    pub fn unmarshal(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2ContextSaveResponseParams<'static>, TpmErr> {
        Ok(Tpm2ContextSaveResponseParams {
            context: self.context.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2ContextSaveResponseParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2ContextSaveResponseParams<'static>, TpmErr> {
        let Self {
            context,
        } = self;

        let context = context.into_bufs_owner_intern()?;

        Ok(Tpm2ContextSaveResponseParams {
            context,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2ContextSaveResponseParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpm2_contextsave_response_params_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    let context_size = match tpms_context_marshalled_max_size(limits) {
        Ok(context_size) => context_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(context_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 296, table 209, TPM2_ContextLoad_COMMAND_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2ContextLoadCommandParams<'a> {
    pub context: TpmsContext<'a>,
}

impl<'a> Tpm2ContextLoadCommandParams<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2_contextload_command_params_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let context_size = match self.context.marshalled_size() {
            Ok(context_size) => context_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(context_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.context.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_context) = match TpmsContext::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{context: unmarshalled_context}))
    }

    pub fn unmarshal(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2ContextLoadCommandParams<'static>, TpmErr> {
        Ok(Tpm2ContextLoadCommandParams {
            context: self.context.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2ContextLoadCommandParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2ContextLoadCommandParams<'static>, TpmErr> {
        let Self {
            context,
        } = self;

        let context = context.into_bufs_owner_intern()?;

        Ok(Tpm2ContextLoadCommandParams {
            context,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2ContextLoadCommandParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpm2_contextload_command_params_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    let context_size = match tpms_context_marshalled_max_size(limits) {
        Ok(context_size) => context_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(context_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 296, table 210, TPM2_ContextLoad_RESPONSE_HANDLES structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2ContextLoadResponseHandles {
    pub loaded_handle: TpmiDhContext,
}

impl Tpm2ContextLoadResponseHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_contextload_response_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.loaded_handle.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_loaded_handle) = match TpmiDhContext::unmarshal(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{loaded_handle: unmarshalled_loaded_handle}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_contextload_response_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiDhContext::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 298, table 211, TPM2_FlushContext_COMMAND_PARAMS structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2FlushContextCommandParams {
    pub flush_handle: TpmiDhContext,
}

impl Tpm2FlushContextCommandParams {
    pub const fn marshalled_size() -> u16 {
        tpm2_flushcontext_command_params_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.flush_handle.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_flush_handle) = match TpmiDhContext::unmarshal(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{flush_handle: unmarshalled_flush_handle}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_flushcontext_command_params_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiDhContext::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 301, table 213, TPM2_EvictControl_COMMAND_HANDLES structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2EvictControlCommandHandles {
    pub auth: TpmiRhProvision,
    pub object_handle: TpmiDhObject,
}

impl Tpm2EvictControlCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_evictcontrol_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.auth.marshal(buf)?;

        let buf = self.object_handle.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_auth) = match TpmiRhProvision::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_object_handle) = match TpmiDhObject::unmarshal(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{auth: unmarshalled_auth, object_handle: unmarshalled_object_handle}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_evictcontrol_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiRhProvision::marshalled_size();
    size += TpmiDhObject::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 301, table 213, TPM2_EvictControl_COMMAND_PARAMS structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2EvictControlCommandParams {
    pub persistent_handle: TpmiDhPersistent,
}

impl Tpm2EvictControlCommandParams {
    pub const fn marshalled_size() -> u16 {
        tpm2_evictcontrol_command_params_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.persistent_handle.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_persistent_handle) = match TpmiDhPersistent::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{persistent_handle: unmarshalled_persistent_handle}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_evictcontrol_command_params_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiDhPersistent::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 303, table 216, TPM2_ReadClock_RESPONSE_PARAMS structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2ReadClockResponseParams {
    pub current_time: TpmsTimeInfo,
}

impl Tpm2ReadClockResponseParams {
    pub const fn marshalled_size() -> u16 {
        tpm2_readclock_response_params_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.current_time.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_current_time) = match TpmsTimeInfo::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{current_time: unmarshalled_current_time}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_readclock_response_params_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += tpms_time_info_marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 305, table 217, TPM2_ClockSet_COMMAND_HANDLES structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2ClockSetCommandHandles {
    pub auth: TpmiRhProvision,
}

impl Tpm2ClockSetCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_clockset_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.auth.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_auth) = match TpmiRhProvision::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{auth: unmarshalled_auth}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_clockset_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiRhProvision::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 305, table 217, TPM2_ClockSet_COMMAND_PARAMS structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2ClockSetCommandParams {
    pub new_time: u64,
}

impl Tpm2ClockSetCommandParams {
    pub const fn marshalled_size() -> u16 {
        tpm2_clockset_command_params_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = marshal_u64(buf, self.new_time)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_new_time) = match unmarshal_u64(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{new_time: unmarshalled_new_time}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_clockset_command_params_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += mem::size_of::<u64>() as u16;

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 307, table 219, TPM2_ClockRateAdjust_COMMAND_HANDLES structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2ClockRateAdjustCommandHandles {
    pub auth: TpmiRhProvision,
}

impl Tpm2ClockRateAdjustCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_clockrateadjust_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.auth.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_auth) = match TpmiRhProvision::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{auth: unmarshalled_auth}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_clockrateadjust_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiRhProvision::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 307, table 219, TPM2_ClockRateAdjust_COMMAND_PARAMS structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2ClockRateAdjustCommandParams {
    pub rate_adjust: TpmClockAdjust,
}

impl Tpm2ClockRateAdjustCommandParams {
    pub const fn marshalled_size() -> u16 {
        tpm2_clockrateadjust_command_params_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.rate_adjust.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_rate_adjust) = match TpmClockAdjust::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{rate_adjust: unmarshalled_rate_adjust}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_clockrateadjust_command_params_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmClockAdjust::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 313, table 221, TPM2_GetCapability_COMMAND_PARAMS structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2GetCapabilityCommandParams {
    pub capability: TpmCap,
    pub property: u32,
    pub property_count: u32,
}

impl Tpm2GetCapabilityCommandParams {
    pub const fn marshalled_size() -> u16 {
        tpm2_getcapability_command_params_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.capability.marshal(buf)?;

        let buf = marshal_u32(buf, self.property)?;

        let buf = marshal_u32(buf, self.property_count)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_capability) = match TpmCap::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_property) = match unmarshal_u32(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_property_count) = match unmarshal_u32(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{capability: unmarshalled_capability, property: unmarshalled_property, property_count: unmarshalled_property_count}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_getcapability_command_params_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmCap::marshalled_size();
    size += mem::size_of::<u32>() as u16;
    size += mem::size_of::<u32>() as u16;

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 313, table 222, TPM2_GetCapability_RESPONSE_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2GetCapabilityResponseParams<'a> {
    pub more_data: TpmiYesNo,
    pub capability_data: TpmsCapabilityData<'a>,
}

impl<'a> Tpm2GetCapabilityResponseParams<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2_getcapability_response_params_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let more_data_size = match usize::try_from(TpmiYesNo::marshalled_size()) {
            Ok(more_data_size) => more_data_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(more_data_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let capability_data_size = match self.capability_data.marshalled_size() {
            Ok(capability_data_size) => capability_data_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(capability_data_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.more_data.marshal(buf)?;

        let buf = self.capability_data.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_more_data) = match TpmiYesNo::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_capability_data) = match TpmsCapabilityData::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{more_data: unmarshalled_more_data, capability_data: unmarshalled_capability_data}))
    }

    pub fn unmarshal(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2GetCapabilityResponseParams<'static>, TpmErr> {
        Ok(Tpm2GetCapabilityResponseParams {
            more_data: self.more_data,
            capability_data: self.capability_data.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2GetCapabilityResponseParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2GetCapabilityResponseParams<'static>, TpmErr> {
        let Self {
            more_data,
            capability_data,
        } = self;

        let capability_data = capability_data.into_bufs_owner_intern()?;

        Ok(Tpm2GetCapabilityResponseParams {
            more_data,
            capability_data,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2GetCapabilityResponseParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpm2_getcapability_response_params_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    size += TpmiYesNo::marshalled_size() as u32;

    let capability_data_size = match tpms_capability_data_marshalled_max_size(limits) {
        Ok(capability_data_size) => capability_data_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(capability_data_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 315, table 223, TPM2_TestParms_COMMAND_PARAMS structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2TestParmsCommandParams {
    pub parameters: TpmtPublicParms,
}

impl Tpm2TestParmsCommandParams {
    pub const fn marshalled_max_size() -> u16 {
        tpm2_testparms_command_params_marshalled_max_size()
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let parameters_size = match self.parameters.marshalled_size() {
            Ok(parameters_size) => parameters_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(parameters_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.parameters.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_parameters) = match TpmtPublicParms::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{parameters: unmarshalled_parameters}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_testparms_command_params_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += tpmt_public_parms_marshalled_max_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 317, table 225, TPM2_SetCapability_COMMAND_HANDLES structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2SetCapabilityCommandHandles {
    pub auth_handle: TpmiRhHierarchyAuthWCV,
}

impl Tpm2SetCapabilityCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_setcapability_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.auth_handle.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_auth_handle) = match TpmiRhHierarchyAuthWCV::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{auth_handle: unmarshalled_auth_handle}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_setcapability_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiRhHierarchyAuthWCV::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 317, table 225, TPM2_SetCapability_COMMAND_PARAMS structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2SetCapabilityCommandParams {
    pub set_capability_data: Tpm2bSetCapabilityData,
}

impl Tpm2SetCapabilityCommandParams {
    pub const fn marshalled_max_size() -> u16 {
        tpm2_setcapability_command_params_marshalled_max_size()
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let set_capability_data_size = match self.set_capability_data.marshalled_size() {
            Ok(set_capability_data_size) => set_capability_data_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(set_capability_data_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.set_capability_data.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_set_capability_data) = match Tpm2bSetCapabilityData::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        Ok((buf, Self{set_capability_data: unmarshalled_set_capability_data}))
    }

    pub fn unmarshal<'a>(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_setcapability_command_params_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += tpm2b_set_capability_data_marshalled_max_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 323, table 228, TPM2_NV_DefineSpace_COMMAND_HANDLES structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2NvDefineSpaceCommandHandles {
    pub auth_handle: TpmiRhProvision,
}

impl Tpm2NvDefineSpaceCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_nv_definespace_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.auth_handle.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_auth_handle) = match TpmiRhProvision::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{auth_handle: unmarshalled_auth_handle}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_nv_definespace_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiRhProvision::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 323, table 228, TPM2_NV_DefineSpace_COMMAND_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2NvDefineSpaceCommandParams<'a> {
    pub auth: Tpm2bDigest<'a>,
    pub public_info: Tpm2bNvPublic<'a>,
}

impl<'a> Tpm2NvDefineSpaceCommandParams<'a> {
    pub const fn marshalled_max_size() -> u16 {
        tpm2_nv_definespace_command_params_marshalled_max_size()
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let auth_size = match self.auth.marshalled_size() {
            Ok(auth_size) => auth_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(auth_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let public_info_size = match self.public_info.marshalled_size() {
            Ok(public_info_size) => public_info_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(public_info_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.auth.marshal(buf)?;

        let buf = self.public_info.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_auth) = match Tpm2bDigest::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        let (buf, unmarshalled_public_info) = match Tpm2bNvPublic::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{auth: unmarshalled_auth, public_info: unmarshalled_public_info}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2NvDefineSpaceCommandParams<'static>, TpmErr> {
        Ok(Tpm2NvDefineSpaceCommandParams {
            auth: self.auth.try_clone_intern()?,
            public_info: self.public_info.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2NvDefineSpaceCommandParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2NvDefineSpaceCommandParams<'static>, TpmErr> {
        let Self {
            auth,
            public_info,
        } = self;

        let auth = auth.into_bufs_owner_intern()?;
        let public_info = public_info.into_bufs_owner_intern()?;

        Ok(Tpm2NvDefineSpaceCommandParams {
            auth,
            public_info,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2NvDefineSpaceCommandParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

const fn tpm2_nv_definespace_command_params_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += tpm2b_digest_marshalled_max_size();
    size += tpm2b_nv_public_marshalled_max_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 325, table 230, TPM2_NV_UndefineSpace_COMMAND_HANDLES structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2NvUndefineSpaceCommandHandles {
    pub auth_handle: TpmiRhProvision,
    pub nv_index: TpmiRhNvDefinedIndex,
}

impl Tpm2NvUndefineSpaceCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_nv_undefinespace_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.auth_handle.marshal(buf)?;

        let buf = self.nv_index.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_auth_handle) = match TpmiRhProvision::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_nv_index) = match TpmiRhNvDefinedIndex::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{auth_handle: unmarshalled_auth_handle, nv_index: unmarshalled_nv_index}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_nv_undefinespace_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiRhProvision::marshalled_size();
    size += TpmiRhNvDefinedIndex::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 327, table 232, TPM2_NV_UndefineSpaceSpecial_COMMAND_HANDLES structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2NvUndefineSpaceSpecialCommandHandles {
    pub nv_index: TpmiRhNvDefinedIndex,
    pub platform: TpmiRhPlatform,
}

impl Tpm2NvUndefineSpaceSpecialCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_nv_undefinespacespecial_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.nv_index.marshal(buf)?;

        let buf = self.platform.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_nv_index) = match TpmiRhNvDefinedIndex::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_platform) = match TpmiRhPlatform::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{nv_index: unmarshalled_nv_index, platform: unmarshalled_platform}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_nv_undefinespacespecial_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiRhNvDefinedIndex::marshalled_size();
    size += TpmiRhPlatform::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 329, table 234, TPM2_NV_ReadPublic_COMMAND_HANDLES structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2NvReadPublicCommandHandles {
    pub nv_index: TpmiRhNvIndex,
}

impl Tpm2NvReadPublicCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_nv_readpublic_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.nv_index.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_nv_index) = match TpmiRhNvIndex::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{nv_index: unmarshalled_nv_index}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_nv_readpublic_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiRhNvIndex::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 329, table 235, TPM2_NV_ReadPublic_RESPONSE_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2NvReadPublicResponseParams<'a> {
    pub nv_public: Tpm2bNvPublic<'a>,
    pub nv_name: Tpm2bName<'a>,
}

impl<'a> Tpm2NvReadPublicResponseParams<'a> {
    pub const fn marshalled_max_size() -> u16 {
        tpm2_nv_readpublic_response_params_marshalled_max_size()
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let nv_public_size = match self.nv_public.marshalled_size() {
            Ok(nv_public_size) => nv_public_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(nv_public_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let nv_name_size = match self.nv_name.marshalled_size() {
            Ok(nv_name_size) => nv_name_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(nv_name_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.nv_public.marshal(buf)?;

        let buf = self.nv_name.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_nv_public) = match Tpm2bNvPublic::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        let (buf, unmarshalled_nv_name) = match Tpm2bName::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{nv_public: unmarshalled_nv_public, nv_name: unmarshalled_nv_name}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2NvReadPublicResponseParams<'static>, TpmErr> {
        Ok(Tpm2NvReadPublicResponseParams {
            nv_public: self.nv_public.try_clone_intern()?,
            nv_name: self.nv_name.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2NvReadPublicResponseParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2NvReadPublicResponseParams<'static>, TpmErr> {
        let Self {
            nv_public,
            nv_name,
        } = self;

        let nv_public = nv_public.into_bufs_owner_intern()?;
        let nv_name = nv_name.into_bufs_owner_intern()?;

        Ok(Tpm2NvReadPublicResponseParams {
            nv_public,
            nv_name,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2NvReadPublicResponseParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

const fn tpm2_nv_readpublic_response_params_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += tpm2b_nv_public_marshalled_max_size();
    size += tpm2b_name_marshalled_max_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 331, table 236, TPM2_NV_Write_COMMAND_HANDLES structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2NvWriteCommandHandles {
    pub auth_handle: TpmiRhNvAuth,
    pub nv_index: TpmiRhNvIndex,
}

impl Tpm2NvWriteCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_nv_write_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.auth_handle.marshal(buf)?;

        let buf = self.nv_index.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_auth_handle) = match TpmiRhNvAuth::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_nv_index) = match TpmiRhNvIndex::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{auth_handle: unmarshalled_auth_handle, nv_index: unmarshalled_nv_index}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_nv_write_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiRhNvAuth::marshalled_size();
    size += TpmiRhNvIndex::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 331, table 236, TPM2_NV_Write_COMMAND_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2NvWriteCommandParams<'a> {
    pub data: Tpm2bMaxNvBuffer<'a>,
    pub offset: u16,
}

impl<'a> Tpm2NvWriteCommandParams<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2_nv_write_command_params_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let offset_size = mem::size_of::<u16>();
        size = match size.checked_add(offset_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let data_size = match self.data.marshalled_size() {
            Ok(data_size) => data_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(data_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.data.marshal(buf)?;

        let buf = marshal_u16(buf, self.offset)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_data) = match Tpm2bMaxNvBuffer::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        let (buf, unmarshalled_offset) = match unmarshal_u16(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{data: unmarshalled_data, offset: unmarshalled_offset}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2NvWriteCommandParams<'static>, TpmErr> {
        Ok(Tpm2NvWriteCommandParams {
            data: self.data.try_clone_intern()?,
            offset: self.offset,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2NvWriteCommandParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2NvWriteCommandParams<'static>, TpmErr> {
        let Self {
            data,
            offset,
        } = self;

        let data = data.into_bufs_owner_intern()?;

        Ok(Tpm2NvWriteCommandParams {
            data,
            offset,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2NvWriteCommandParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpm2_nv_write_command_params_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    size += mem::size_of::<u16>() as u32;

    let data_size = match tpm2b_max_nv_buffer_marshalled_max_size(limits) {
        Ok(data_size) => data_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(data_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 333, table 238, TPM2_NV_Increment_COMMAND_HANDLES structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2NvIncrementCommandHandles {
    pub auth_handle: TpmiRhNvAuth,
    pub nv_index: TpmiRhNvIndex,
}

impl Tpm2NvIncrementCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_nv_increment_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.auth_handle.marshal(buf)?;

        let buf = self.nv_index.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_auth_handle) = match TpmiRhNvAuth::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_nv_index) = match TpmiRhNvIndex::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{auth_handle: unmarshalled_auth_handle, nv_index: unmarshalled_nv_index}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_nv_increment_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiRhNvAuth::marshalled_size();
    size += TpmiRhNvIndex::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 335, table 240, TPM2_NV_Extend_COMMAND_HANDLES structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2NvExtendCommandHandles {
    pub auth_handle: TpmiRhNvAuth,
    pub nv_index: TpmiRhNvIndex,
}

impl Tpm2NvExtendCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_nv_extend_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.auth_handle.marshal(buf)?;

        let buf = self.nv_index.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_auth_handle) = match TpmiRhNvAuth::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_nv_index) = match TpmiRhNvIndex::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{auth_handle: unmarshalled_auth_handle, nv_index: unmarshalled_nv_index}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_nv_extend_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiRhNvAuth::marshalled_size();
    size += TpmiRhNvIndex::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 335, table 240, TPM2_NV_Extend_COMMAND_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2NvExtendCommandParams<'a> {
    pub data: Tpm2bMaxNvBuffer<'a>,
}

impl<'a> Tpm2NvExtendCommandParams<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2_nv_extend_command_params_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let data_size = match self.data.marshalled_size() {
            Ok(data_size) => data_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(data_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.data.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_data) = match Tpm2bMaxNvBuffer::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        Ok((buf, Self{data: unmarshalled_data}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2NvExtendCommandParams<'static>, TpmErr> {
        Ok(Tpm2NvExtendCommandParams {
            data: self.data.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2NvExtendCommandParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2NvExtendCommandParams<'static>, TpmErr> {
        let Self {
            data,
        } = self;

        let data = data.into_bufs_owner_intern()?;

        Ok(Tpm2NvExtendCommandParams {
            data,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2NvExtendCommandParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpm2_nv_extend_command_params_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    let data_size = match tpm2b_max_nv_buffer_marshalled_max_size(limits) {
        Ok(data_size) => data_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(data_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 337, table 242, TPM2_NV_SetBits_COMMAND_HANDLES structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2NvSetBitsCommandHandles {
    pub auth_handle: TpmiRhNvAuth,
    pub nv_index: TpmiRhNvIndex,
}

impl Tpm2NvSetBitsCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_nv_setbits_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.auth_handle.marshal(buf)?;

        let buf = self.nv_index.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_auth_handle) = match TpmiRhNvAuth::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_nv_index) = match TpmiRhNvIndex::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{auth_handle: unmarshalled_auth_handle, nv_index: unmarshalled_nv_index}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_nv_setbits_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiRhNvAuth::marshalled_size();
    size += TpmiRhNvIndex::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 337, table 242, TPM2_NV_SetBits_COMMAND_PARAMS structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2NvSetBitsCommandParams {
    pub bits: u64,
}

impl Tpm2NvSetBitsCommandParams {
    pub const fn marshalled_size() -> u16 {
        tpm2_nv_setbits_command_params_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = marshal_u64(buf, self.bits)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_bits) = match unmarshal_u64(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{bits: unmarshalled_bits}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_nv_setbits_command_params_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += mem::size_of::<u64>() as u16;

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 339, table 244, TPM2_NV_WriteLock_COMMAND_HANDLES structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2NvWriteLockCommandHandles {
    pub auth_handle: TpmiRhNvAuth,
    pub nv_index: TpmiRhNvIndex,
}

impl Tpm2NvWriteLockCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_nv_writelock_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.auth_handle.marshal(buf)?;

        let buf = self.nv_index.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_auth_handle) = match TpmiRhNvAuth::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_nv_index) = match TpmiRhNvIndex::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{auth_handle: unmarshalled_auth_handle, nv_index: unmarshalled_nv_index}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_nv_writelock_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiRhNvAuth::marshalled_size();
    size += TpmiRhNvIndex::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 341, table 246, TPM2_NV_GlobalWriteLock_COMMAND_HANDLES structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2NvGlobalWriteLockCommandHandles {
    pub auth_handle: TpmiRhProvision,
}

impl Tpm2NvGlobalWriteLockCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_nv_globalwritelock_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.auth_handle.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_auth_handle) = match TpmiRhProvision::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{auth_handle: unmarshalled_auth_handle}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_nv_globalwritelock_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiRhProvision::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 343, table 248, TPM2_NV_Read_COMMAND_HANDLES structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2NvReadCommandHandles {
    pub auth_handle: TpmiRhNvAuth,
    pub nv_index: TpmiRhNvIndex,
}

impl Tpm2NvReadCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_nv_read_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.auth_handle.marshal(buf)?;

        let buf = self.nv_index.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_auth_handle) = match TpmiRhNvAuth::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_nv_index) = match TpmiRhNvIndex::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{auth_handle: unmarshalled_auth_handle, nv_index: unmarshalled_nv_index}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_nv_read_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiRhNvAuth::marshalled_size();
    size += TpmiRhNvIndex::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 343, table 248, TPM2_NV_Read_COMMAND_PARAMS structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2NvReadCommandParams {
    pub size: u16,
    pub offset: u16,
}

impl Tpm2NvReadCommandParams {
    pub const fn marshalled_size() -> u16 {
        tpm2_nv_read_command_params_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = marshal_u16(buf, self.size)?;

        let buf = marshal_u16(buf, self.offset)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_size) = match unmarshal_u16(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_offset) = match unmarshal_u16(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{size: unmarshalled_size, offset: unmarshalled_offset}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_nv_read_command_params_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += mem::size_of::<u16>() as u16;
    size += mem::size_of::<u16>() as u16;

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 343, table 249, TPM2_NV_Read_RESPONSE_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2NvReadResponseParams<'a> {
    pub data: Tpm2bMaxNvBuffer<'a>,
}

impl<'a> Tpm2NvReadResponseParams<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2_nv_read_response_params_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let data_size = match self.data.marshalled_size() {
            Ok(data_size) => data_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(data_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.data.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_data) = match Tpm2bMaxNvBuffer::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        Ok((buf, Self{data: unmarshalled_data}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2NvReadResponseParams<'static>, TpmErr> {
        Ok(Tpm2NvReadResponseParams {
            data: self.data.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2NvReadResponseParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2NvReadResponseParams<'static>, TpmErr> {
        let Self {
            data,
        } = self;

        let data = data.into_bufs_owner_intern()?;

        Ok(Tpm2NvReadResponseParams {
            data,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2NvReadResponseParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpm2_nv_read_response_params_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    let data_size = match tpm2b_max_nv_buffer_marshalled_max_size(limits) {
        Ok(data_size) => data_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(data_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 345, table 250, TPM2_NV_ReadLock_COMMAND_HANDLES structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2NvReadLockCommandHandles {
    pub auth_handle: TpmiRhNvAuth,
    pub nv_index: TpmiRhNvIndex,
}

impl Tpm2NvReadLockCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_nv_readlock_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.auth_handle.marshal(buf)?;

        let buf = self.nv_index.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_auth_handle) = match TpmiRhNvAuth::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_nv_index) = match TpmiRhNvIndex::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{auth_handle: unmarshalled_auth_handle, nv_index: unmarshalled_nv_index}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_nv_readlock_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiRhNvAuth::marshalled_size();
    size += TpmiRhNvIndex::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 347, table 252, TPM2_NV_ChangeAuth_COMMAND_HANDLES structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2NvChangeAuthCommandHandles {
    pub nv_index: TpmiRhNvIndex,
}

impl Tpm2NvChangeAuthCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_nv_changeauth_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.nv_index.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_nv_index) = match TpmiRhNvIndex::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{nv_index: unmarshalled_nv_index}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_nv_changeauth_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiRhNvIndex::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 347, table 252, TPM2_NV_ChangeAuth_COMMAND_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2NvChangeAuthCommandParams<'a> {
    pub new_auth: Tpm2bDigest<'a>,
}

impl<'a> Tpm2NvChangeAuthCommandParams<'a> {
    pub const fn marshalled_max_size() -> u16 {
        tpm2_nv_changeauth_command_params_marshalled_max_size()
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let new_auth_size = match self.new_auth.marshalled_size() {
            Ok(new_auth_size) => new_auth_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(new_auth_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.new_auth.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_new_auth) = match Tpm2bDigest::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        Ok((buf, Self{new_auth: unmarshalled_new_auth}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2NvChangeAuthCommandParams<'static>, TpmErr> {
        Ok(Tpm2NvChangeAuthCommandParams {
            new_auth: self.new_auth.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2NvChangeAuthCommandParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2NvChangeAuthCommandParams<'static>, TpmErr> {
        let Self {
            new_auth,
        } = self;

        let new_auth = new_auth.into_bufs_owner_intern()?;

        Ok(Tpm2NvChangeAuthCommandParams {
            new_auth,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2NvChangeAuthCommandParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

const fn tpm2_nv_changeauth_command_params_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += tpm2b_digest_marshalled_max_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 349, table 254, TPM2_NV_Certify_COMMAND_HANDLES structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2NvCertifyCommandHandles {
    pub sign_handle: TpmiDhObjectWCV,
    pub auth_handle: TpmiRhNvAuth,
    pub nv_index: TpmiRhNvIndex,
}

impl Tpm2NvCertifyCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_nv_certify_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.sign_handle.marshal(buf)?;

        let buf = self.auth_handle.marshal(buf)?;

        let buf = self.nv_index.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_sign_handle) = match TpmiDhObjectWCV::unmarshal(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_auth_handle) = match TpmiRhNvAuth::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_nv_index) = match TpmiRhNvIndex::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{sign_handle: unmarshalled_sign_handle, auth_handle: unmarshalled_auth_handle, nv_index: unmarshalled_nv_index}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_nv_certify_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiDhObjectWCV::marshalled_size();
    size += TpmiRhNvAuth::marshalled_size();
    size += TpmiRhNvIndex::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 349, table 254, TPM2_NV_Certify_COMMAND_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2NvCertifyCommandParams<'a> {
    pub qualifying_data: Tpm2bData<'a>,
    pub in_scheme: TpmtSigSchemeWCV,
    pub size: u16,
    pub offset: u16,
}

impl<'a> Tpm2NvCertifyCommandParams<'a> {
    pub const fn marshalled_max_size() -> u16 {
        tpm2_nv_certify_command_params_marshalled_max_size()
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let size_size = mem::size_of::<u16>();
        size = match size.checked_add(size_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let offset_size = mem::size_of::<u16>();
        size = match size.checked_add(offset_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let qualifying_data_size = match self.qualifying_data.marshalled_size() {
            Ok(qualifying_data_size) => qualifying_data_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(qualifying_data_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let in_scheme_size = match self.in_scheme.marshalled_size() {
            Ok(in_scheme_size) => in_scheme_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(in_scheme_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.qualifying_data.marshal(buf)?;

        let buf = self.in_scheme.marshal(buf)?;

        let buf = marshal_u16(buf, self.size)?;

        let buf = marshal_u16(buf, self.offset)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_qualifying_data) = match Tpm2bData::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        let (buf, unmarshalled_in_scheme) = match TpmtSigSchemeWCV::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_size) = match unmarshal_u16(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_offset) = match unmarshal_u16(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{qualifying_data: unmarshalled_qualifying_data, in_scheme: unmarshalled_in_scheme, size: unmarshalled_size, offset: unmarshalled_offset}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2NvCertifyCommandParams<'static>, TpmErr> {
        Ok(Tpm2NvCertifyCommandParams {
            qualifying_data: self.qualifying_data.try_clone_intern()?,
            in_scheme: self.in_scheme,
            size: self.size,
            offset: self.offset,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2NvCertifyCommandParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2NvCertifyCommandParams<'static>, TpmErr> {
        let Self {
            qualifying_data,
            in_scheme,
            size,
            offset,
        } = self;

        let qualifying_data = qualifying_data.into_bufs_owner_intern()?;

        Ok(Tpm2NvCertifyCommandParams {
            qualifying_data,
            in_scheme,
            size,
            offset,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2NvCertifyCommandParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

const fn tpm2_nv_certify_command_params_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += tpm2b_data_marshalled_max_size();
    size += tpmt_sig_scheme_wcv_marshalled_max_size();
    size += mem::size_of::<u16>() as u16;
    size += mem::size_of::<u16>() as u16;

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 349, table 255, TPM2_NV_Certify_RESPONSE_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2NvCertifyResponseParams<'a> {
    pub certify_info: Tpm2bAttest<'a>,
    pub signature: TpmtSignature<'a>,
}

impl<'a> Tpm2NvCertifyResponseParams<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2_nv_certify_response_params_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let certify_info_size = match self.certify_info.marshalled_size() {
            Ok(certify_info_size) => certify_info_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(certify_info_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let signature_size = match self.signature.marshalled_size() {
            Ok(signature_size) => signature_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(signature_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.certify_info.marshal(buf)?;

        let buf = self.signature.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_certify_info) = match Tpm2bAttest::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        let (buf, unmarshalled_signature) = match TpmtSignature::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{certify_info: unmarshalled_certify_info, signature: unmarshalled_signature}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2NvCertifyResponseParams<'static>, TpmErr> {
        Ok(Tpm2NvCertifyResponseParams {
            certify_info: self.certify_info.try_clone_intern()?,
            signature: self.signature.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2NvCertifyResponseParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2NvCertifyResponseParams<'static>, TpmErr> {
        let Self {
            certify_info,
            signature,
        } = self;

        let certify_info = certify_info.into_bufs_owner_intern()?;
        let signature = signature.into_bufs_owner_intern()?;

        Ok(Tpm2NvCertifyResponseParams {
            certify_info,
            signature,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2NvCertifyResponseParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpm2_nv_certify_response_params_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    let certify_info_size = match tpm2b_attest_marshalled_max_size(limits) {
        Ok(certify_info_size) => certify_info_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(certify_info_size).ok_or(())?;

    let signature_size = match tpmt_signature_marshalled_max_size(limits) {
        Ok(signature_size) => signature_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(signature_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 351, table 256, TPM2_NV_DefineSpace2_COMMAND_HANDLES structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2NvDefineSpace2CommandHandles {
    pub auth_handle: TpmiRhProvision,
}

impl Tpm2NvDefineSpace2CommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_nv_definespace2_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.auth_handle.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_auth_handle) = match TpmiRhProvision::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{auth_handle: unmarshalled_auth_handle}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_nv_definespace2_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiRhProvision::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 351, table 256, TPM2_NV_DefineSpace2_COMMAND_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2NvDefineSpace2CommandParams<'a> {
    pub auth: Tpm2bDigest<'a>,
    pub public_info: Tpm2bNvPublic2<'a>,
}

impl<'a> Tpm2NvDefineSpace2CommandParams<'a> {
    pub const fn marshalled_max_size() -> u16 {
        tpm2_nv_definespace2_command_params_marshalled_max_size()
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let auth_size = match self.auth.marshalled_size() {
            Ok(auth_size) => auth_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(auth_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let public_info_size = match self.public_info.marshalled_size() {
            Ok(public_info_size) => public_info_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(public_info_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.auth.marshal(buf)?;

        let buf = self.public_info.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_auth) = match Tpm2bDigest::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        let (buf, unmarshalled_public_info) = match Tpm2bNvPublic2::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{auth: unmarshalled_auth, public_info: unmarshalled_public_info}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2NvDefineSpace2CommandParams<'static>, TpmErr> {
        Ok(Tpm2NvDefineSpace2CommandParams {
            auth: self.auth.try_clone_intern()?,
            public_info: self.public_info.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2NvDefineSpace2CommandParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2NvDefineSpace2CommandParams<'static>, TpmErr> {
        let Self {
            auth,
            public_info,
        } = self;

        let auth = auth.into_bufs_owner_intern()?;
        let public_info = public_info.into_bufs_owner_intern()?;

        Ok(Tpm2NvDefineSpace2CommandParams {
            auth,
            public_info,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2NvDefineSpace2CommandParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

const fn tpm2_nv_definespace2_command_params_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += tpm2b_digest_marshalled_max_size();
    size += tpm2b_nv_public_2_marshalled_max_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 353, table 258, TPM2_NV_ReadPublic2_COMMAND_HANDLES structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2NvReadPublic2CommandHandles {
    pub nv_index: TpmiRhNvIndex,
}

impl Tpm2NvReadPublic2CommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_nv_readpublic2_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.nv_index.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_nv_index) = match TpmiRhNvIndex::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{nv_index: unmarshalled_nv_index}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_nv_readpublic2_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiRhNvIndex::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 353, table 259, TPM2_NV_ReadPublic2_RESPONSE_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2NvReadPublic2ResponseParams<'a> {
    pub nv_public: Tpm2bNvPublic2<'a>,
    pub nv_name: Tpm2bName<'a>,
}

impl<'a> Tpm2NvReadPublic2ResponseParams<'a> {
    pub const fn marshalled_max_size() -> u16 {
        tpm2_nv_readpublic2_response_params_marshalled_max_size()
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let nv_public_size = match self.nv_public.marshalled_size() {
            Ok(nv_public_size) => nv_public_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(nv_public_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let nv_name_size = match self.nv_name.marshalled_size() {
            Ok(nv_name_size) => nv_name_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(nv_name_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.nv_public.marshal(buf)?;

        let buf = self.nv_name.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_nv_public) = match Tpm2bNvPublic2::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        let (buf, unmarshalled_nv_name) = match Tpm2bName::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{nv_public: unmarshalled_nv_public, nv_name: unmarshalled_nv_name}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2NvReadPublic2ResponseParams<'static>, TpmErr> {
        Ok(Tpm2NvReadPublic2ResponseParams {
            nv_public: self.nv_public.try_clone_intern()?,
            nv_name: self.nv_name.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2NvReadPublic2ResponseParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2NvReadPublic2ResponseParams<'static>, TpmErr> {
        let Self {
            nv_public,
            nv_name,
        } = self;

        let nv_public = nv_public.into_bufs_owner_intern()?;
        let nv_name = nv_name.into_bufs_owner_intern()?;

        Ok(Tpm2NvReadPublic2ResponseParams {
            nv_public,
            nv_name,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2NvReadPublic2ResponseParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

const fn tpm2_nv_readpublic2_response_params_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += tpm2b_nv_public_2_marshalled_max_size();
    size += tpm2b_name_marshalled_max_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 356, table 260, TPM2_AC_GetCapability_COMMAND_HANDLES structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2AcGetCapabilityCommandHandles {
    pub ac: TpmiRhAc,
}

impl Tpm2AcGetCapabilityCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_ac_getcapability_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.ac.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_ac) = match TpmiRhAc::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{ac: unmarshalled_ac}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_ac_getcapability_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiRhAc::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 356, table 260, TPM2_AC_GetCapability_COMMAND_PARAMS structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2AcGetCapabilityCommandParams {
    pub capability: TpmAt,
    pub count: u32,
}

impl Tpm2AcGetCapabilityCommandParams {
    pub const fn marshalled_size() -> u16 {
        tpm2_ac_getcapability_command_params_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.capability.marshal(buf)?;

        let buf = marshal_u32(buf, self.count)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_capability) = match TpmAt::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_count) = match unmarshal_u32(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{capability: unmarshalled_capability, count: unmarshalled_count}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_ac_getcapability_command_params_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmAt::marshalled_size();
    size += mem::size_of::<u32>() as u16;

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 356, table 261, TPM2_AC_GetCapability_RESPONSE_PARAMS structure
#[derive(Debug, PartialEq, Eq)]
pub struct Tpm2AcGetCapabilityResponseParams {
    pub more_data: TpmiYesNo,
    pub capabilities_data: TpmlAcCapabilities,
}

impl Tpm2AcGetCapabilityResponseParams {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2_ac_getcapability_response_params_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let more_data_size = match usize::try_from(TpmiYesNo::marshalled_size()) {
            Ok(more_data_size) => more_data_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(more_data_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let capabilities_data_size = match self.capabilities_data.marshalled_size() {
            Ok(capabilities_data_size) => capabilities_data_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(capabilities_data_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.more_data.marshal(buf)?;

        let buf = self.capabilities_data.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_more_data) = match TpmiYesNo::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_capabilities_data) = match TpmlAcCapabilities::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{more_data: unmarshalled_more_data, capabilities_data: unmarshalled_capabilities_data}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2AcGetCapabilityResponseParams, TpmErr> {
        Ok(Tpm2AcGetCapabilityResponseParams {
            more_data: self.more_data,
            capabilities_data: self.capabilities_data.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2AcGetCapabilityResponseParams>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpm2_ac_getcapability_response_params_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    size += TpmiYesNo::marshalled_size() as u32;

    let capabilities_data_size = match tpml_ac_capabilities_marshalled_max_size(limits) {
        Ok(capabilities_data_size) => capabilities_data_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(capabilities_data_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 358, table 262, TPM2_AC_Send_COMMAND_HANDLES structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2AcSendCommandHandles {
    pub send_object: TpmiDhObject,
    pub auth_handle: TpmiRhNvAuth,
    pub ac: TpmiRhAc,
}

impl Tpm2AcSendCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_ac_send_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.send_object.marshal(buf)?;

        let buf = self.auth_handle.marshal(buf)?;

        let buf = self.ac.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_send_object) = match TpmiDhObject::unmarshal(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_auth_handle) = match TpmiRhNvAuth::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_ac) = match TpmiRhAc::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{send_object: unmarshalled_send_object, auth_handle: unmarshalled_auth_handle, ac: unmarshalled_ac}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_ac_send_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiDhObject::marshalled_size();
    size += TpmiRhNvAuth::marshalled_size();
    size += TpmiRhAc::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 358, table 262, TPM2_AC_Send_COMMAND_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2AcSendCommandParams<'a> {
    pub ac_data_in: Tpm2bMaxBuffer<'a>,
}

impl<'a> Tpm2AcSendCommandParams<'a> {
    pub fn marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
        tpm2_ac_send_command_params_marshalled_max_size(limits)
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let ac_data_in_size = match self.ac_data_in.marshalled_size() {
            Ok(ac_data_in_size) => ac_data_in_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(ac_data_in_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.ac_data_in.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_ac_data_in) = match Tpm2bMaxBuffer::unmarshal_intern(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        Ok((buf, Self{ac_data_in: unmarshalled_ac_data_in}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2AcSendCommandParams<'static>, TpmErr> {
        Ok(Tpm2AcSendCommandParams {
            ac_data_in: self.ac_data_in.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2AcSendCommandParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2AcSendCommandParams<'static>, TpmErr> {
        let Self {
            ac_data_in,
        } = self;

        let ac_data_in = ac_data_in.into_bufs_owner_intern()?;

        Ok(Tpm2AcSendCommandParams {
            ac_data_in,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2AcSendCommandParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

fn tpm2_ac_send_command_params_marshalled_max_size(limits: &TpmLimits) -> Result<u32, ()> {
    let mut size: u32 = 0;

    let ac_data_in_size = match tpm2b_max_buffer_marshalled_max_size(limits) {
        Ok(ac_data_in_size) => ac_data_in_size,
        Err(_) => {
            return Err(());
        },
    };
    size = size.checked_add(ac_data_in_size).ok_or(())?;

    Ok(size)
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 358, table 263, TPM2_AC_Send_RESPONSE_PARAMS structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2AcSendResponseParams {
    pub ac_data_out: TpmsAcOutput,
}

impl Tpm2AcSendResponseParams {
    pub const fn marshalled_size() -> u16 {
        tpm2_ac_send_response_params_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.ac_data_out.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_ac_data_out) = match TpmsAcOutput::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{ac_data_out: unmarshalled_ac_data_out}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_ac_send_response_params_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += tpms_ac_output_marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 361, table 264, TPM2_Policy_AC_SendSelect_COMMAND_HANDLES structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2PolicyAcSendSelectCommandHandles {
    pub policy_session: TpmiShPolicy,
}

impl Tpm2PolicyAcSendSelectCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_policy_ac_sendselect_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.policy_session.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_policy_session) = match TpmiShPolicy::unmarshal(buf, limits) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{policy_session: unmarshalled_policy_session}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8], limits: &TpmLimits) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf, limits)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_policy_ac_sendselect_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiShPolicy::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 361, table 264, TPM2_Policy_AC_SendSelect_COMMAND_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2PolicyAcSendSelectCommandParams<'a> {
    pub object_name: Tpm2bName<'a>,
    pub auth_handle_name: Tpm2bName<'a>,
    pub ac_name: Tpm2bName<'a>,
    pub include_object: TpmiYesNo,
}

impl<'a> Tpm2PolicyAcSendSelectCommandParams<'a> {
    pub const fn marshalled_max_size() -> u16 {
        tpm2_policy_ac_sendselect_command_params_marshalled_max_size()
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let include_object_size = match usize::try_from(TpmiYesNo::marshalled_size()) {
            Ok(include_object_size) => include_object_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(include_object_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let object_name_size = match self.object_name.marshalled_size() {
            Ok(object_name_size) => object_name_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(object_name_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let auth_handle_name_size = match self.auth_handle_name.marshalled_size() {
            Ok(auth_handle_name_size) => auth_handle_name_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(auth_handle_name_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        let ac_name_size = match self.ac_name.marshalled_size() {
            Ok(ac_name_size) => ac_name_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(ac_name_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.object_name.marshal(buf)?;

        let buf = self.auth_handle_name.marshal(buf)?;

        let buf = self.ac_name.marshal(buf)?;

        let buf = self.include_object.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_object_name) = match Tpm2bName::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        let (buf, unmarshalled_auth_handle_name) = match Tpm2bName::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_ac_name) = match Tpm2bName::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        let (buf, unmarshalled_include_object) = match TpmiYesNo::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{object_name: unmarshalled_object_name, auth_handle_name: unmarshalled_auth_handle_name, ac_name: unmarshalled_ac_name, include_object: unmarshalled_include_object}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2PolicyAcSendSelectCommandParams<'static>, TpmErr> {
        Ok(Tpm2PolicyAcSendSelectCommandParams {
            object_name: self.object_name.try_clone_intern()?,
            auth_handle_name: self.auth_handle_name.try_clone_intern()?,
            ac_name: self.ac_name.try_clone_intern()?,
            include_object: self.include_object,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2PolicyAcSendSelectCommandParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2PolicyAcSendSelectCommandParams<'static>, TpmErr> {
        let Self {
            object_name,
            auth_handle_name,
            ac_name,
            include_object,
        } = self;

        let object_name = object_name.into_bufs_owner_intern()?;
        let auth_handle_name = auth_handle_name.into_bufs_owner_intern()?;
        let ac_name = ac_name.into_bufs_owner_intern()?;

        Ok(Tpm2PolicyAcSendSelectCommandParams {
            object_name,
            auth_handle_name,
            ac_name,
            include_object,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2PolicyAcSendSelectCommandParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

const fn tpm2_policy_ac_sendselect_command_params_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += tpm2b_name_marshalled_max_size();
    size += tpm2b_name_marshalled_max_size();
    size += tpm2b_name_marshalled_max_size();
    size += TpmiYesNo::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 364, table 266, TPM2_ACT_SetTimeout_COMMAND_HANDLES structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2ActSetTimeoutCommandHandles {
    pub act_handle: TpmiRhAct,
}

impl Tpm2ActSetTimeoutCommandHandles {
    pub const fn marshalled_size() -> u16 {
        tpm2_act_settimeout_command_handles_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = self.act_handle.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_act_handle) = match TpmiRhAct::unmarshal(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{act_handle: unmarshalled_act_handle}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_act_settimeout_command_handles_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += TpmiRhAct::marshalled_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 364, table 266, TPM2_ACT_SetTimeout_COMMAND_PARAMS structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Tpm2ActSetTimeoutCommandParams {
    pub start_timeout: u32,
}

impl Tpm2ActSetTimeoutCommandParams {
    pub const fn marshalled_size() -> u16 {
        tpm2_act_settimeout_command_params_marshalled_size()
    }

    pub fn marshal<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], TpmErr> {
        let buf = marshal_u32(buf, self.start_timeout)?;

        Ok(buf)
    }

    fn unmarshal_intern<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unmarshalled_start_timeout) = match unmarshal_u32(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };

        Ok((buf, Self{start_timeout: unmarshalled_start_timeout}))
    }

    pub fn unmarshal<'a>(buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }
}

const fn tpm2_act_settimeout_command_params_marshalled_size() -> u16 {
    let mut size: u16 = 0;

    size += mem::size_of::<u32>() as u16;

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 367, table 268, TPM2_Vendor_TCG_Test_COMMAND_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2VendorTcgTestCommandParams<'a> {
    pub input_data: Tpm2bData<'a>,
}

impl<'a> Tpm2VendorTcgTestCommandParams<'a> {
    pub const fn marshalled_max_size() -> u16 {
        tpm2_vendor_tcg_test_command_params_marshalled_max_size()
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let input_data_size = match self.input_data.marshalled_size() {
            Ok(input_data_size) => input_data_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(input_data_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.input_data.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_input_data) = match Tpm2bData::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        Ok((buf, Self{input_data: unmarshalled_input_data}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2VendorTcgTestCommandParams<'static>, TpmErr> {
        Ok(Tpm2VendorTcgTestCommandParams {
            input_data: self.input_data.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2VendorTcgTestCommandParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2VendorTcgTestCommandParams<'static>, TpmErr> {
        let Self {
            input_data,
        } = self;

        let input_data = input_data.into_bufs_owner_intern()?;

        Ok(Tpm2VendorTcgTestCommandParams {
            input_data,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2VendorTcgTestCommandParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

const fn tpm2_vendor_tcg_test_command_params_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += tpm2b_data_marshalled_max_size();

    size
}

// TCG TPM2 Library, Version 184, Part 3 -- Commands, page 367, table 269, TPM2_Vendor_TCG_Test_RESPONSE_PARAMS structure
#[derive(Debug, PartialEq)]
pub struct Tpm2VendorTcgTestResponseParams<'a> {
    pub output_data: Tpm2bData<'a>,
}

impl<'a> Tpm2VendorTcgTestResponseParams<'a> {
    pub const fn marshalled_max_size() -> u16 {
        tpm2_vendor_tcg_test_response_params_marshalled_max_size()
    }

    pub fn marshalled_size(&self) -> Result<usize, ()> {
        let mut size: usize = 0;

        let output_data_size = match self.output_data.marshalled_size() {
            Ok(output_data_size) => output_data_size,
            Err(_) => {
                return Err(());
            },
        };
        size = match size.checked_add(output_data_size) {
            Some(size) => size,
            None => {
                return Err(());
            },
        };

        Ok(size)
    }

    pub fn marshal<'b>(&self, buf: &'b mut [u8]) -> Result<&'b mut [u8], TpmErr> {
        let buf = self.output_data.marshal(buf)?;

        Ok(buf)
    }

    fn unmarshal_intern(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8]) -> Result<(&'a [u8], Self), TpmErr> {
        let (buf, unencrypted_tail_buf) = match decrypted_head_buf {
            Some(decrypted_head_buf) => (decrypted_head_buf, Some(unencrypted_tail_buf)),
            None => (unencrypted_tail_buf, None),
        };
        let (buf, unmarshalled_output_data) = match Tpm2bData::unmarshal_intern(buf) {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            },
        };
        let buf = unencrypted_tail_buf.unwrap_or(buf);

        Ok((buf, Self{output_data: unmarshalled_output_data}))
    }

    pub fn unmarshal(decrypted_head_buf: Option<&'a [u8]>, unencrypted_tail_buf: &'a [u8]) -> Result<(&'a [u8], Box<Self>), TpmErr> {
        let (buf, unmarshalled) = Self::unmarshal_intern(decrypted_head_buf, unencrypted_tail_buf)?;
        let unmarshalled: Box<Self> = match box_try_new(unmarshalled) {
            Ok(unmarshalled) => unmarshalled,
            Err(_) => {
                return Err(TpmErr::Rc(TpmRc::MEMORY));
            },
        };

        Ok((buf, unmarshalled))
    }

    fn try_clone_intern(&self) -> Result<Tpm2VendorTcgTestResponseParams<'static>, TpmErr> {
        Ok(Tpm2VendorTcgTestResponseParams {
            output_data: self.output_data.try_clone_intern()?,
        })
    }

    pub fn try_clone(&self) -> Result<Box<Tpm2VendorTcgTestResponseParams<'static>>, TpmErr> {
        box_try_new(self.try_clone_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }

    fn into_bufs_owner_intern(self) -> Result<Tpm2VendorTcgTestResponseParams<'static>, TpmErr> {
        let Self {
            output_data,
        } = self;

        let output_data = output_data.into_bufs_owner_intern()?;

        Ok(Tpm2VendorTcgTestResponseParams {
            output_data,
        })
    }

    pub fn into_bufs_owner(this: Box<Self>) -> Result<Box<Tpm2VendorTcgTestResponseParams<'static>>, TpmErr> {
        let this = box_into_inner(this);
        box_try_new(this.into_bufs_owner_intern()?).map_err(|_| TpmErr::Rc(TpmRc::MEMORY))
    }
}

const fn tpm2_vendor_tcg_test_response_params_marshalled_max_size() -> u16 {
    let mut size: u16 = 0;

    size += tpm2b_data_marshalled_max_size();

    size
}

macro_rules! with_tpm_commands {
    ( $m:ident, $cp_lifetime:lifetime, $rp_lifetime:lifetime ) => {
        $m![
            {
                command_code: TpmCc::Startup,
                name_in_camelcase: Tpm2Startup,
                name_in_snakecase: tpm2_startup,
                nv: true,
                command_params: {
                    type: Tpm2StartupCommandParams,
                    can_crypt: false,
                    trivial_clone: true,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::Shutdown,
                name_in_camelcase: Tpm2Shutdown,
                name_in_snakecase: tpm2_shutdown,
                nv: true,
                command_params: {
                    type: Tpm2ShutdownCommandParams,
                    can_crypt: false,
                    trivial_clone: true,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::SelfTest,
                name_in_camelcase: Tpm2SelfTest,
                name_in_snakecase: tpm2_self_test,
                nv: true,
                command_params: {
                    type: Tpm2SelfTestCommandParams,
                    can_crypt: false,
                    trivial_clone: true,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::IncrementalSelfTest,
                name_in_camelcase: Tpm2IncrementalSelfTest,
                name_in_snakecase: tpm2_incremental_self_test,
                nv: true,
                command_params: {
                    type: Tpm2IncrementalSelfTestCommandParams,
                    can_crypt: false,
                    trivial_clone: false,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
                response_params: {
                    type: Tpm2IncrementalSelfTestResponseParams,
                    can_crypt: false,
                    trivial_clone: false,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::GetTestResult,
                name_in_camelcase: Tpm2GetTestResult,
                name_in_snakecase: tpm2_get_test_result,
                response_params: {
                    type: Tpm2GetTestResultResponseParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::StartAuthSession,
                name_in_camelcase: Tpm2StartAuthSession,
                name_in_snakecase: tpm2_start_auth_session,
                command_handles: {
                    type: Tpm2StartAuthSessionCommandHandles,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        { name: tpm_key, type: TpmiDhObjectWCV, },
                        { name: bind, type: TpmiDhEntityWCV, }
                    },
                },
                command_params: {
                    type: Tpm2StartAuthSessionCommandParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
                response_handles: {
                    type: Tpm2StartAuthSessionResponseHandles,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        { name: session_handle, type: TpmiShAuthSession, }
                    },
                },
                response_params: {
                    type: Tpm2StartAuthSessionResponseParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::PolicyRestart,
                name_in_camelcase: Tpm2PolicyRestart,
                name_in_snakecase: tpm2_policy_restart,
                command_handles: {
                    type: Tpm2PolicyRestartCommandHandles,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        { name: session_handle, type: TpmiShPolicy, }
                    },
                },
            },
            {
                command_code: TpmCc::Create,
                name_in_camelcase: Tpm2Create,
                name_in_snakecase: tpm2_create,
                command_handles: {
                    type: Tpm2CreateCommandHandles,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        {
                            name: parent_handle, type: TpmiDhObject,
                            auth: { index: 1, role: User, },
                        }
                    },
                },
                command_params: {
                    type: Tpm2CreateCommandParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
                response_params: {
                    type: Tpm2CreateResponseParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::Load,
                name_in_camelcase: Tpm2Load,
                name_in_snakecase: tpm2_load,
                command_handles: {
                    type: Tpm2LoadCommandHandles,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        {
                            name: parent_handle, type: TpmiDhObject,
                            auth: { index: 1, role: User, },
                        }
                    },
                },
                command_params: {
                    type: Tpm2LoadCommandParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
                response_handles: {
                    type: Tpm2LoadResponseHandles,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        { name: object_handle, type: u32, }
                    },
                },
                response_params: {
                    type: Tpm2LoadResponseParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::LoadExternal,
                name_in_camelcase: Tpm2LoadExternal,
                name_in_snakecase: tpm2_load_external,
                command_params: {
                    type: Tpm2LoadExternalCommandParams,
                    lifetime: $cp_lifetime,
                    can_crypt: false,
                    trivial_clone: false,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
                response_handles: {
                    type: Tpm2LoadExternalResponseHandles,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        { name: object_handle, type: u32, }
                    },
                },
                response_params: {
                    type: Tpm2LoadExternalResponseParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::ReadPublic,
                name_in_camelcase: Tpm2ReadPublic,
                name_in_snakecase: tpm2_read_public,
                command_handles: {
                    type: Tpm2ReadPublicCommandHandles,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        { name: object_handle, type: TpmiDhObject, }
                    },
                },
                response_params: {
                    type: Tpm2ReadPublicResponseParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::ActivateCredential,
                name_in_camelcase: Tpm2ActivateCredential,
                name_in_snakecase: tpm2_activate_credential,
                command_handles: {
                    type: Tpm2ActivateCredentialCommandHandles,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        {
                            name: activate_handle, type: TpmiDhObject,
                            auth: { index: 1, role: Admin, },
                        },
                        {
                            name: key_handle, type: TpmiDhObject,
                            auth: { index: 2, role: User, },
                        }
                    },
                },
                command_params: {
                    type: Tpm2ActivateCredentialCommandParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
                response_params: {
                    type: Tpm2ActivateCredentialResponseParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::MakeCredential,
                name_in_camelcase: Tpm2MakeCredential,
                name_in_snakecase: tpm2_make_credential,
                command_handles: {
                    type: Tpm2MakeCredentialCommandHandles,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        { name: handle, type: TpmiDhObject, }
                    },
                },
                command_params: {
                    type: Tpm2MakeCredentialCommandParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
                response_params: {
                    type: Tpm2MakeCredentialResponseParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::Unseal,
                name_in_camelcase: Tpm2Unseal,
                name_in_snakecase: tpm2_unseal,
                command_handles: {
                    type: Tpm2UnsealCommandHandles,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        {
                            name: item_handle, type: TpmiDhObject,
                            auth: { index: 1, role: User, },
                        }
                    },
                },
                response_params: {
                    type: Tpm2UnsealResponseParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::ObjectChangeAuth,
                name_in_camelcase: Tpm2ObjectChangeAuth,
                name_in_snakecase: tpm2_object_change_auth,
                command_handles: {
                    type: Tpm2ObjectChangeAuthCommandHandles,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        {
                            name: object_handle, type: TpmiDhObject,
                            auth: { index: 1, role: Admin, },
                        },
                        { name: parent_handle, type: TpmiDhObject, }
                    },
                },
                command_params: {
                    type: Tpm2ObjectChangeAuthCommandParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
                response_params: {
                    type: Tpm2ObjectChangeAuthResponseParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::CreateLoaded,
                name_in_camelcase: Tpm2CreateLoaded,
                name_in_snakecase: tpm2_create_loaded,
                platform_auth_pp: MayBeRequired,
                command_handles: {
                    type: Tpm2CreateLoadedCommandHandles,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        {
                            name: parent_handle, type: TpmiDhParent,
                            auth: { index: 1, role: User, },
                        }
                    },
                },
                command_params: {
                    type: Tpm2CreateLoadedCommandParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
                response_handles: {
                    type: Tpm2CreateLoadedResponseHandles,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        { name: object_handle, type: u32, }
                    },
                },
                response_params: {
                    type: Tpm2CreateLoadedResponseParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::Duplicate,
                name_in_camelcase: Tpm2Duplicate,
                name_in_snakecase: tpm2_duplicate,
                command_handles: {
                    type: Tpm2DuplicateCommandHandles,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        {
                            name: object_handle, type: TpmiDhObject,
                            auth: { index: 1, role: Dup, },
                        },
                        { name: new_parent_handle, type: TpmiDhObjectWCV, }
                    },
                },
                command_params: {
                    type: Tpm2DuplicateCommandParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
                response_params: {
                    type: Tpm2DuplicateResponseParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::Rewrap,
                name_in_camelcase: Tpm2Rewrap,
                name_in_snakecase: tpm2_rewrap,
                command_handles: {
                    type: Tpm2RewrapCommandHandles,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        {
                            name: old_parent, type: TpmiDhObjectWCV,
                            auth: { index: 1, role: User, },
                        },
                        { name: new_parent, type: TpmiDhObjectWCV, }
                    },
                },
                command_params: {
                    type: Tpm2RewrapCommandParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
                response_params: {
                    type: Tpm2RewrapResponseParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::Import,
                name_in_camelcase: Tpm2Import,
                name_in_snakecase: tpm2_import,
                command_handles: {
                    type: Tpm2ImportCommandHandles,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        {
                            name: parent_handle, type: TpmiDhObject,
                            auth: { index: 1, role: User, },
                        }
                    },
                },
                command_params: {
                    type: Tpm2ImportCommandParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
                response_params: {
                    type: Tpm2ImportResponseParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::RsaEncrypt,
                name_in_camelcase: Tpm2RsaEncrypt,
                name_in_snakecase: tpm2_rsa_encrypt,
                cfg: feature = "rsa",
                command_handles: {
                    type: Tpm2RsaEncryptCommandHandles,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        { name: key_handle, type: TpmiDhObject, }
                    },
                },
                command_params: {
                    type: Tpm2RsaEncryptCommandParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
                response_params: {
                    type: Tpm2RsaEncryptResponseParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::RsaDecrypt,
                name_in_camelcase: Tpm2RsaDecrypt,
                name_in_snakecase: tpm2_rsa_decrypt,
                cfg: feature = "rsa",
                command_handles: {
                    type: Tpm2RsaDecryptCommandHandles,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        {
                            name: key_handle, type: TpmiDhObject,
                            auth: { index: 1, role: User, },
                        }
                    },
                },
                command_params: {
                    type: Tpm2RsaDecryptCommandParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
                response_params: {
                    type: Tpm2RsaDecryptResponseParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::EcdhKeyGen,
                name_in_camelcase: Tpm2EcdhKeyGen,
                name_in_snakecase: tpm2_ecdh_key_gen,
                cfg: feature = "ecc",
                command_handles: {
                    type: Tpm2EcdhKeyGenCommandHandles,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        { name: key_handle, type: TpmiDhObject, }
                    },
                },
                response_params: {
                    type: Tpm2EcdhKeyGenResponseParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::EcdhZGen,
                name_in_camelcase: Tpm2EcdhZGen,
                name_in_snakecase: tpm2_ecdh_zg_en,
                cfg: feature = "ecc",
                command_handles: {
                    type: Tpm2EcdhZGenCommandHandles,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        {
                            name: key_handle, type: TpmiDhObject,
                            auth: { index: 1, role: User, },
                        }
                    },
                },
                command_params: {
                    type: Tpm2EcdhZGenCommandParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
                response_params: {
                    type: Tpm2EcdhZGenResponseParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::EccParameters,
                name_in_camelcase: Tpm2EccParameters,
                name_in_snakecase: tpm2_ecc_parameters,
                cfg: feature = "ecc",
                command_params: {
                    type: Tpm2EccParametersCommandParams,
                    can_crypt: false,
                    trivial_clone: true,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
                response_params: {
                    type: Tpm2EccParametersResponseParams,
                    lifetime: $cp_lifetime,
                    can_crypt: false,
                    trivial_clone: false,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::ZGen2Phase,
                name_in_camelcase: Tpm2ZGen2Phase,
                name_in_snakecase: tpm2_zg_en_2_phase,
                cfg: feature = "ecc",
                command_handles: {
                    type: Tpm2ZGen2PhaseCommandHandles,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        {
                            name: key_a, type: TpmiDhObject,
                            auth: { index: 1, role: User, },
                        }
                    },
                },
                command_params: {
                    type: Tpm2ZGen2PhaseCommandParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
                response_params: {
                    type: Tpm2ZGen2PhaseResponseParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::EccEncrypt,
                name_in_camelcase: Tpm2EccEncrypt,
                name_in_snakecase: tpm2_ecc_encrypt,
                cfg: feature = "ecc",
                command_handles: {
                    type: Tpm2EccEncryptCommandHandles,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        { name: key_handle, type: TpmiDhObject, }
                    },
                },
                command_params: {
                    type: Tpm2EccEncryptCommandParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
                response_params: {
                    type: Tpm2EccEncryptResponseParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::EccDecrypt,
                name_in_camelcase: Tpm2EccDecrypt,
                name_in_snakecase: tpm2_ecc_decrypt,
                cfg: feature = "ecc",
                command_handles: {
                    type: Tpm2EccDecryptCommandHandles,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        {
                            name: key_handle, type: TpmiDhObject,
                            auth: { index: 1, role: User, },
                        }
                    },
                },
                command_params: {
                    type: Tpm2EccDecryptCommandParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
                response_params: {
                    type: Tpm2EccDecryptResponseParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::EncryptDecrypt,
                name_in_camelcase: Tpm2EncryptDecrypt,
                name_in_snakecase: tpm2_encrypt_decrypt,
                command_handles: {
                    type: Tpm2EncryptDecryptCommandHandles,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        {
                            name: key_handle, type: TpmiDhObject,
                            auth: { index: 1, role: User, },
                        }
                    },
                },
                command_params: {
                    type: Tpm2EncryptDecryptCommandParams,
                    lifetime: $cp_lifetime,
                    can_crypt: false,
                    trivial_clone: false,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
                response_params: {
                    type: Tpm2EncryptDecryptResponseParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::EncryptDecrypt2,
                name_in_camelcase: Tpm2EncryptDecrypt2,
                name_in_snakecase: tpm2_encrypt_decrypt2,
                command_handles: {
                    type: Tpm2EncryptDecrypt2CommandHandles,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        {
                            name: key_handle, type: TpmiDhObject,
                            auth: { index: 1, role: User, },
                        }
                    },
                },
                command_params: {
                    type: Tpm2EncryptDecrypt2CommandParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
                response_params: {
                    type: Tpm2EncryptDecrypt2ResponseParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::Hash,
                name_in_camelcase: Tpm2Hash,
                name_in_snakecase: tpm2_hash,
                command_params: {
                    type: Tpm2HashCommandParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
                response_params: {
                    type: Tpm2HashResponseParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::Hmac,
                name_in_camelcase: Tpm2Hmac,
                name_in_snakecase: tpm2_hmac,
                cfg: not(feature = "cmac"),
                command_handles: {
                    type: Tpm2HmacCommandHandles,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        {
                            name: handle, type: TpmiDhObject,
                            auth: { index: 1, role: User, },
                        }
                    },
                },
                command_params: {
                    type: Tpm2HmacCommandParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
                response_params: {
                    type: Tpm2HmacResponseParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::Mac,
                name_in_camelcase: Tpm2Mac,
                name_in_snakecase: tpm2_mac,
                cfg: feature = "cmac",
                command_handles: {
                    type: Tpm2MacCommandHandles,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        {
                            name: handle, type: TpmiDhObject,
                            auth: { index: 1, role: User, },
                        }
                    },
                },
                command_params: {
                    type: Tpm2MacCommandParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
                response_params: {
                    type: Tpm2MacResponseParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::GetRandom,
                name_in_camelcase: Tpm2GetRandom,
                name_in_snakecase: tpm2_get_random,
                command_params: {
                    type: Tpm2GetRandomCommandParams,
                    can_crypt: false,
                    trivial_clone: true,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
                response_params: {
                    type: Tpm2GetRandomResponseParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::StirRandom,
                name_in_camelcase: Tpm2StirRandom,
                name_in_snakecase: tpm2_stir_random,
                nv: true,
                command_params: {
                    type: Tpm2StirRandomCommandParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::HmacStart,
                name_in_camelcase: Tpm2HmacStart,
                name_in_snakecase: tpm2_hmac_start,
                cfg: not(feature = "cmac"),
                command_handles: {
                    type: Tpm2HmacStartCommandHandles,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        {
                            name: handle, type: TpmiDhObject,
                            auth: { index: 1, role: User, },
                        }
                    },
                },
                command_params: {
                    type: Tpm2HmacStartCommandParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
                response_handles: {
                    type: Tpm2HmacStartResponseHandles,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        { name: sequence_handle, type: TpmiDhObject, }
                    },
                },
            },
            {
                command_code: TpmCc::MacStart,
                name_in_camelcase: Tpm2MacStart,
                name_in_snakecase: tpm2_mac_start,
                cfg: feature = "cmac",
                command_handles: {
                    type: Tpm2MacStartCommandHandles,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        {
                            name: handle, type: TpmiDhObject,
                            auth: { index: 1, role: User, },
                        }
                    },
                },
                command_params: {
                    type: Tpm2MacStartCommandParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
                response_handles: {
                    type: Tpm2MacStartResponseHandles,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        { name: sequence_handle, type: TpmiDhObject, }
                    },
                },
            },
            {
                command_code: TpmCc::HashSequenceStart,
                name_in_camelcase: Tpm2HashSequenceStart,
                name_in_snakecase: tpm2_hash_sequence_start,
                command_params: {
                    type: Tpm2HashSequenceStartCommandParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
                response_handles: {
                    type: Tpm2HashSequenceStartResponseHandles,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        { name: sequence_handle, type: TpmiDhObject, }
                    },
                },
            },
            {
                command_code: TpmCc::SequenceUpdate,
                name_in_camelcase: Tpm2SequenceUpdate,
                name_in_snakecase: tpm2_sequence_update,
                command_handles: {
                    type: Tpm2SequenceUpdateCommandHandles,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        {
                            name: sequence_handle, type: TpmiDhObject,
                            auth: { index: 1, role: User, },
                        }
                    },
                },
                command_params: {
                    type: Tpm2SequenceUpdateCommandParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::SequenceComplete,
                name_in_camelcase: Tpm2SequenceComplete,
                name_in_snakecase: tpm2_sequence_complete,
                flushing: Used,
                command_handles: {
                    type: Tpm2SequenceCompleteCommandHandles,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        {
                            name: sequence_handle, type: TpmiDhObject,
                            auth: { index: 1, role: User, },
                        }
                    },
                },
                command_params: {
                    type: Tpm2SequenceCompleteCommandParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
                response_params: {
                    type: Tpm2SequenceCompleteResponseParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::EventSequenceComplete,
                name_in_camelcase: Tpm2EventSequenceComplete,
                name_in_snakecase: tpm2_event_sequence_complete,
                nv: true,
                flushing: Used,
                command_handles: {
                    type: Tpm2EventSequenceCompleteCommandHandles,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        {
                            name: pcr_handle, type: TpmiDhPcrWCV,
                            auth: { index: 1, role: User, },
                        },
                        {
                            name: sequence_handle, type: TpmiDhObject,
                            auth: { index: 2, role: User, },
                        }
                    },
                },
                command_params: {
                    type: Tpm2EventSequenceCompleteCommandParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
                response_params: {
                    type: Tpm2EventSequenceCompleteResponseParams,
                    lifetime: $cp_lifetime,
                    can_crypt: false,
                    trivial_clone: false,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::Certify,
                name_in_camelcase: Tpm2Certify,
                name_in_snakecase: tpm2_certify,
                command_handles: {
                    type: Tpm2CertifyCommandHandles,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        {
                            name: object_handle, type: TpmiDhObject,
                            auth: { index: 1, role: Admin, },
                        },
                        {
                            name: sign_handle, type: TpmiDhObjectWCV,
                            auth: { index: 2, role: User, },
                        }
                    },
                },
                command_params: {
                    type: Tpm2CertifyCommandParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
                response_params: {
                    type: Tpm2CertifyResponseParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::CertifyCreation,
                name_in_camelcase: Tpm2CertifyCreation,
                name_in_snakecase: tpm2_certify_creation,
                command_handles: {
                    type: Tpm2CertifyCreationCommandHandles,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        {
                            name: sign_handle, type: TpmiDhObjectWCV,
                            auth: { index: 1, role: User, },
                        },
                        { name: object_handle, type: TpmiDhObject, }
                    },
                },
                command_params: {
                    type: Tpm2CertifyCreationCommandParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
                response_params: {
                    type: Tpm2CertifyCreationResponseParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::Quote,
                name_in_camelcase: Tpm2Quote,
                name_in_snakecase: tpm2_quote,
                command_handles: {
                    type: Tpm2QuoteCommandHandles,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        {
                            name: sign_handle, type: TpmiDhObjectWCV,
                            auth: { index: 1, role: User, },
                        }
                    },
                },
                command_params: {
                    type: Tpm2QuoteCommandParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
                response_params: {
                    type: Tpm2QuoteResponseParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::GetSessionAuditDigest,
                name_in_camelcase: Tpm2GetSessionAuditDigest,
                name_in_snakecase: tpm2_get_session_audit_digest,
                command_handles: {
                    type: Tpm2GetSessionAuditDigestCommandHandles,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        {
                            name: privacy_admin_handle, type: TpmiRhEndorsement,
                            auth: { index: 1, role: User, },
                        },
                        {
                            name: sign_handle, type: TpmiDhObjectWCV,
                            auth: { index: 2, role: User, },
                        },
                        { name: session_handle, type: TpmiShHmac, }
                    },
                },
                command_params: {
                    type: Tpm2GetSessionAuditDigestCommandParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
                response_params: {
                    type: Tpm2GetSessionAuditDigestResponseParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::GetCommandAuditDigest,
                name_in_camelcase: Tpm2GetCommandAuditDigest,
                name_in_snakecase: tpm2_get_command_audit_digest,
                nv: true,
                command_handles: {
                    type: Tpm2GetCommandAuditDigestCommandHandles,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        {
                            name: privacy_handle, type: TpmiRhEndorsement,
                            auth: { index: 1, role: User, },
                        },
                        {
                            name: sign_handle, type: TpmiDhObjectWCV,
                            auth: { index: 2, role: User, },
                        }
                    },
                },
                command_params: {
                    type: Tpm2GetCommandAuditDigestCommandParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
                response_params: {
                    type: Tpm2GetCommandAuditDigestResponseParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::GetTime,
                name_in_camelcase: Tpm2GetTime,
                name_in_snakecase: tpm2_get_time,
                command_handles: {
                    type: Tpm2GetTimeCommandHandles,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        {
                            name: privacy_admin_handle, type: TpmiRhEndorsement,
                            auth: { index: 1, role: User, },
                        },
                        {
                            name: sign_handle, type: TpmiDhObjectWCV,
                            auth: { index: 2, role: User, },
                        }
                    },
                },
                command_params: {
                    type: Tpm2GetTimeCommandParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
                response_params: {
                    type: Tpm2GetTimeResponseParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::CertifyX509,
                name_in_camelcase: Tpm2CertifyX509,
                name_in_snakecase: tpm2_certify_x509,
                command_handles: {
                    type: Tpm2CertifyX509CommandHandles,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        {
                            name: object_handle, type: TpmiDhObject,
                            auth: { index: 1, role: Admin, },
                        },
                        {
                            name: sign_handle, type: TpmiDhObject,
                            auth: { index: 2, role: User, },
                        }
                    },
                },
                command_params: {
                    type: Tpm2CertifyX509CommandParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
                response_params: {
                    type: Tpm2CertifyX509ResponseParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::Commit,
                name_in_camelcase: Tpm2Commit,
                name_in_snakecase: tpm2_commit,
                cfg: feature = "ecc",
                command_handles: {
                    type: Tpm2CommitCommandHandles,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        {
                            name: sign_handle, type: TpmiDhObject,
                            auth: { index: 1, role: User, },
                        }
                    },
                },
                command_params: {
                    type: Tpm2CommitCommandParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
                response_params: {
                    type: Tpm2CommitResponseParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::EcEphemeral,
                name_in_camelcase: Tpm2EcEphemeral,
                name_in_snakecase: tpm2_ec_ephemeral,
                cfg: feature = "ecc",
                command_params: {
                    type: Tpm2EcEphemeralCommandParams,
                    can_crypt: false,
                    trivial_clone: true,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
                response_params: {
                    type: Tpm2EcEphemeralResponseParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::VerifySignature,
                name_in_camelcase: Tpm2VerifySignature,
                name_in_snakecase: tpm2_verify_signature,
                command_handles: {
                    type: Tpm2VerifySignatureCommandHandles,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        { name: key_handle, type: TpmiDhObject, }
                    },
                },
                command_params: {
                    type: Tpm2VerifySignatureCommandParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
                response_params: {
                    type: Tpm2VerifySignatureResponseParams,
                    lifetime: $cp_lifetime,
                    can_crypt: false,
                    trivial_clone: false,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::Sign,
                name_in_camelcase: Tpm2Sign,
                name_in_snakecase: tpm2_sign,
                command_handles: {
                    type: Tpm2SignCommandHandles,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        {
                            name: key_handle, type: TpmiDhObject,
                            auth: { index: 1, role: User, },
                        }
                    },
                },
                command_params: {
                    type: Tpm2SignCommandParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
                response_params: {
                    type: Tpm2SignResponseParams,
                    lifetime: $cp_lifetime,
                    can_crypt: false,
                    trivial_clone: false,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::SetCommandCodeAuditStatus,
                name_in_camelcase: Tpm2SetCommandCodeAuditStatus,
                name_in_snakecase: tpm2_set_command_code_audit_status,
                nv: true,
                platform_auth_pp: MayBeRequired,
                command_handles: {
                    type: Tpm2SetCommandCodeAuditStatusCommandHandles,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        {
                            name: auth, type: TpmiRhProvision,
                            auth: { index: 1, role: User, },
                        }
                    },
                },
                command_params: {
                    type: Tpm2SetCommandCodeAuditStatusCommandParams,
                    can_crypt: false,
                    trivial_clone: false,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::PcrExtend,
                name_in_camelcase: Tpm2PcrExtend,
                name_in_snakecase: tpm2_pcr_extend,
                nv: true,
                command_handles: {
                    type: Tpm2PcrExtendCommandHandles,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        {
                            name: pcr_handle, type: TpmiDhPcrWCV,
                            auth: { index: 1, role: User, },
                        }
                    },
                },
                command_params: {
                    type: Tpm2PcrExtendCommandParams,
                    lifetime: $cp_lifetime,
                    can_crypt: false,
                    trivial_clone: false,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::PcrEvent,
                name_in_camelcase: Tpm2PcrEvent,
                name_in_snakecase: tpm2_pcr_event,
                nv: true,
                command_handles: {
                    type: Tpm2PcrEventCommandHandles,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        {
                            name: pcr_handle, type: TpmiDhPcrWCV,
                            auth: { index: 1, role: User, },
                        }
                    },
                },
                command_params: {
                    type: Tpm2PcrEventCommandParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
                response_params: {
                    type: Tpm2PcrEventResponseParams,
                    lifetime: $cp_lifetime,
                    can_crypt: false,
                    trivial_clone: false,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::PcrRead,
                name_in_camelcase: Tpm2PcrRead,
                name_in_snakecase: tpm2_pcr_read,
                command_params: {
                    type: Tpm2PcrReadCommandParams,
                    lifetime: $cp_lifetime,
                    can_crypt: false,
                    trivial_clone: false,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
                response_params: {
                    type: Tpm2PcrReadResponseParams,
                    lifetime: $cp_lifetime,
                    can_crypt: false,
                    trivial_clone: false,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::PcrAllocate,
                name_in_camelcase: Tpm2PcrAllocate,
                name_in_snakecase: tpm2_pcr_allocate,
                nv: true,
                platform_auth_pp: MayBeRequired,
                command_handles: {
                    type: Tpm2PcrAllocateCommandHandles,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        {
                            name: auth_handle, type: TpmiRhPlatform,
                            auth: { index: 1, role: User, },
                        }
                    },
                },
                command_params: {
                    type: Tpm2PcrAllocateCommandParams,
                    lifetime: $cp_lifetime,
                    can_crypt: false,
                    trivial_clone: false,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
                response_params: {
                    type: Tpm2PcrAllocateResponseParams,
                    can_crypt: false,
                    trivial_clone: true,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::PcrSetAuthPolicy,
                name_in_camelcase: Tpm2PcrSetAuthPolicy,
                name_in_snakecase: tpm2_pcr_set_auth_policy,
                nv: true,
                platform_auth_pp: MayBeRequired,
                command_handles: {
                    type: Tpm2PcrSetAuthPolicyCommandHandles,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        {
                            name: auth_handle, type: TpmiRhPlatform,
                            auth: { index: 1, role: User, },
                        }
                    },
                },
                command_params: {
                    type: Tpm2PcrSetAuthPolicyCommandParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::PcrSetAuthValue,
                name_in_camelcase: Tpm2PcrSetAuthValue,
                name_in_snakecase: tpm2_pcr_set_auth_value,
                command_handles: {
                    type: Tpm2PcrSetAuthValueCommandHandles,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        {
                            name: pcr_handle, type: TpmiDhPcr,
                            auth: { index: 1, role: User, },
                        }
                    },
                },
                command_params: {
                    type: Tpm2PcrSetAuthValueCommandParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::PcrReset,
                name_in_camelcase: Tpm2PcrReset,
                name_in_snakecase: tpm2_pcr_reset,
                nv: true,
                command_handles: {
                    type: Tpm2PcrResetCommandHandles,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        {
                            name: pcr_handle, type: TpmiDhPcr,
                            auth: { index: 1, role: User, },
                        }
                    },
                },
            },
            {
                command_code: TpmCc::PolicySigned,
                name_in_camelcase: Tpm2PolicySigned,
                name_in_snakecase: tpm2_policy_signed,
                command_handles: {
                    type: Tpm2PolicySignedCommandHandles,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        { name: auth_object, type: TpmiDhObject, },
                        { name: policy_session, type: TpmiShPolicy, }
                    },
                },
                command_params: {
                    type: Tpm2PolicySignedCommandParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
                response_params: {
                    type: Tpm2PolicySignedResponseParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::PolicySecret,
                name_in_camelcase: Tpm2PolicySecret,
                name_in_snakecase: tpm2_policy_secret,
                command_handles: {
                    type: Tpm2PolicySecretCommandHandles,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        {
                            name: auth_handle, type: TpmiDhEntity,
                            auth: { index: 1, role: User, },
                        },
                        { name: policy_session, type: TpmiShPolicy, }
                    },
                },
                command_params: {
                    type: Tpm2PolicySecretCommandParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
                response_params: {
                    type: Tpm2PolicySecretResponseParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::PolicyTicket,
                name_in_camelcase: Tpm2PolicyTicket,
                name_in_snakecase: tpm2_policy_ticket,
                command_handles: {
                    type: Tpm2PolicyTicketCommandHandles,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        { name: policy_session, type: TpmiShPolicy, }
                    },
                },
                command_params: {
                    type: Tpm2PolicyTicketCommandParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::PolicyOR,
                name_in_camelcase: Tpm2PolicyOR,
                name_in_snakecase: tpm2_policy_or,
                command_handles: {
                    type: Tpm2PolicyORCommandHandles,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        { name: policy_session, type: TpmiShPolicy, }
                    },
                },
                command_params: {
                    type: Tpm2PolicyORCommandParams,
                    lifetime: $cp_lifetime,
                    can_crypt: false,
                    trivial_clone: false,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::PolicyPCR,
                name_in_camelcase: Tpm2PolicyPCR,
                name_in_snakecase: tpm2_policy_pcr,
                command_handles: {
                    type: Tpm2PolicyPCRCommandHandles,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        { name: policy_session, type: TpmiShPolicy, }
                    },
                },
                command_params: {
                    type: Tpm2PolicyPCRCommandParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::PolicyLocality,
                name_in_camelcase: Tpm2PolicyLocality,
                name_in_snakecase: tpm2_policy_locality,
                command_handles: {
                    type: Tpm2PolicyLocalityCommandHandles,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        { name: policy_session, type: TpmiShPolicy, }
                    },
                },
                command_params: {
                    type: Tpm2PolicyLocalityCommandParams,
                    can_crypt: false,
                    trivial_clone: true,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::PolicyNV,
                name_in_camelcase: Tpm2PolicyNV,
                name_in_snakecase: tpm2_policy_nv,
                command_handles: {
                    type: Tpm2PolicyNVCommandHandles,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        {
                            name: auth_handle, type: TpmiRhNvAuth,
                            auth: { index: 1, role: User, },
                        },
                        { name: nv_index, type: TpmiRhNvIndex, },
                        { name: policy_session, type: TpmiShPolicy, }
                    },
                },
                command_params: {
                    type: Tpm2PolicyNVCommandParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::PolicyCounterTimer,
                name_in_camelcase: Tpm2PolicyCounterTimer,
                name_in_snakecase: tpm2_policy_counter_timer,
                command_handles: {
                    type: Tpm2PolicyCounterTimerCommandHandles,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        { name: policy_session, type: TpmiShPolicy, }
                    },
                },
                command_params: {
                    type: Tpm2PolicyCounterTimerCommandParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::PolicyCommandCode,
                name_in_camelcase: Tpm2PolicyCommandCode,
                name_in_snakecase: tpm2_policy_command_code,
                command_handles: {
                    type: Tpm2PolicyCommandCodeCommandHandles,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        { name: policy_session, type: TpmiShPolicy, }
                    },
                },
                command_params: {
                    type: Tpm2PolicyCommandCodeCommandParams,
                    can_crypt: false,
                    trivial_clone: true,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::PolicyPhysicalPresence,
                name_in_camelcase: Tpm2PolicyPhysicalPresence,
                name_in_snakecase: tpm2_policy_physical_presence,
                command_handles: {
                    type: Tpm2PolicyPhysicalPresenceCommandHandles,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        { name: policy_session, type: TpmiShPolicy, }
                    },
                },
            },
            {
                command_code: TpmCc::PolicyCpHash,
                name_in_camelcase: Tpm2PolicyCpHash,
                name_in_snakecase: tpm2_policy_cp_hash,
                command_handles: {
                    type: Tpm2PolicyCpHashCommandHandles,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        { name: policy_session, type: TpmiShPolicy, }
                    },
                },
                command_params: {
                    type: Tpm2PolicyCpHashCommandParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::PolicyNameHash,
                name_in_camelcase: Tpm2PolicyNameHash,
                name_in_snakecase: tpm2_policy_name_hash,
                command_handles: {
                    type: Tpm2PolicyNameHashCommandHandles,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        { name: policy_session, type: TpmiShPolicy, }
                    },
                },
                command_params: {
                    type: Tpm2PolicyNameHashCommandParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::PolicyDuplicationSelect,
                name_in_camelcase: Tpm2PolicyDuplicationSelect,
                name_in_snakecase: tpm2_policy_duplication_select,
                command_handles: {
                    type: Tpm2PolicyDuplicationSelectCommandHandles,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        { name: policy_session, type: TpmiShPolicy, }
                    },
                },
                command_params: {
                    type: Tpm2PolicyDuplicationSelectCommandParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::PolicyAuthorize,
                name_in_camelcase: Tpm2PolicyAuthorize,
                name_in_snakecase: tpm2_policy_authorize,
                command_handles: {
                    type: Tpm2PolicyAuthorizeCommandHandles,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        { name: policy_session, type: TpmiShPolicy, }
                    },
                },
                command_params: {
                    type: Tpm2PolicyAuthorizeCommandParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::PolicyAuthValue,
                name_in_camelcase: Tpm2PolicyAuthValue,
                name_in_snakecase: tpm2_policy_auth_value,
                command_handles: {
                    type: Tpm2PolicyAuthValueCommandHandles,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        { name: policy_session, type: TpmiShPolicy, }
                    },
                },
            },
            {
                command_code: TpmCc::PolicyPassword,
                name_in_camelcase: Tpm2PolicyPassword,
                name_in_snakecase: tpm2_policy_password,
                command_handles: {
                    type: Tpm2PolicyPasswordCommandHandles,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        { name: policy_session, type: TpmiShPolicy, }
                    },
                },
            },
            {
                command_code: TpmCc::PolicyGetDigest,
                name_in_camelcase: Tpm2PolicyGetDigest,
                name_in_snakecase: tpm2_policy_get_digest,
                command_handles: {
                    type: Tpm2PolicyGetDigestCommandHandles,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        { name: policy_session, type: TpmiShPolicy, }
                    },
                },
                response_params: {
                    type: Tpm2PolicyGetDigestResponseParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::PolicyNvWritten,
                name_in_camelcase: Tpm2PolicyNvWritten,
                name_in_snakecase: tpm2_policy_nv_written,
                command_handles: {
                    type: Tpm2PolicyNvWrittenCommandHandles,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        { name: policy_session, type: TpmiShPolicy, }
                    },
                },
                command_params: {
                    type: Tpm2PolicyNvWrittenCommandParams,
                    can_crypt: false,
                    trivial_clone: true,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::PolicyTemplate,
                name_in_camelcase: Tpm2PolicyTemplate,
                name_in_snakecase: tpm2_policy_template,
                command_handles: {
                    type: Tpm2PolicyTemplateCommandHandles,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        { name: policy_session, type: TpmiShPolicy, }
                    },
                },
                command_params: {
                    type: Tpm2PolicyTemplateCommandParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::PolicyAuthorizeNV,
                name_in_camelcase: Tpm2PolicyAuthorizeNV,
                name_in_snakecase: tpm2_policy_authorize_nv,
                command_handles: {
                    type: Tpm2PolicyAuthorizeNVCommandHandles,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        {
                            name: auth_handle, type: TpmiRhNvAuth,
                            auth: { index: 1, role: User, },
                        },
                        { name: nv_index, type: TpmiRhNvIndex, },
                        { name: policy_session, type: TpmiShPolicy, }
                    },
                },
            },
            {
                command_code: TpmCc::PolicyCapability,
                name_in_camelcase: Tpm2PolicyCapability,
                name_in_snakecase: tpm2_policy_capability,
                command_handles: {
                    type: Tpm2PolicyCapabilityCommandHandles,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        { name: policy_session, type: TpmiShPolicy, }
                    },
                },
                command_params: {
                    type: Tpm2PolicyCapabilityCommandParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::PolicyParameters,
                name_in_camelcase: Tpm2PolicyParameters,
                name_in_snakecase: tpm2_policy_parameters,
                command_handles: {
                    type: Tpm2PolicyParametersCommandHandles,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        { name: policy_session, type: TpmiShPolicy, }
                    },
                },
                command_params: {
                    type: Tpm2PolicyParametersCommandParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::PolicyTransportSPDM,
                name_in_camelcase: Tpm2PolicyTransportSPDM,
                name_in_snakecase: tpm2_policy_transport_spdm,
                command_handles: {
                    type: Tpm2PolicyTransportSPDMCommandHandles,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        { name: policy_session, type: TpmiShPolicy, }
                    },
                },
                command_params: {
                    type: Tpm2PolicyTransportSPDMCommandParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::CreatePrimary,
                name_in_camelcase: Tpm2CreatePrimary,
                name_in_snakecase: tpm2_create_primary,
                platform_auth_pp: MayBeRequired,
                command_handles: {
                    type: Tpm2CreatePrimaryCommandHandles,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        {
                            name: primary_handle, type: TpmiRhHierarchy,
                            auth: { index: 1, role: User, },
                        }
                    },
                },
                command_params: {
                    type: Tpm2CreatePrimaryCommandParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
                response_handles: {
                    type: Tpm2CreatePrimaryResponseHandles,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        { name: object_handle, type: u32, }
                    },
                },
                response_params: {
                    type: Tpm2CreatePrimaryResponseParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::HierarchyControl,
                name_in_camelcase: Tpm2HierarchyControl,
                name_in_snakecase: tpm2_hierarchy_control,
                nv: true,
                flushing: Extensive,
                platform_auth_pp: MayBeRequired,
                command_handles: {
                    type: Tpm2HierarchyControlCommandHandles,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        {
                            name: auth_handle, type: TpmiRhBaseHierarchy,
                            auth: { index: 1, role: User, },
                        }
                    },
                },
                command_params: {
                    type: Tpm2HierarchyControlCommandParams,
                    can_crypt: false,
                    trivial_clone: true,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::SetPrimaryPolicy,
                name_in_camelcase: Tpm2SetPrimaryPolicy,
                name_in_snakecase: tpm2_set_primary_policy,
                nv: true,
                platform_auth_pp: MayBeRequired,
                command_handles: {
                    type: Tpm2SetPrimaryPolicyCommandHandles,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        {
                            name: auth_handle, type: TpmiRhHierarchyPolicy,
                            auth: { index: 1, role: User, },
                        }
                    },
                },
                command_params: {
                    type: Tpm2SetPrimaryPolicyCommandParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::ChangePPS,
                name_in_camelcase: Tpm2ChangePPS,
                name_in_snakecase: tpm2_change_pps,
                nv: true,
                flushing: Extensive,
                platform_auth_pp: MayBeRequired,
                command_handles: {
                    type: Tpm2ChangePPSCommandHandles,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        {
                            name: auth_handle, type: TpmiRhPlatform,
                            auth: { index: 1, role: User, },
                        }
                    },
                },
            },
            {
                command_code: TpmCc::ChangeEPS,
                name_in_camelcase: Tpm2ChangeEPS,
                name_in_snakecase: tpm2_change_eps,
                nv: true,
                flushing: Extensive,
                platform_auth_pp: MayBeRequired,
                command_handles: {
                    type: Tpm2ChangeEPSCommandHandles,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        {
                            name: auth_handle, type: TpmiRhPlatform,
                            auth: { index: 1, role: User, },
                        }
                    },
                },
            },
            {
                command_code: TpmCc::Clear,
                name_in_camelcase: Tpm2Clear,
                name_in_snakecase: tpm2_clear,
                nv: true,
                flushing: Extensive,
                platform_auth_pp: MayBeRequired,
                command_handles: {
                    type: Tpm2ClearCommandHandles,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        {
                            name: auth_handle, type: TpmiRhClear,
                            auth: { index: 1, role: User, },
                        }
                    },
                },
            },
            {
                command_code: TpmCc::ClearControl,
                name_in_camelcase: Tpm2ClearControl,
                name_in_snakecase: tpm2_clear_control,
                nv: true,
                platform_auth_pp: MayBeRequired,
                command_handles: {
                    type: Tpm2ClearControlCommandHandles,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        {
                            name: auth, type: TpmiRhClear,
                            auth: { index: 1, role: User, },
                        }
                    },
                },
                command_params: {
                    type: Tpm2ClearControlCommandParams,
                    can_crypt: false,
                    trivial_clone: true,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::HierarchyChangeAuth,
                name_in_camelcase: Tpm2HierarchyChangeAuth,
                name_in_snakecase: tpm2_hierarchy_change_auth,
                nv: true,
                platform_auth_pp: MayBeRequired,
                command_handles: {
                    type: Tpm2HierarchyChangeAuthCommandHandles,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        {
                            name: auth_handle, type: TpmiRhHierarchyAuth,
                            auth: { index: 1, role: User, },
                        }
                    },
                },
                command_params: {
                    type: Tpm2HierarchyChangeAuthCommandParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::ReadOnlyControl,
                name_in_camelcase: Tpm2ReadOnlyControl,
                name_in_snakecase: tpm2_read_only_control,
                platform_auth_pp: MayBeRequired,
                command_handles: {
                    type: Tpm2ReadOnlyControlCommandHandles,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        {
                            name: auth_handle, type: TpmiRhPlatform,
                            auth: { index: 1, role: User, },
                        }
                    },
                },
                command_params: {
                    type: Tpm2ReadOnlyControlCommandParams,
                    can_crypt: false,
                    trivial_clone: true,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::DictionaryAttackLockReset,
                name_in_camelcase: Tpm2DictionaryAttackLockReset,
                name_in_snakecase: tpm2_dictionary_attack_lock_reset,
                nv: true,
                command_handles: {
                    type: Tpm2DictionaryAttackLockResetCommandHandles,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        {
                            name: lock_handle, type: TpmiRhLockout,
                            auth: { index: 1, role: User, },
                        }
                    },
                },
            },
            {
                command_code: TpmCc::DictionaryAttackParameters,
                name_in_camelcase: Tpm2DictionaryAttackParameters,
                name_in_snakecase: tpm2_dictionary_attack_parameters,
                nv: true,
                command_handles: {
                    type: Tpm2DictionaryAttackParametersCommandHandles,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        {
                            name: lock_handle, type: TpmiRhLockout,
                            auth: { index: 1, role: User, },
                        }
                    },
                },
                command_params: {
                    type: Tpm2DictionaryAttackParametersCommandParams,
                    can_crypt: false,
                    trivial_clone: true,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::PpCommands,
                name_in_camelcase: Tpm2PpCommands,
                name_in_snakecase: tpm2_pp_commands,
                nv: true,
                platform_auth_pp: IsRequired,
                command_handles: {
                    type: Tpm2PpCommandsCommandHandles,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        {
                            name: auth, type: TpmiRhPlatform,
                            auth: { index: 1, role: User, },
                        }
                    },
                },
                command_params: {
                    type: Tpm2PpCommandsCommandParams,
                    can_crypt: false,
                    trivial_clone: false,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::SetAlgorithmSet,
                name_in_camelcase: Tpm2SetAlgorithmSet,
                name_in_snakecase: tpm2_set_algorithm_set,
                nv: true,
                command_handles: {
                    type: Tpm2SetAlgorithmSetCommandHandles,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        {
                            name: auth_handle, type: TpmiRhPlatform,
                            auth: { index: 1, role: User, },
                        }
                    },
                },
                command_params: {
                    type: Tpm2SetAlgorithmSetCommandParams,
                    can_crypt: false,
                    trivial_clone: true,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::FieldUpgradeStart,
                name_in_camelcase: Tpm2FieldUpgradeStart,
                name_in_snakecase: tpm2_field_upgrade_start,
                command_handles: {
                    type: Tpm2FieldUpgradeStartCommandHandles,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        {
                            name: authorization, type: TpmiRhPlatform,
                            auth: { index: 1, role: Admin, },
                        },
                        { name: key_handle, type: TpmiDhObject, }
                    },
                },
                command_params: {
                    type: Tpm2FieldUpgradeStartCommandParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::FieldUpgradeData,
                name_in_camelcase: Tpm2FieldUpgradeData,
                name_in_snakecase: tpm2_field_upgrade_data,
                nv: true,
                command_params: {
                    type: Tpm2FieldUpgradeDataCommandParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
                response_params: {
                    type: Tpm2FieldUpgradeDataResponseParams,
                    lifetime: $cp_lifetime,
                    can_crypt: false,
                    trivial_clone: false,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::FirmwareRead,
                name_in_camelcase: Tpm2FirmwareRead,
                name_in_snakecase: tpm2_firmware_read,
                command_params: {
                    type: Tpm2FirmwareReadCommandParams,
                    can_crypt: false,
                    trivial_clone: true,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
                response_params: {
                    type: Tpm2FirmwareReadResponseParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::ContextSave,
                name_in_camelcase: Tpm2ContextSave,
                name_in_snakecase: tpm2_context_save,
                command_handles: {
                    type: Tpm2ContextSaveCommandHandles,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        { name: save_handle, type: TpmiDhContext, }
                    },
                },
                response_params: {
                    type: Tpm2ContextSaveResponseParams,
                    lifetime: $cp_lifetime,
                    can_crypt: false,
                    trivial_clone: false,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::ContextLoad,
                name_in_camelcase: Tpm2ContextLoad,
                name_in_snakecase: tpm2_context_load,
                command_params: {
                    type: Tpm2ContextLoadCommandParams,
                    lifetime: $cp_lifetime,
                    can_crypt: false,
                    trivial_clone: false,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
                response_handles: {
                    type: Tpm2ContextLoadResponseHandles,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        { name: loaded_handle, type: TpmiDhContext, }
                    },
                },
            },
            {
                command_code: TpmCc::FlushContext,
                name_in_camelcase: Tpm2FlushContext,
                name_in_snakecase: tpm2_flush_context,
                command_params: {
                    type: Tpm2FlushContextCommandParams,
                    can_crypt: false,
                    trivial_clone: true,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::EvictControl,
                name_in_camelcase: Tpm2EvictControl,
                name_in_snakecase: tpm2_evict_control,
                nv: true,
                command_handles: {
                    type: Tpm2EvictControlCommandHandles,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        {
                            name: auth, type: TpmiRhProvision,
                            auth: { index: 1, role: User, },
                        },
                        { name: object_handle, type: TpmiDhObject, }
                    },
                },
                command_params: {
                    type: Tpm2EvictControlCommandParams,
                    can_crypt: false,
                    trivial_clone: true,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::ReadClock,
                name_in_camelcase: Tpm2ReadClock,
                name_in_snakecase: tpm2_read_clock,
                response_params: {
                    type: Tpm2ReadClockResponseParams,
                    can_crypt: false,
                    trivial_clone: true,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::ClockSet,
                name_in_camelcase: Tpm2ClockSet,
                name_in_snakecase: tpm2_clock_set,
                nv: true,
                platform_auth_pp: MayBeRequired,
                command_handles: {
                    type: Tpm2ClockSetCommandHandles,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        {
                            name: auth, type: TpmiRhProvision,
                            auth: { index: 1, role: User, },
                        }
                    },
                },
                command_params: {
                    type: Tpm2ClockSetCommandParams,
                    can_crypt: false,
                    trivial_clone: true,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::ClockRateAdjust,
                name_in_camelcase: Tpm2ClockRateAdjust,
                name_in_snakecase: tpm2_clock_rate_adjust,
                platform_auth_pp: MayBeRequired,
                command_handles: {
                    type: Tpm2ClockRateAdjustCommandHandles,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        {
                            name: auth, type: TpmiRhProvision,
                            auth: { index: 1, role: User, },
                        }
                    },
                },
                command_params: {
                    type: Tpm2ClockRateAdjustCommandParams,
                    can_crypt: false,
                    trivial_clone: true,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::GetCapability,
                name_in_camelcase: Tpm2GetCapability,
                name_in_snakecase: tpm2_get_capability,
                command_params: {
                    type: Tpm2GetCapabilityCommandParams,
                    can_crypt: false,
                    trivial_clone: true,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
                response_params: {
                    type: Tpm2GetCapabilityResponseParams,
                    lifetime: $cp_lifetime,
                    can_crypt: false,
                    trivial_clone: false,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::TestParms,
                name_in_camelcase: Tpm2TestParms,
                name_in_snakecase: tpm2_test_parms,
                command_params: {
                    type: Tpm2TestParmsCommandParams,
                    can_crypt: false,
                    trivial_clone: true,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::SetCapability,
                name_in_camelcase: Tpm2SetCapability,
                name_in_snakecase: tpm2_set_capability,
                nv: true,
                platform_auth_pp: MayBeRequired,
                command_handles: {
                    type: Tpm2SetCapabilityCommandHandles,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        {
                            name: auth_handle, type: TpmiRhHierarchyAuthWCV,
                            auth: { index: 1, role: User, },
                        }
                    },
                },
                command_params: {
                    type: Tpm2SetCapabilityCommandParams,
                    can_crypt: true,
                    trivial_clone: true,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::NvDefineSpace,
                name_in_camelcase: Tpm2NvDefineSpace,
                name_in_snakecase: tpm2_nv_define_space,
                nv: true,
                platform_auth_pp: MayBeRequired,
                command_handles: {
                    type: Tpm2NvDefineSpaceCommandHandles,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        {
                            name: auth_handle, type: TpmiRhProvision,
                            auth: { index: 1, role: User, },
                        }
                    },
                },
                command_params: {
                    type: Tpm2NvDefineSpaceCommandParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::NvUndefineSpace,
                name_in_camelcase: Tpm2NvUndefineSpace,
                name_in_snakecase: tpm2_nv_undefine_space,
                nv: true,
                command_handles: {
                    type: Tpm2NvUndefineSpaceCommandHandles,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        {
                            name: auth_handle, type: TpmiRhProvision,
                            auth: { index: 1, role: User, },
                        },
                        { name: nv_index, type: TpmiRhNvDefinedIndex, }
                    },
                },
            },
            {
                command_code: TpmCc::NvUndefineSpaceSpecial,
                name_in_camelcase: Tpm2NvUndefineSpaceSpecial,
                name_in_snakecase: tpm2_nv_undefine_space_special,
                nv: true,
                platform_auth_pp: MayBeRequired,
                command_handles: {
                    type: Tpm2NvUndefineSpaceSpecialCommandHandles,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        {
                            name: nv_index, type: TpmiRhNvDefinedIndex,
                            auth: { index: 1, role: Admin, },
                        },
                        {
                            name: platform, type: TpmiRhPlatform,
                            auth: { index: 2, role: User, },
                        }
                    },
                },
            },
            {
                command_code: TpmCc::NvReadPublic,
                name_in_camelcase: Tpm2NvReadPublic,
                name_in_snakecase: tpm2_nv_read_public,
                command_handles: {
                    type: Tpm2NvReadPublicCommandHandles,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        { name: nv_index, type: TpmiRhNvIndex, }
                    },
                },
                response_params: {
                    type: Tpm2NvReadPublicResponseParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::NvWrite,
                name_in_camelcase: Tpm2NvWrite,
                name_in_snakecase: tpm2_nv_write,
                nv: true,
                command_handles: {
                    type: Tpm2NvWriteCommandHandles,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        {
                            name: auth_handle, type: TpmiRhNvAuth,
                            auth: { index: 1, role: User, },
                        },
                        { name: nv_index, type: TpmiRhNvIndex, }
                    },
                },
                command_params: {
                    type: Tpm2NvWriteCommandParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::NvIncrement,
                name_in_camelcase: Tpm2NvIncrement,
                name_in_snakecase: tpm2_nv_increment,
                nv: true,
                command_handles: {
                    type: Tpm2NvIncrementCommandHandles,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        {
                            name: auth_handle, type: TpmiRhNvAuth,
                            auth: { index: 1, role: User, },
                        },
                        { name: nv_index, type: TpmiRhNvIndex, }
                    },
                },
            },
            {
                command_code: TpmCc::NvExtend,
                name_in_camelcase: Tpm2NvExtend,
                name_in_snakecase: tpm2_nv_extend,
                nv: true,
                command_handles: {
                    type: Tpm2NvExtendCommandHandles,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        {
                            name: auth_handle, type: TpmiRhNvAuth,
                            auth: { index: 1, role: User, },
                        },
                        { name: nv_index, type: TpmiRhNvIndex, }
                    },
                },
                command_params: {
                    type: Tpm2NvExtendCommandParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::NvSetBits,
                name_in_camelcase: Tpm2NvSetBits,
                name_in_snakecase: tpm2_nv_set_bits,
                nv: true,
                command_handles: {
                    type: Tpm2NvSetBitsCommandHandles,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        {
                            name: auth_handle, type: TpmiRhNvAuth,
                            auth: { index: 1, role: User, },
                        },
                        { name: nv_index, type: TpmiRhNvIndex, }
                    },
                },
                command_params: {
                    type: Tpm2NvSetBitsCommandParams,
                    can_crypt: false,
                    trivial_clone: true,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::NvWriteLock,
                name_in_camelcase: Tpm2NvWriteLock,
                name_in_snakecase: tpm2_nv_write_lock,
                nv: true,
                command_handles: {
                    type: Tpm2NvWriteLockCommandHandles,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        {
                            name: auth_handle, type: TpmiRhNvAuth,
                            auth: { index: 1, role: User, },
                        },
                        { name: nv_index, type: TpmiRhNvIndex, }
                    },
                },
            },
            {
                command_code: TpmCc::NvGlobalWriteLock,
                name_in_camelcase: Tpm2NvGlobalWriteLock,
                name_in_snakecase: tpm2_nv_global_write_lock,
                nv: true,
                platform_auth_pp: MayBeRequired,
                command_handles: {
                    type: Tpm2NvGlobalWriteLockCommandHandles,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        {
                            name: auth_handle, type: TpmiRhProvision,
                            auth: { index: 1, role: User, },
                        }
                    },
                },
            },
            {
                command_code: TpmCc::NvRead,
                name_in_camelcase: Tpm2NvRead,
                name_in_snakecase: tpm2_nv_read,
                command_handles: {
                    type: Tpm2NvReadCommandHandles,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        {
                            name: auth_handle, type: TpmiRhNvAuth,
                            auth: { index: 1, role: User, },
                        },
                        { name: nv_index, type: TpmiRhNvIndex, }
                    },
                },
                command_params: {
                    type: Tpm2NvReadCommandParams,
                    can_crypt: false,
                    trivial_clone: true,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
                response_params: {
                    type: Tpm2NvReadResponseParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::NvReadLock,
                name_in_camelcase: Tpm2NvReadLock,
                name_in_snakecase: tpm2_nv_read_lock,
                nv: true,
                command_handles: {
                    type: Tpm2NvReadLockCommandHandles,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        {
                            name: auth_handle, type: TpmiRhNvAuth,
                            auth: { index: 1, role: User, },
                        },
                        { name: nv_index, type: TpmiRhNvIndex, }
                    },
                },
            },
            {
                command_code: TpmCc::NvChangeAuth,
                name_in_camelcase: Tpm2NvChangeAuth,
                name_in_snakecase: tpm2_nv_change_auth,
                nv: true,
                command_handles: {
                    type: Tpm2NvChangeAuthCommandHandles,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        {
                            name: nv_index, type: TpmiRhNvIndex,
                            auth: { index: 1, role: Admin, },
                        }
                    },
                },
                command_params: {
                    type: Tpm2NvChangeAuthCommandParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::NvCertify,
                name_in_camelcase: Tpm2NvCertify,
                name_in_snakecase: tpm2_nv_certify,
                command_handles: {
                    type: Tpm2NvCertifyCommandHandles,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        {
                            name: sign_handle, type: TpmiDhObjectWCV,
                            auth: { index: 1, role: User, },
                        },
                        {
                            name: auth_handle, type: TpmiRhNvAuth,
                            auth: { index: 2, role: User, },
                        },
                        { name: nv_index, type: TpmiRhNvIndex, }
                    },
                },
                command_params: {
                    type: Tpm2NvCertifyCommandParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
                response_params: {
                    type: Tpm2NvCertifyResponseParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::NvDefineSpace2,
                name_in_camelcase: Tpm2NvDefineSpace2,
                name_in_snakecase: tpm2_nv_define_space2,
                nv: true,
                platform_auth_pp: MayBeRequired,
                command_handles: {
                    type: Tpm2NvDefineSpace2CommandHandles,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        {
                            name: auth_handle, type: TpmiRhProvision,
                            auth: { index: 1, role: User, },
                        }
                    },
                },
                command_params: {
                    type: Tpm2NvDefineSpace2CommandParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::NvReadPublic2,
                name_in_camelcase: Tpm2NvReadPublic2,
                name_in_snakecase: tpm2_nv_read_public2,
                command_handles: {
                    type: Tpm2NvReadPublic2CommandHandles,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        { name: nv_index, type: TpmiRhNvIndex, }
                    },
                },
                response_params: {
                    type: Tpm2NvReadPublic2ResponseParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::AcGetCapability,
                name_in_camelcase: Tpm2AcGetCapability,
                name_in_snakecase: tpm2_ac_get_capability,
                command_handles: {
                    type: Tpm2AcGetCapabilityCommandHandles,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        { name: ac, type: TpmiRhAc, }
                    },
                },
                command_params: {
                    type: Tpm2AcGetCapabilityCommandParams,
                    can_crypt: false,
                    trivial_clone: true,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
                response_params: {
                    type: Tpm2AcGetCapabilityResponseParams,
                    can_crypt: false,
                    trivial_clone: false,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::AcSend,
                name_in_camelcase: Tpm2AcSend,
                name_in_snakecase: tpm2_ac_send,
                command_handles: {
                    type: Tpm2AcSendCommandHandles,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        {
                            name: send_object, type: TpmiDhObject,
                            auth: { index: 1, role: Dup, },
                        },
                        {
                            name: auth_handle, type: TpmiRhNvAuth,
                            auth: { index: 2, role: User, },
                        },
                        { name: ac, type: TpmiRhAc, }
                    },
                },
                command_params: {
                    type: Tpm2AcSendCommandParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
                response_params: {
                    type: Tpm2AcSendResponseParams,
                    can_crypt: false,
                    trivial_clone: true,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::PolicyAcSendSelect,
                name_in_camelcase: Tpm2PolicyAcSendSelect,
                name_in_snakecase: tpm2_policy_ac_send_select,
                command_handles: {
                    type: Tpm2PolicyAcSendSelectCommandHandles,
                    unmarshal_needs_limits: true,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        { name: policy_session, type: TpmiShPolicy, }
                    },
                },
                command_params: {
                    type: Tpm2PolicyAcSendSelectCommandParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::ActSetTimeout,
                name_in_camelcase: Tpm2ActSetTimeout,
                name_in_snakecase: tpm2_act_set_timeout,
                command_handles: {
                    type: Tpm2ActSetTimeoutCommandHandles,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                    handles: {
                        {
                            name: act_handle, type: TpmiRhAct,
                            auth: { index: 1, role: User, },
                        }
                    },
                },
                command_params: {
                    type: Tpm2ActSetTimeoutCommandParams,
                    can_crypt: false,
                    trivial_clone: true,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            },
            {
                command_code: TpmCc::VendorTcgTest,
                name_in_camelcase: Tpm2VendorTcgTest,
                name_in_snakecase: tpm2_vendor_tcg_test,
                command_params: {
                    type: Tpm2VendorTcgTestCommandParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
                response_params: {
                    type: Tpm2VendorTcgTestResponseParams,
                    lifetime: $cp_lifetime,
                    can_crypt: true,
                    trivial_clone: false,
                    unmarshal_needs_limits: false,
                    marshalled_size_needs_limits: false,
                    marshal_needs_limits: false,
                },
            }
        ]
    };
}
